// Code generated from ClickHouseParser.g4 by ANTLR 4.9. DO NOT EDIT.

package clickhouse_parser // ClickHouseParser
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 224, 1918,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 3, 2, 3,
	2, 3, 2, 3, 2, 5, 2, 225, 10, 2, 3, 2, 3, 2, 5, 2, 229, 10, 2, 3, 2, 5,
	2, 232, 10, 2, 3, 2, 5, 2, 235, 10, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 5, 3, 255, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 261, 10, 4, 3, 4, 3,
	4, 3, 4, 7, 4, 266, 10, 4, 12, 4, 14, 4, 269, 11, 4, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 5, 5, 276, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 281, 10, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 288, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 293,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 300, 10, 5, 3, 5, 3, 5, 3, 5,
	5, 5, 305, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 311, 10, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 5, 5, 317, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 322, 10, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 5, 5, 328, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 333, 10, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 339, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 344,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 350, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 364, 10, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 371, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	5, 5, 378, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 385, 10, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 5, 5, 391, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 396, 10, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 402, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 407,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 413, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 5, 5, 422, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 5, 5, 432, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 5, 5, 442, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 462,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 470, 10, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5,
	485, 10, 5, 3, 6, 3, 6, 3, 6, 7, 6, 490, 10, 6, 12, 6, 14, 6, 493, 11,
	6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 5,
	9, 506, 10, 9, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 512, 10, 10, 3, 11, 3,
	11, 3, 11, 3, 11, 5, 11, 518, 10, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12,
	5, 12, 525, 10, 12, 3, 12, 3, 12, 5, 12, 529, 10, 12, 3, 12, 5, 12, 532,
	10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 539, 10, 12, 3, 12, 3,
	12, 5, 12, 543, 10, 12, 3, 12, 5, 12, 546, 10, 12, 3, 12, 3, 12, 3, 12,
	3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 557, 10, 12, 3, 12, 3,
	12, 5, 12, 561, 10, 12, 3, 12, 5, 12, 564, 10, 12, 3, 12, 3, 12, 3, 12,
	5, 12, 569, 10, 12, 5, 12, 571, 10, 12, 3, 12, 5, 12, 574, 10, 12, 3, 12,
	5, 12, 577, 10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3,
	12, 5, 12, 587, 10, 12, 3, 12, 3, 12, 5, 12, 591, 10, 12, 3, 12, 5, 12,
	594, 10, 12, 3, 12, 5, 12, 597, 10, 12, 3, 12, 3, 12, 3, 12, 5, 12, 602,
	10, 12, 5, 12, 604, 10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 610, 10,
	12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 616, 10, 12, 3, 12, 3, 12, 5, 12,
	620, 10, 12, 3, 12, 5, 12, 623, 10, 12, 3, 12, 5, 12, 626, 10, 12, 3, 12,
	5, 12, 629, 10, 12, 3, 12, 5, 12, 632, 10, 12, 3, 12, 3, 12, 3, 12, 5,
	12, 637, 10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 643, 10, 12, 3, 12,
	3, 12, 5, 12, 647, 10, 12, 3, 12, 5, 12, 650, 10, 12, 3, 12, 5, 12, 653,
	10, 12, 3, 12, 3, 12, 5, 12, 657, 10, 12, 3, 13, 3, 13, 3, 13, 3, 13, 7,
	13, 663, 10, 13, 12, 13, 14, 13, 666, 11, 13, 3, 13, 3, 13, 3, 14, 3, 14,
	3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3,
	14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 7, 14, 691,
	10, 14, 12, 14, 14, 14, 694, 11, 14, 3, 15, 5, 15, 697, 10, 15, 3, 15,
	3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3,
	15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 7, 15, 719,
	10, 15, 12, 15, 14, 15, 722, 11, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 17,
	3, 17, 3, 17, 3, 17, 5, 17, 732, 10, 17, 3, 17, 5, 17, 735, 10, 17, 3,
	18, 3, 18, 3, 18, 3, 18, 3, 18, 7, 18, 742, 10, 18, 12, 18, 14, 18, 745,
	11, 18, 3, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 761, 10, 19, 3, 19, 3, 19, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 7, 20, 770, 10, 20, 12, 20, 14, 20, 773,
	11, 20, 3, 20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 790, 10, 21, 3, 21, 3,
	21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23,
	803, 10, 23, 3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 3, 26, 3, 26, 3,
	26, 3, 27, 3, 27, 3, 27, 3, 27, 7, 27, 818, 10, 27, 12, 27, 14, 27, 821,
	11, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 829, 10, 27, 3,
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 3, 28, 3, 28, 3, 28, 7, 28, 856, 10, 28, 12, 28, 14, 28, 859, 11, 28,
	3, 29, 3, 29, 3, 29, 3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 31, 3, 31, 3,
	31, 3, 31, 3, 32, 3, 32, 3, 32, 3, 32, 7, 32, 877, 10, 32, 12, 32, 14,
	32, 880, 11, 32, 3, 33, 3, 33, 5, 33, 884, 10, 33, 3, 33, 3, 33, 3, 33,
	5, 33, 889, 10, 33, 3, 33, 5, 33, 892, 10, 33, 3, 34, 3, 34, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 904, 10, 34, 3, 35,
	3, 35, 3, 35, 5, 35, 909, 10, 35, 3, 35, 3, 35, 5, 35, 913, 10, 35, 3,
	35, 5, 35, 916, 10, 35, 3, 35, 3, 35, 5, 35, 920, 10, 35, 3, 35, 3, 35,
	5, 35, 924, 10, 35, 3, 35, 3, 35, 3, 35, 5, 35, 929, 10, 35, 3, 35, 5,
	35, 932, 10, 35, 3, 35, 3, 35, 5, 35, 936, 10, 35, 5, 35, 938, 10, 35,
	3, 36, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3,
	38, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 7, 39, 958, 10, 39,
	12, 39, 14, 39, 961, 11, 39, 3, 39, 3, 39, 3, 40, 3, 40, 3, 40, 5, 40,
	968, 10, 40, 3, 40, 5, 40, 971, 10, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3,
	41, 3, 41, 3, 41, 3, 41, 5, 41, 981, 10, 41, 3, 42, 3, 42, 5, 42, 985,
	10, 42, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 993, 10, 43, 3,
	43, 3, 43, 5, 43, 997, 10, 43, 3, 43, 3, 43, 3, 43, 5, 43, 1002, 10, 43,
	3, 43, 3, 43, 5, 43, 1006, 10, 43, 3, 43, 3, 43, 5, 43, 1010, 10, 43, 3,
	43, 3, 43, 5, 43, 1014, 10, 43, 3, 43, 3, 43, 5, 43, 1018, 10, 43, 5, 43,
	1020, 10, 43, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 1028, 10,
	44, 3, 44, 3, 44, 5, 44, 1032, 10, 44, 3, 44, 5, 44, 1035, 10, 44, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 1043, 10, 45, 3, 46, 3, 46, 3,
	46, 5, 46, 1048, 10, 46, 3, 46, 3, 46, 3, 46, 5, 46, 1053, 10, 46, 3, 46,
	5, 46, 1056, 10, 46, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 3, 47, 7, 47, 1064,
	10, 47, 12, 47, 14, 47, 1067, 11, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48,
	3, 48, 3, 48, 5, 48, 1076, 10, 48, 3, 48, 3, 48, 5, 48, 1080, 10, 48, 3,
	49, 3, 49, 3, 49, 5, 49, 1085, 10, 49, 3, 49, 3, 49, 5, 49, 1089, 10, 49,
	3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 1095, 10, 50, 3, 50, 5, 50, 1098, 10,
	50, 3, 50, 5, 50, 1101, 10, 50, 3, 50, 5, 50, 1104, 10, 50, 3, 51, 3, 51,
	3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 7, 51, 1116, 10,
	51, 12, 51, 14, 51, 1119, 11, 51, 3, 51, 5, 51, 1122, 10, 51, 3, 52, 3,
	52, 5, 52, 1126, 10, 52, 3, 52, 3, 52, 3, 52, 5, 52, 1131, 10, 52, 3, 52,
	5, 52, 1134, 10, 52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 53, 7, 53, 1142,
	10, 53, 12, 53, 14, 53, 1145, 11, 53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54,
	5, 54, 1152, 10, 54, 3, 55, 5, 55, 1155, 10, 55, 3, 55, 3, 55, 5, 55, 1159,
	10, 55, 3, 55, 5, 55, 1162, 10, 55, 3, 55, 3, 55, 5, 55, 1166, 10, 55,
	3, 55, 5, 55, 1169, 10, 55, 3, 55, 5, 55, 1172, 10, 55, 3, 55, 5, 55, 1175,
	10, 55, 3, 55, 5, 55, 1178, 10, 55, 3, 55, 3, 55, 5, 55, 1182, 10, 55,
	3, 55, 3, 55, 5, 55, 1186, 10, 55, 3, 55, 5, 55, 1189, 10, 55, 3, 55, 5,
	55, 1192, 10, 55, 3, 55, 5, 55, 1195, 10, 55, 3, 55, 5, 55, 1198, 10, 55,
	3, 55, 5, 55, 1201, 10, 55, 3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 3, 57, 3,
	57, 5, 57, 1210, 10, 57, 3, 58, 3, 58, 3, 58, 3, 59, 5, 59, 1216, 10, 59,
	3, 59, 3, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 61, 3, 61, 3, 61, 3,
	62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 5, 62, 1236, 10, 62,
	3, 63, 3, 63, 3, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3,
	65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67,
	1258, 10, 67, 3, 68, 3, 68, 3, 68, 3, 69, 3, 69, 3, 69, 5, 69, 1266, 10,
	69, 3, 69, 5, 69, 1269, 10, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1275,
	10, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1283, 10, 69,
	3, 69, 5, 69, 1286, 10, 69, 3, 69, 3, 69, 3, 69, 3, 69, 7, 69, 1292, 10,
	69, 12, 69, 14, 69, 1295, 11, 69, 3, 70, 5, 70, 1298, 10, 70, 3, 70, 3,
	70, 3, 70, 5, 70, 1303, 10, 70, 3, 70, 5, 70, 1306, 10, 70, 3, 70, 5, 70,
	1309, 10, 70, 3, 70, 3, 70, 5, 70, 1313, 10, 70, 3, 70, 3, 70, 5, 70, 1317,
	10, 70, 3, 70, 5, 70, 1320, 10, 70, 5, 70, 1322, 10, 70, 3, 70, 5, 70,
	1325, 10, 70, 3, 70, 3, 70, 5, 70, 1329, 10, 70, 3, 70, 3, 70, 5, 70, 1333,
	10, 70, 3, 70, 5, 70, 1336, 10, 70, 5, 70, 1338, 10, 70, 5, 70, 1340, 10,
	70, 3, 71, 5, 71, 1343, 10, 71, 3, 71, 3, 71, 3, 71, 5, 71, 1348, 10, 71,
	3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 1359,
	10, 72, 3, 73, 3, 73, 3, 73, 3, 73, 5, 73, 1365, 10, 73, 3, 74, 3, 74,
	3, 74, 5, 74, 1370, 10, 74, 3, 75, 3, 75, 3, 75, 7, 75, 1375, 10, 75, 12,
	75, 14, 75, 1378, 11, 75, 3, 76, 3, 76, 5, 76, 1382, 10, 76, 3, 76, 3,
	76, 5, 76, 1386, 10, 76, 3, 76, 3, 76, 5, 76, 1390, 10, 76, 3, 77, 3, 77,
	3, 77, 5, 77, 1395, 10, 77, 3, 78, 3, 78, 3, 78, 7, 78, 1400, 10, 78, 12,
	78, 14, 78, 1403, 11, 78, 3, 79, 3, 79, 3, 79, 3, 79, 3, 80, 3, 80, 3,
	80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81,
	3, 81, 5, 81, 1423, 10, 81, 3, 81, 5, 81, 1426, 10, 81, 3, 81, 3, 81, 3,
	81, 3, 81, 3, 81, 3, 81, 3, 81, 5, 81, 1435, 10, 81, 3, 81, 3, 81, 5, 81,
	1439, 10, 81, 3, 81, 3, 81, 3, 81, 5, 81, 1444, 10, 81, 3, 81, 3, 81, 3,
	81, 5, 81, 1449, 10, 81, 3, 81, 5, 81, 1452, 10, 81, 5, 81, 1454, 10, 81,
	3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3,
	82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82,
	1476, 10, 82, 3, 82, 5, 82, 1479, 10, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3,
	82, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 1490, 10, 82, 3, 83, 3, 83, 5, 83,
	1494, 10, 83, 3, 83, 5, 83, 1497, 10, 83, 3, 83, 3, 83, 5, 83, 1501, 10,
	83, 3, 83, 3, 83, 5, 83, 1505, 10, 83, 3, 84, 3, 84, 3, 84, 3, 85, 3, 85,
	3, 85, 5, 85, 1513, 10, 85, 3, 85, 3, 85, 5, 85, 1517, 10, 85, 3, 86, 3,
	86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 7, 86, 1528, 10, 86,
	12, 86, 14, 86, 1531, 11, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86,
	3, 86, 7, 86, 1540, 10, 86, 12, 86, 14, 86, 1543, 11, 86, 3, 86, 3, 86,
	3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 7, 86, 1552, 10, 86, 12, 86, 14, 86,
	1555, 11, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 5, 86, 1562, 10, 86, 3,
	86, 3, 86, 5, 86, 1566, 10, 86, 3, 87, 3, 87, 3, 87, 7, 87, 1571, 10, 87,
	12, 87, 14, 87, 1574, 11, 87, 3, 88, 3, 88, 3, 88, 5, 88, 1579, 10, 88,
	3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88, 1587, 10, 88, 3, 89, 3,
	89, 3, 89, 5, 89, 1592, 10, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 6, 89,
	1599, 10, 89, 13, 89, 14, 89, 1600, 3, 89, 3, 89, 5, 89, 1605, 10, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3,
	89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1636, 10,
	89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1653, 10, 89, 3, 89, 5, 89, 1656,
	10, 89, 3, 89, 3, 89, 5, 89, 1660, 10, 89, 3, 89, 5, 89, 1663, 10, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5,
	89, 1675, 10, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1692, 10, 89, 3,
	89, 3, 89, 5, 89, 1696, 10, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1713,
	10, 89, 3, 89, 5, 89, 1716, 10, 89, 3, 89, 3, 89, 5, 89, 1720, 10, 89,
	3, 89, 5, 89, 1723, 10, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3,
	89, 3, 89, 3, 89, 5, 89, 1734, 10, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3,
	89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1758, 10, 89, 3, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1765, 10, 89, 7, 89, 1767, 10, 89, 12,
	89, 14, 89, 1770, 11, 89, 3, 90, 3, 90, 3, 90, 7, 90, 1775, 10, 90, 12,
	90, 14, 90, 1778, 11, 90, 3, 91, 3, 91, 5, 91, 1782, 10, 91, 3, 92, 3,
	92, 3, 92, 3, 92, 7, 92, 1788, 10, 92, 12, 92, 14, 92, 1791, 11, 92, 3,
	92, 3, 92, 3, 92, 3, 92, 3, 92, 7, 92, 1798, 10, 92, 12, 92, 14, 92, 1801,
	11, 92, 5, 92, 1803, 10, 92, 3, 92, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93,
	5, 93, 1811, 10, 93, 3, 93, 3, 93, 3, 94, 3, 94, 3, 94, 5, 94, 1818, 10,
	94, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 5, 95, 1827, 10, 95,
	3, 95, 3, 95, 3, 95, 3, 95, 5, 95, 1833, 10, 95, 7, 95, 1835, 10, 95, 12,
	95, 14, 95, 1838, 11, 95, 3, 96, 3, 96, 3, 96, 5, 96, 1843, 10, 96, 3,
	96, 3, 96, 3, 97, 3, 97, 3, 97, 5, 97, 1850, 10, 97, 3, 97, 3, 97, 3, 98,
	3, 98, 3, 98, 7, 98, 1857, 10, 98, 12, 98, 14, 98, 1860, 11, 98, 3, 99,
	3, 99, 3, 99, 5, 99, 1865, 10, 99, 3, 100, 3, 100, 3, 101, 3, 101, 3, 101,
	3, 101, 3, 101, 3, 101, 5, 101, 1875, 10, 101, 5, 101, 1877, 10, 101, 3,
	102, 5, 102, 1880, 10, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3,
	102, 5, 102, 1888, 10, 102, 3, 103, 3, 103, 3, 103, 5, 103, 1893, 10, 103,
	3, 104, 3, 104, 3, 105, 3, 105, 3, 106, 3, 106, 3, 107, 3, 107, 5, 107,
	1903, 10, 107, 3, 108, 3, 108, 3, 108, 5, 108, 1908, 10, 108, 3, 109, 3,
	109, 5, 109, 1912, 10, 109, 3, 110, 3, 110, 3, 110, 3, 110, 3, 110, 2,
	5, 136, 176, 188, 111, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
	28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
	64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
	100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,
	130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158,
	160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188,
	190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218,
	2, 29, 8, 2, 5, 5, 26, 26, 29, 29, 39, 39, 103, 103, 168, 168, 4, 2, 17,
	17, 31, 31, 5, 2, 5, 5, 39, 39, 103, 103, 4, 2, 42, 42, 44, 44, 4, 2, 45,
	45, 51, 51, 5, 2, 16, 16, 151, 151, 157, 157, 4, 2, 33, 33, 138, 138, 4,
	2, 83, 83, 95, 95, 4, 2, 70, 70, 100, 100, 5, 2, 6, 6, 10, 10, 14, 14,
	6, 2, 6, 6, 9, 10, 14, 14, 142, 142, 4, 2, 95, 95, 137, 137, 4, 2, 6, 6,
	10, 10, 4, 2, 117, 117, 197, 197, 4, 2, 13, 13, 42, 43, 4, 2, 62, 62, 92,
	92, 4, 2, 67, 67, 79, 79, 3, 2, 148, 149, 5, 2, 19, 19, 94, 94, 165, 165,
	5, 2, 193, 193, 211, 211, 220, 220, 4, 2, 198, 199, 212, 212, 4, 2, 78,
	78, 97, 97, 3, 2, 188, 189, 4, 2, 199, 199, 212, 212, 10, 2, 37, 37, 75,
	75, 107, 107, 109, 109, 129, 129, 140, 140, 179, 179, 183, 183, 14, 2,
	4, 36, 38, 74, 76, 80, 82, 106, 108, 108, 110, 111, 113, 114, 116, 127,
	130, 139, 141, 178, 180, 182, 184, 185, 6, 2, 36, 36, 62, 62, 76, 76, 90,
	90, 2, 2191, 2, 234, 3, 2, 2, 2, 4, 254, 3, 2, 2, 2, 6, 256, 3, 2, 2, 2,
	8, 484, 3, 2, 2, 2, 10, 486, 3, 2, 2, 2, 12, 494, 3, 2, 2, 2, 14, 498,
	3, 2, 2, 2, 16, 505, 3, 2, 2, 2, 18, 507, 3, 2, 2, 2, 20, 513, 3, 2, 2,
	2, 22, 656, 3, 2, 2, 2, 24, 658, 3, 2, 2, 2, 26, 669, 3, 2, 2, 2, 28, 696,
	3, 2, 2, 2, 30, 723, 3, 2, 2, 2, 32, 727, 3, 2, 2, 2, 34, 736, 3, 2, 2,
	2, 36, 749, 3, 2, 2, 2, 38, 764, 3, 2, 2, 2, 40, 777, 3, 2, 2, 2, 42, 793,
	3, 2, 2, 2, 44, 798, 3, 2, 2, 2, 46, 804, 3, 2, 2, 2, 48, 807, 3, 2, 2,
	2, 50, 810, 3, 2, 2, 2, 52, 828, 3, 2, 2, 2, 54, 830, 3, 2, 2, 2, 56, 860,
	3, 2, 2, 2, 58, 864, 3, 2, 2, 2, 60, 868, 3, 2, 2, 2, 62, 872, 3, 2, 2,
	2, 64, 881, 3, 2, 2, 2, 66, 903, 3, 2, 2, 2, 68, 937, 3, 2, 2, 2, 70, 939,
	3, 2, 2, 2, 72, 942, 3, 2, 2, 2, 74, 949, 3, 2, 2, 2, 76, 952, 3, 2, 2,
	2, 78, 964, 3, 2, 2, 2, 80, 972, 3, 2, 2, 2, 82, 982, 3, 2, 2, 2, 84, 1019,
	3, 2, 2, 2, 86, 1034, 3, 2, 2, 2, 88, 1042, 3, 2, 2, 2, 90, 1044, 3, 2,
	2, 2, 92, 1059, 3, 2, 2, 2, 94, 1079, 3, 2, 2, 2, 96, 1081, 3, 2, 2, 2,
	98, 1090, 3, 2, 2, 2, 100, 1105, 3, 2, 2, 2, 102, 1123, 3, 2, 2, 2, 104,
	1137, 3, 2, 2, 2, 106, 1151, 3, 2, 2, 2, 108, 1154, 3, 2, 2, 2, 110, 1202,
	3, 2, 2, 2, 112, 1205, 3, 2, 2, 2, 114, 1211, 3, 2, 2, 2, 116, 1215, 3,
	2, 2, 2, 118, 1221, 3, 2, 2, 2, 120, 1224, 3, 2, 2, 2, 122, 1227, 3, 2,
	2, 2, 124, 1237, 3, 2, 2, 2, 126, 1240, 3, 2, 2, 2, 128, 1244, 3, 2, 2,
	2, 130, 1248, 3, 2, 2, 2, 132, 1253, 3, 2, 2, 2, 134, 1259, 3, 2, 2, 2,
	136, 1274, 3, 2, 2, 2, 138, 1339, 3, 2, 2, 2, 140, 1347, 3, 2, 2, 2, 142,
	1358, 3, 2, 2, 2, 144, 1360, 3, 2, 2, 2, 146, 1366, 3, 2, 2, 2, 148, 1371,
	3, 2, 2, 2, 150, 1379, 3, 2, 2, 2, 152, 1391, 3, 2, 2, 2, 154, 1396, 3,
	2, 2, 2, 156, 1404, 3, 2, 2, 2, 158, 1408, 3, 2, 2, 2, 160, 1453, 3, 2,
	2, 2, 162, 1489, 3, 2, 2, 2, 164, 1491, 3, 2, 2, 2, 166, 1506, 3, 2, 2,
	2, 168, 1509, 3, 2, 2, 2, 170, 1565, 3, 2, 2, 2, 172, 1567, 3, 2, 2, 2,
	174, 1586, 3, 2, 2, 2, 176, 1695, 3, 2, 2, 2, 178, 1771, 3, 2, 2, 2, 180,
	1781, 3, 2, 2, 2, 182, 1802, 3, 2, 2, 2, 184, 1810, 3, 2, 2, 2, 186, 1814,
	3, 2, 2, 2, 188, 1826, 3, 2, 2, 2, 190, 1839, 3, 2, 2, 2, 192, 1849, 3,
	2, 2, 2, 194, 1853, 3, 2, 2, 2, 196, 1864, 3, 2, 2, 2, 198, 1866, 3, 2,
	2, 2, 200, 1876, 3, 2, 2, 2, 202, 1879, 3, 2, 2, 2, 204, 1892, 3, 2, 2,
	2, 206, 1894, 3, 2, 2, 2, 208, 1896, 3, 2, 2, 2, 210, 1898, 3, 2, 2, 2,
	212, 1902, 3, 2, 2, 2, 214, 1907, 3, 2, 2, 2, 216, 1911, 3, 2, 2, 2, 218,
	1913, 3, 2, 2, 2, 220, 224, 5, 4, 3, 2, 221, 222, 7, 86, 2, 2, 222, 223,
	7, 123, 2, 2, 223, 225, 7, 191, 2, 2, 224, 221, 3, 2, 2, 2, 224, 225, 3,
	2, 2, 2, 225, 228, 3, 2, 2, 2, 226, 227, 7, 65, 2, 2, 227, 229, 5, 216,
	109, 2, 228, 226, 3, 2, 2, 2, 228, 229, 3, 2, 2, 2, 229, 231, 3, 2, 2,
	2, 230, 232, 7, 219, 2, 2, 231, 230, 3, 2, 2, 2, 231, 232, 3, 2, 2, 2,
	232, 235, 3, 2, 2, 2, 233, 235, 5, 90, 46, 2, 234, 220, 3, 2, 2, 2, 234,
	233, 3, 2, 2, 2, 235, 3, 3, 2, 2, 2, 236, 255, 5, 6, 4, 2, 237, 255, 5,
	18, 10, 2, 238, 255, 5, 20, 11, 2, 239, 255, 5, 22, 12, 2, 240, 255, 5,
	82, 42, 2, 241, 255, 5, 84, 43, 2, 242, 255, 5, 86, 44, 2, 243, 255, 5,
	88, 45, 2, 244, 255, 5, 96, 49, 2, 245, 255, 5, 98, 50, 2, 246, 255, 5,
	100, 51, 2, 247, 255, 5, 104, 53, 2, 248, 255, 5, 158, 80, 2, 249, 255,
	5, 160, 81, 2, 250, 255, 5, 162, 82, 2, 251, 255, 5, 164, 83, 2, 252, 255,
	5, 166, 84, 2, 253, 255, 5, 168, 85, 2, 254, 236, 3, 2, 2, 2, 254, 237,
	3, 2, 2, 2, 254, 238, 3, 2, 2, 2, 254, 239, 3, 2, 2, 2, 254, 240, 3, 2,
	2, 2, 254, 241, 3, 2, 2, 2, 254, 242, 3, 2, 2, 2, 254, 243, 3, 2, 2, 2,
	254, 244, 3, 2, 2, 2, 254, 245, 3, 2, 2, 2, 254, 246, 3, 2, 2, 2, 254,
	247, 3, 2, 2, 2, 254, 248, 3, 2, 2, 2, 254, 249, 3, 2, 2, 2, 254, 250,
	3, 2, 2, 2, 254, 251, 3, 2, 2, 2, 254, 252, 3, 2, 2, 2, 254, 253, 3, 2,
	2, 2, 255, 5, 3, 2, 2, 2, 256, 257, 7, 7, 2, 2, 257, 258, 7, 154, 2, 2,
	258, 260, 5, 192, 97, 2, 259, 261, 5, 44, 23, 2, 260, 259, 3, 2, 2, 2,
	260, 261, 3, 2, 2, 2, 261, 262, 3, 2, 2, 2, 262, 267, 5, 8, 5, 2, 263,
	264, 7, 197, 2, 2, 264, 266, 5, 8, 5, 2, 265, 263, 3, 2, 2, 2, 266, 269,
	3, 2, 2, 2, 267, 265, 3, 2, 2, 2, 267, 268, 3, 2, 2, 2, 268, 7, 3, 2, 2,
	2, 269, 267, 3, 2, 2, 2, 270, 271, 7, 3, 2, 2, 271, 275, 7, 28, 2, 2, 272,
	273, 7, 77, 2, 2, 273, 274, 7, 114, 2, 2, 274, 276, 7, 56, 2, 2, 275, 272,
	3, 2, 2, 2, 275, 276, 3, 2, 2, 2, 276, 277, 3, 2, 2, 2, 277, 280, 5, 68,
	35, 2, 278, 279, 7, 4, 2, 2, 279, 281, 5, 186, 94, 2, 280, 278, 3, 2, 2,
	2, 280, 281, 3, 2, 2, 2, 281, 485, 3, 2, 2, 2, 282, 283, 7, 3, 2, 2, 283,
	287, 7, 80, 2, 2, 284, 285, 7, 77, 2, 2, 285, 286, 7, 114, 2, 2, 286, 288,
	7, 56, 2, 2, 287, 284, 3, 2, 2, 2, 287, 288, 3, 2, 2, 2, 288, 289, 3, 2,
	2, 2, 289, 292, 5, 72, 37, 2, 290, 291, 7, 4, 2, 2, 291, 293, 5, 186, 94,
	2, 292, 290, 3, 2, 2, 2, 292, 293, 3, 2, 2, 2, 293, 485, 3, 2, 2, 2, 294,
	295, 7, 3, 2, 2, 295, 299, 7, 128, 2, 2, 296, 297, 7, 77, 2, 2, 297, 298,
	7, 114, 2, 2, 298, 300, 7, 56, 2, 2, 299, 296, 3, 2, 2, 2, 299, 300, 3,
	2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 304, 5, 74, 38, 2, 302, 303, 7, 4,
	2, 2, 303, 305, 5, 186, 94, 2, 304, 302, 3, 2, 2, 2, 304, 305, 3, 2, 2,
	2, 305, 485, 3, 2, 2, 2, 306, 307, 7, 17, 2, 2, 307, 310, 5, 16, 9, 2,
	308, 309, 7, 67, 2, 2, 309, 311, 5, 192, 97, 2, 310, 308, 3, 2, 2, 2, 310,
	311, 3, 2, 2, 2, 311, 485, 3, 2, 2, 2, 312, 313, 7, 24, 2, 2, 313, 316,
	7, 28, 2, 2, 314, 315, 7, 77, 2, 2, 315, 317, 7, 56, 2, 2, 316, 314, 3,
	2, 2, 2, 316, 317, 3, 2, 2, 2, 317, 318, 3, 2, 2, 2, 318, 321, 5, 186,
	94, 2, 319, 320, 7, 79, 2, 2, 320, 322, 5, 16, 9, 2, 321, 319, 3, 2, 2,
	2, 321, 322, 3, 2, 2, 2, 322, 485, 3, 2, 2, 2, 323, 324, 7, 24, 2, 2, 324,
	327, 7, 80, 2, 2, 325, 326, 7, 77, 2, 2, 326, 328, 7, 56, 2, 2, 327, 325,
	3, 2, 2, 2, 327, 328, 3, 2, 2, 2, 328, 329, 3, 2, 2, 2, 329, 332, 5, 186,
	94, 2, 330, 331, 7, 79, 2, 2, 331, 333, 5, 16, 9, 2, 332, 330, 3, 2, 2,
	2, 332, 333, 3, 2, 2, 2, 333, 485, 3, 2, 2, 2, 334, 335, 7, 24, 2, 2, 335,
	338, 7, 128, 2, 2, 336, 337, 7, 77, 2, 2, 337, 339, 7, 56, 2, 2, 338, 336,
	3, 2, 2, 2, 338, 339, 3, 2, 2, 2, 339, 340, 3, 2, 2, 2, 340, 343, 5, 186,
	94, 2, 341, 342, 7, 79, 2, 2, 342, 344, 5, 16, 9, 2, 343, 341, 3, 2, 2,
	2, 343, 344, 3, 2, 2, 2, 344, 485, 3, 2, 2, 2, 345, 346, 7, 29, 2, 2, 346,
	349, 7, 28, 2, 2, 347, 348, 7, 77, 2, 2, 348, 350, 7, 56, 2, 2, 349, 347,
	3, 2, 2, 2, 349, 350, 3, 2, 2, 2, 350, 351, 3, 2, 2, 2, 351, 352, 5, 186,
	94, 2, 352, 353, 7, 191, 2, 2, 353, 485, 3, 2, 2, 2, 354, 355, 7, 41, 2,
	2, 355, 356, 7, 181, 2, 2, 356, 485, 5, 176, 89, 2, 357, 358, 7, 45, 2,
	2, 358, 485, 5, 16, 9, 2, 359, 360, 7, 51, 2, 2, 360, 363, 7, 28, 2, 2,
	361, 362, 7, 77, 2, 2, 362, 364, 7, 56, 2, 2, 363, 361, 3, 2, 2, 2, 363,
	364, 3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 485, 5, 186, 94, 2, 366, 367,
	7, 51, 2, 2, 367, 370, 7, 80, 2, 2, 368, 369, 7, 77, 2, 2, 369, 371, 7,
	56, 2, 2, 370, 368, 3, 2, 2, 2, 370, 371, 3, 2, 2, 2, 371, 372, 3, 2, 2,
	2, 372, 485, 5, 186, 94, 2, 373, 374, 7, 51, 2, 2, 374, 377, 7, 128, 2,
	2, 375, 376, 7, 77, 2, 2, 376, 378, 7, 56, 2, 2, 377, 375, 3, 2, 2, 2,
	377, 378, 3, 2, 2, 2, 378, 379, 3, 2, 2, 2, 379, 485, 5, 186, 94, 2, 380,
	381, 7, 51, 2, 2, 381, 485, 5, 16, 9, 2, 382, 384, 7, 66, 2, 2, 383, 385,
	5, 16, 9, 2, 384, 383, 3, 2, 2, 2, 384, 385, 3, 2, 2, 2, 385, 485, 3, 2,
	2, 2, 386, 387, 7, 102, 2, 2, 387, 390, 7, 80, 2, 2, 388, 389, 7, 77, 2,
	2, 389, 391, 7, 56, 2, 2, 390, 388, 3, 2, 2, 2, 390, 391, 3, 2, 2, 2, 391,
	392, 3, 2, 2, 2, 392, 395, 5, 186, 94, 2, 393, 394, 7, 79, 2, 2, 394, 396,
	5, 16, 9, 2, 395, 393, 3, 2, 2, 2, 395, 396, 3, 2, 2, 2, 396, 485, 3, 2,
	2, 2, 397, 398, 7, 102, 2, 2, 398, 401, 7, 128, 2, 2, 399, 400, 7, 77,
	2, 2, 400, 402, 7, 56, 2, 2, 401, 399, 3, 2, 2, 2, 401, 402, 3, 2, 2, 2,
	402, 403, 3, 2, 2, 2, 403, 406, 5, 186, 94, 2, 404, 405, 7, 79, 2, 2, 405,
	407, 5, 16, 9, 2, 406, 404, 3, 2, 2, 2, 406, 407, 3, 2, 2, 2, 407, 485,
	3, 2, 2, 2, 408, 409, 7, 108, 2, 2, 409, 412, 7, 28, 2, 2, 410, 411, 7,
	77, 2, 2, 411, 413, 7, 56, 2, 2, 412, 410, 3, 2, 2, 2, 412, 413, 3, 2,
	2, 2, 413, 414, 3, 2, 2, 2, 414, 415, 5, 186, 94, 2, 415, 416, 5, 76, 39,
	2, 416, 485, 3, 2, 2, 2, 417, 418, 7, 108, 2, 2, 418, 421, 7, 28, 2, 2,
	419, 420, 7, 77, 2, 2, 420, 422, 7, 56, 2, 2, 421, 419, 3, 2, 2, 2, 421,
	422, 3, 2, 2, 2, 422, 423, 3, 2, 2, 2, 423, 424, 5, 186, 94, 2, 424, 425,
	7, 29, 2, 2, 425, 426, 7, 191, 2, 2, 426, 485, 3, 2, 2, 2, 427, 428, 7,
	108, 2, 2, 428, 431, 7, 28, 2, 2, 429, 430, 7, 77, 2, 2, 430, 432, 7, 56,
	2, 2, 431, 429, 3, 2, 2, 2, 431, 432, 3, 2, 2, 2, 432, 433, 3, 2, 2, 2,
	433, 434, 5, 186, 94, 2, 434, 435, 7, 132, 2, 2, 435, 436, 5, 14, 8, 2,
	436, 485, 3, 2, 2, 2, 437, 438, 7, 108, 2, 2, 438, 441, 7, 28, 2, 2, 439,
	440, 7, 77, 2, 2, 440, 442, 7, 56, 2, 2, 441, 439, 3, 2, 2, 2, 441, 442,
	3, 2, 2, 2, 442, 443, 3, 2, 2, 2, 443, 485, 5, 68, 35, 2, 444, 445, 7,
	108, 2, 2, 445, 446, 7, 121, 2, 2, 446, 447, 7, 20, 2, 2, 447, 485, 5,
	176, 89, 2, 448, 449, 7, 108, 2, 2, 449, 485, 5, 62, 32, 2, 450, 451, 7,
	110, 2, 2, 451, 461, 5, 16, 9, 2, 452, 453, 7, 162, 2, 2, 453, 454, 7,
	48, 2, 2, 454, 462, 7, 191, 2, 2, 455, 456, 7, 162, 2, 2, 456, 457, 7,
	177, 2, 2, 457, 462, 7, 191, 2, 2, 458, 459, 7, 162, 2, 2, 459, 460, 7,
	154, 2, 2, 460, 462, 5, 192, 97, 2, 461, 452, 3, 2, 2, 2, 461, 455, 3,
	2, 2, 2, 461, 458, 3, 2, 2, 2, 462, 485, 3, 2, 2, 2, 463, 464, 7, 132,
	2, 2, 464, 485, 7, 168, 2, 2, 465, 466, 7, 133, 2, 2, 466, 469, 7, 28,
	2, 2, 467, 468, 7, 77, 2, 2, 468, 470, 7, 56, 2, 2, 469, 467, 3, 2, 2,
	2, 469, 470, 3, 2, 2, 2, 470, 471, 3, 2, 2, 2, 471, 472, 5, 186, 94, 2,
	472, 473, 7, 162, 2, 2, 473, 474, 5, 186, 94, 2, 474, 485, 3, 2, 2, 2,
	475, 476, 7, 134, 2, 2, 476, 477, 5, 16, 9, 2, 477, 478, 7, 67, 2, 2, 478,
	479, 5, 192, 97, 2, 479, 485, 3, 2, 2, 2, 480, 481, 7, 171, 2, 2, 481,
	482, 5, 10, 6, 2, 482, 483, 5, 120, 61, 2, 483, 485, 3, 2, 2, 2, 484, 270,
	3, 2, 2, 2, 484, 282, 3, 2, 2, 2, 484, 294, 3, 2, 2, 2, 484, 306, 3, 2,
	2, 2, 484, 312, 3, 2, 2, 2, 484, 323, 3, 2, 2, 2, 484, 334, 3, 2, 2, 2,
	484, 345, 3, 2, 2, 2, 484, 354, 3, 2, 2, 2, 484, 357, 3, 2, 2, 2, 484,
	359, 3, 2, 2, 2, 484, 366, 3, 2, 2, 2, 484, 373, 3, 2, 2, 2, 484, 380,
	3, 2, 2, 2, 484, 382, 3, 2, 2, 2, 484, 386, 3, 2, 2, 2, 484, 397, 3, 2,
	2, 2, 484, 408, 3, 2, 2, 2, 484, 417, 3, 2, 2, 2, 484, 427, 3, 2, 2, 2,
	484, 437, 3, 2, 2, 2, 484, 444, 3, 2, 2, 2, 484, 448, 3, 2, 2, 2, 484,
	450, 3, 2, 2, 2, 484, 463, 3, 2, 2, 2, 484, 465, 3, 2, 2, 2, 484, 475,
	3, 2, 2, 2, 484, 480, 3, 2, 2, 2, 485, 9, 3, 2, 2, 2, 486, 491, 5, 12,
	7, 2, 487, 488, 7, 197, 2, 2, 488, 490, 5, 12, 7, 2, 489, 487, 3, 2, 2,
	2, 490, 493, 3, 2, 2, 2, 491, 489, 3, 2, 2, 2, 491, 492, 3, 2, 2, 2, 492,
	11, 3, 2, 2, 2, 493, 491, 3, 2, 2, 2, 494, 495, 5, 186, 94, 2, 495, 496,
	7, 202, 2, 2, 496, 497, 5, 176, 89, 2, 497, 13, 3, 2, 2, 2, 498, 499, 9,
	2, 2, 2, 499, 15, 3, 2, 2, 2, 500, 501, 7, 124, 2, 2, 501, 506, 5, 176,
	89, 2, 502, 503, 7, 124, 2, 2, 503, 504, 7, 76, 2, 2, 504, 506, 7, 191,
	2, 2, 505, 500, 3, 2, 2, 2, 505, 502, 3, 2, 2, 2, 506, 17, 3, 2, 2, 2,
	507, 508, 7, 17, 2, 2, 508, 509, 7, 47, 2, 2, 509, 511, 5, 192, 97, 2,
	510, 512, 5, 44, 23, 2, 511, 510, 3, 2, 2, 2, 511, 512, 3, 2, 2, 2, 512,
	19, 3, 2, 2, 2, 513, 514, 7, 23, 2, 2, 514, 515, 7, 154, 2, 2, 515, 517,
	5, 192, 97, 2, 516, 518, 5, 16, 9, 2, 517, 516, 3, 2, 2, 2, 517, 518, 3,
	2, 2, 2, 518, 21, 3, 2, 2, 2, 519, 520, 9, 3, 2, 2, 520, 524, 7, 34, 2,
	2, 521, 522, 7, 77, 2, 2, 522, 523, 7, 114, 2, 2, 523, 525, 7, 56, 2, 2,
	524, 521, 3, 2, 2, 2, 524, 525, 3, 2, 2, 2, 525, 526, 3, 2, 2, 2, 526,
	528, 5, 198, 100, 2, 527, 529, 5, 44, 23, 2, 528, 527, 3, 2, 2, 2, 528,
	529, 3, 2, 2, 2, 529, 531, 3, 2, 2, 2, 530, 532, 5, 64, 33, 2, 531, 530,
	3, 2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 657, 3, 2, 2, 2, 533, 534, 9, 3,
	2, 2, 534, 538, 7, 47, 2, 2, 535, 536, 7, 77, 2, 2, 536, 537, 7, 114, 2,
	2, 537, 539, 7, 56, 2, 2, 538, 535, 3, 2, 2, 2, 538, 539, 3, 2, 2, 2, 539,
	540, 3, 2, 2, 2, 540, 542, 5, 192, 97, 2, 541, 543, 5, 46, 24, 2, 542,
	541, 3, 2, 2, 2, 542, 543, 3, 2, 2, 2, 543, 545, 3, 2, 2, 2, 544, 546,
	5, 44, 23, 2, 545, 544, 3, 2, 2, 2, 545, 546, 3, 2, 2, 2, 546, 547, 3,
	2, 2, 2, 547, 548, 5, 24, 13, 2, 548, 549, 5, 28, 15, 2, 549, 657, 3, 2,
	2, 2, 550, 551, 9, 3, 2, 2, 551, 552, 7, 99, 2, 2, 552, 556, 7, 176, 2,
	2, 553, 554, 7, 77, 2, 2, 554, 555, 7, 114, 2, 2, 555, 557, 7, 56, 2, 2,
	556, 553, 3, 2, 2, 2, 556, 557, 3, 2, 2, 2, 557, 558, 3, 2, 2, 2, 558,
	560, 5, 192, 97, 2, 559, 561, 5, 46, 24, 2, 560, 559, 3, 2, 2, 2, 560,
	561, 3, 2, 2, 2, 561, 563, 3, 2, 2, 2, 562, 564, 5, 44, 23, 2, 563, 562,
	3, 2, 2, 2, 563, 564, 3, 2, 2, 2, 564, 570, 3, 2, 2, 2, 565, 566, 7, 182,
	2, 2, 566, 568, 7, 160, 2, 2, 567, 569, 7, 189, 2, 2, 568, 567, 3, 2, 2,
	2, 568, 569, 3, 2, 2, 2, 569, 571, 3, 2, 2, 2, 570, 565, 3, 2, 2, 2, 570,
	571, 3, 2, 2, 2, 571, 573, 3, 2, 2, 2, 572, 574, 5, 48, 25, 2, 573, 572,
	3, 2, 2, 2, 573, 574, 3, 2, 2, 2, 574, 576, 3, 2, 2, 2, 575, 577, 5, 52,
	27, 2, 576, 575, 3, 2, 2, 2, 576, 577, 3, 2, 2, 2, 577, 578, 3, 2, 2, 2,
	578, 579, 5, 50, 26, 2, 579, 657, 3, 2, 2, 2, 580, 581, 9, 3, 2, 2, 581,
	582, 7, 103, 2, 2, 582, 586, 7, 176, 2, 2, 583, 584, 7, 77, 2, 2, 584,
	585, 7, 114, 2, 2, 585, 587, 7, 56, 2, 2, 586, 583, 3, 2, 2, 2, 586, 587,
	3, 2, 2, 2, 587, 588, 3, 2, 2, 2, 588, 590, 5, 192, 97, 2, 589, 591, 5,
	46, 24, 2, 590, 589, 3, 2, 2, 2, 590, 591, 3, 2, 2, 2, 591, 593, 3, 2,
	2, 2, 592, 594, 5, 44, 23, 2, 593, 592, 3, 2, 2, 2, 593, 594, 3, 2, 2,
	2, 594, 596, 3, 2, 2, 2, 595, 597, 5, 52, 27, 2, 596, 595, 3, 2, 2, 2,
	596, 597, 3, 2, 2, 2, 597, 603, 3, 2, 2, 2, 598, 604, 5, 48, 25, 2, 599,
	601, 5, 54, 28, 2, 600, 602, 7, 125, 2, 2, 601, 600, 3, 2, 2, 2, 601, 602,
	3, 2, 2, 2, 602, 604, 3, 2, 2, 2, 603, 598, 3, 2, 2, 2, 603, 599, 3, 2,
	2, 2, 604, 605, 3, 2, 2, 2, 605, 606, 5, 50, 26, 2, 606, 657, 3, 2, 2,
	2, 607, 609, 9, 3, 2, 2, 608, 610, 7, 156, 2, 2, 609, 608, 3, 2, 2, 2,
	609, 610, 3, 2, 2, 2, 610, 611, 3, 2, 2, 2, 611, 615, 7, 154, 2, 2, 612,
	613, 7, 77, 2, 2, 613, 614, 7, 114, 2, 2, 614, 616, 7, 56, 2, 2, 615, 612,
	3, 2, 2, 2, 615, 616, 3, 2, 2, 2, 616, 617, 3, 2, 2, 2, 617, 619, 5, 192,
	97, 2, 618, 620, 5, 46, 24, 2, 619, 618, 3, 2, 2, 2, 619, 620, 3, 2, 2,
	2, 620, 622, 3, 2, 2, 2, 621, 623, 5, 44, 23, 2, 622, 621, 3, 2, 2, 2,
	622, 623, 3, 2, 2, 2, 623, 625, 3, 2, 2, 2, 624, 626, 5, 52, 27, 2, 625,
	624, 3, 2, 2, 2, 625, 626, 3, 2, 2, 2, 626, 628, 3, 2, 2, 2, 627, 629,
	5, 54, 28, 2, 628, 627, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 631, 3,
	2, 2, 2, 630, 632, 5, 50, 26, 2, 631, 630, 3, 2, 2, 2, 631, 632, 3, 2,
	2, 2, 632, 657, 3, 2, 2, 2, 633, 636, 9, 3, 2, 2, 634, 635, 7, 120, 2,
	2, 635, 637, 7, 134, 2, 2, 636, 634, 3, 2, 2, 2, 636, 637, 3, 2, 2, 2,
	637, 638, 3, 2, 2, 2, 638, 642, 7, 176, 2, 2, 639, 640, 7, 77, 2, 2, 640,
	641, 7, 114, 2, 2, 641, 643, 7, 56, 2, 2, 642, 639, 3, 2, 2, 2, 642, 643,
	3, 2, 2, 2, 643, 644, 3, 2, 2, 2, 644, 646, 5, 192, 97, 2, 645, 647, 5,
	46, 24, 2, 646, 645, 3, 2, 2, 2, 646, 647, 3, 2, 2, 2, 647, 649, 3, 2,
	2, 2, 648, 650, 5, 44, 23, 2, 649, 648, 3, 2, 2, 2, 649, 650, 3, 2, 2,
	2, 650, 652, 3, 2, 2, 2, 651, 653, 5, 52, 27, 2, 652, 651, 3, 2, 2, 2,
	652, 653, 3, 2, 2, 2, 653, 654, 3, 2, 2, 2, 654, 655, 5, 50, 26, 2, 655,
	657, 3, 2, 2, 2, 656, 519, 3, 2, 2, 2, 656, 533, 3, 2, 2, 2, 656, 550,
	3, 2, 2, 2, 656, 580, 3, 2, 2, 2, 656, 607, 3, 2, 2, 2, 656, 633, 3, 2,
	2, 2, 657, 23, 3, 2, 2, 2, 658, 659, 7, 208, 2, 2, 659, 664, 5, 26, 14,
	2, 660, 661, 7, 197, 2, 2, 661, 663, 5, 26, 14, 2, 662, 660, 3, 2, 2, 2,
	663, 666, 3, 2, 2, 2, 664, 662, 3, 2, 2, 2, 664, 665, 3, 2, 2, 2, 665,
	667, 3, 2, 2, 2, 666, 664, 3, 2, 2, 2, 667, 668, 7, 218, 2, 2, 668, 25,
	3, 2, 2, 2, 669, 670, 5, 214, 108, 2, 670, 692, 5, 170, 86, 2, 671, 672,
	6, 14, 2, 3, 672, 673, 7, 39, 2, 2, 673, 674, 5, 204, 103, 2, 674, 675,
	8, 14, 1, 2, 675, 691, 3, 2, 2, 2, 676, 677, 6, 14, 3, 3, 677, 678, 7,
	58, 2, 2, 678, 679, 5, 176, 89, 2, 679, 680, 8, 14, 1, 2, 680, 691, 3,
	2, 2, 2, 681, 682, 6, 14, 4, 3, 682, 683, 7, 74, 2, 2, 683, 691, 8, 14,
	1, 2, 684, 685, 6, 14, 5, 3, 685, 686, 7, 82, 2, 2, 686, 691, 8, 14, 1,
	2, 687, 688, 6, 14, 6, 3, 688, 689, 7, 88, 2, 2, 689, 691, 8, 14, 1, 2,
	690, 671, 3, 2, 2, 2, 690, 676, 3, 2, 2, 2, 690, 681, 3, 2, 2, 2, 690,
	684, 3, 2, 2, 2, 690, 687, 3, 2, 2, 2, 691, 694, 3, 2, 2, 2, 692, 690,
	3, 2, 2, 2, 692, 693, 3, 2, 2, 2, 693, 27, 3, 2, 2, 2, 694, 692, 3, 2,
	2, 2, 695, 697, 5, 30, 16, 2, 696, 695, 3, 2, 2, 2, 696, 697, 3, 2, 2,
	2, 697, 720, 3, 2, 2, 2, 698, 699, 6, 15, 7, 3, 699, 700, 5, 34, 18, 2,
	700, 701, 8, 15, 1, 2, 701, 719, 3, 2, 2, 2, 702, 703, 6, 15, 8, 3, 703,
	704, 5, 36, 19, 2, 704, 705, 8, 15, 1, 2, 705, 719, 3, 2, 2, 2, 706, 707,
	6, 15, 9, 3, 707, 708, 5, 38, 20, 2, 708, 709, 8, 15, 1, 2, 709, 719, 3,
	2, 2, 2, 710, 711, 6, 15, 10, 3, 711, 712, 5, 40, 21, 2, 712, 713, 8, 15,
	1, 2, 713, 719, 3, 2, 2, 2, 714, 715, 6, 15, 11, 3, 715, 716, 5, 42, 22,
	2, 716, 717, 8, 15, 1, 2, 717, 719, 3, 2, 2, 2, 718, 698, 3, 2, 2, 2, 718,
	702, 3, 2, 2, 2, 718, 706, 3, 2, 2, 2, 718, 710, 3, 2, 2, 2, 718, 714,
	3, 2, 2, 2, 719, 722, 3, 2, 2, 2, 720, 718, 3, 2, 2, 2, 720, 721, 3, 2,
	2, 2, 721, 29, 3, 2, 2, 2, 722, 720, 3, 2, 2, 2, 723, 724, 7, 127, 2, 2,
	724, 725, 7, 90, 2, 2, 725, 726, 5, 172, 87, 2, 726, 31, 3, 2, 2, 2, 727,
	734, 5, 214, 108, 2, 728, 731, 5, 214, 108, 2, 729, 730, 7, 208, 2, 2,
	730, 732, 7, 218, 2, 2, 731, 729, 3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732,
	735, 3, 2, 2, 2, 733, 735, 5, 204, 103, 2, 734, 728, 3, 2, 2, 2, 734, 733,
	3, 2, 2, 2, 735, 33, 3, 2, 2, 2, 736, 737, 7, 147, 2, 2, 737, 738, 7, 208,
	2, 2, 738, 739, 5, 214, 108, 2, 739, 743, 7, 208, 2, 2, 740, 742, 5, 32,
	17, 2, 741, 740, 3, 2, 2, 2, 742, 745, 3, 2, 2, 2, 743, 741, 3, 2, 2, 2,
	743, 744, 3, 2, 2, 2, 744, 746, 3, 2, 2, 2, 745, 743, 3, 2, 2, 2, 746,
	747, 7, 218, 2, 2, 747, 748, 7, 218, 2, 2, 748, 35, 3, 2, 2, 2, 749, 750,
	7, 96, 2, 2, 750, 760, 7, 208, 2, 2, 751, 761, 7, 189, 2, 2, 752, 753,
	7, 106, 2, 2, 753, 754, 7, 189, 2, 2, 754, 755, 7, 104, 2, 2, 755, 761,
	7, 189, 2, 2, 756, 757, 7, 104, 2, 2, 757, 758, 7, 189, 2, 2, 758, 759,
	7, 106, 2, 2, 759, 761, 7, 189, 2, 2, 760, 751, 3, 2, 2, 2, 760, 752, 3,
	2, 2, 2, 760, 756, 3, 2, 2, 2, 761, 762, 3, 2, 2, 2, 762, 763, 7, 218,
	2, 2, 763, 37, 3, 2, 2, 2, 764, 765, 7, 93, 2, 2, 765, 766, 7, 208, 2,
	2, 766, 767, 5, 214, 108, 2, 767, 771, 7, 208, 2, 2, 768, 770, 5, 32, 17,
	2, 769, 768, 3, 2, 2, 2, 770, 773, 3, 2, 2, 2, 771, 769, 3, 2, 2, 2, 771,
	772, 3, 2, 2, 2, 772, 774, 3, 2, 2, 2, 773, 771, 3, 2, 2, 2, 774, 775,
	7, 218, 2, 2, 775, 776, 7, 218, 2, 2, 776, 39, 3, 2, 2, 2, 777, 778, 7,
	130, 2, 2, 778, 789, 7, 208, 2, 2, 779, 780, 7, 106, 2, 2, 780, 781, 5,
	214, 108, 2, 781, 782, 7, 104, 2, 2, 782, 783, 5, 214, 108, 2, 783, 790,
	3, 2, 2, 2, 784, 785, 7, 104, 2, 2, 785, 786, 5, 214, 108, 2, 786, 787,
	7, 106, 2, 2, 787, 788, 5, 214, 108, 2, 788, 790, 3, 2, 2, 2, 789, 779,
	3, 2, 2, 2, 789, 784, 3, 2, 2, 2, 790, 791, 3, 2, 2, 2, 791, 792, 7, 218,
	2, 2, 792, 41, 3, 2, 2, 2, 793, 794, 7, 145, 2, 2, 794, 795, 7, 208, 2,
	2, 795, 796, 5, 154, 78, 2, 796, 797, 7, 218, 2, 2, 797, 43, 3, 2, 2, 2,
	798, 799, 7, 118, 2, 2, 799, 802, 7, 25, 2, 2, 800, 803, 5, 214, 108, 2,
	801, 803, 7, 191, 2, 2, 802, 800, 3, 2, 2, 2, 802, 801, 3, 2, 2, 2, 803,
	45, 3, 2, 2, 2, 804, 805, 7, 174, 2, 2, 805, 806, 7, 191, 2, 2, 806, 47,
	3, 2, 2, 2, 807, 808, 7, 162, 2, 2, 808, 809, 5, 192, 97, 2, 809, 49, 3,
	2, 2, 2, 810, 811, 7, 12, 2, 2, 811, 812, 5, 104, 53, 2, 812, 51, 3, 2,
	2, 2, 813, 814, 7, 208, 2, 2, 814, 819, 5, 66, 34, 2, 815, 816, 7, 197,
	2, 2, 816, 818, 5, 66, 34, 2, 817, 815, 3, 2, 2, 2, 818, 821, 3, 2, 2,
	2, 819, 817, 3, 2, 2, 2, 819, 820, 3, 2, 2, 2, 820, 822, 3, 2, 2, 2, 821,
	819, 3, 2, 2, 2, 822, 823, 7, 218, 2, 2, 823, 829, 3, 2, 2, 2, 824, 825,
	7, 12, 2, 2, 825, 829, 5, 192, 97, 2, 826, 827, 7, 12, 2, 2, 827, 829,
	5, 190, 96, 2, 828, 813, 3, 2, 2, 2, 828, 824, 3, 2, 2, 2, 828, 826, 3,
	2, 2, 2, 829, 53, 3, 2, 2, 2, 830, 857, 5, 64, 33, 2, 831, 832, 6, 28,
	12, 3, 832, 833, 5, 126, 64, 2, 833, 834, 8, 28, 1, 2, 834, 856, 3, 2,
	2, 2, 835, 836, 6, 28, 13, 3, 836, 837, 5, 56, 29, 2, 837, 838, 8, 28,
	1, 2, 838, 856, 3, 2, 2, 2, 839, 840, 6, 28, 14, 3, 840, 841, 5, 58, 30,
	2, 841, 842, 8, 28, 1, 2, 842, 856, 3, 2, 2, 2, 843, 844, 6, 28, 15, 3,
	844, 845, 5, 60, 31, 2, 845, 846, 8, 28, 1, 2, 846, 856, 3, 2, 2, 2, 847,
	848, 6, 28, 16, 3, 848, 849, 5, 62, 32, 2, 849, 850, 8, 28, 1, 2, 850,
	856, 3, 2, 2, 2, 851, 852, 6, 28, 17, 3, 852, 853, 5, 134, 68, 2, 853,
	854, 8, 28, 1, 2, 854, 856, 3, 2, 2, 2, 855, 831, 3, 2, 2, 2, 855, 835,
	3, 2, 2, 2, 855, 839, 3, 2, 2, 2, 855, 843, 3, 2, 2, 2, 855, 847, 3, 2,
	2, 2, 855, 851, 3, 2, 2, 2, 856, 859, 3, 2, 2, 2, 857, 855, 3, 2, 2, 2,
	857, 858, 3, 2, 2, 2, 858, 55, 3, 2, 2, 2, 859, 857, 3, 2, 2, 2, 860, 861,
	7, 124, 2, 2, 861, 862, 7, 20, 2, 2, 862, 863, 5, 176, 89, 2, 863, 57,
	3, 2, 2, 2, 864, 865, 7, 127, 2, 2, 865, 866, 7, 90, 2, 2, 866, 867, 5,
	176, 89, 2, 867, 59, 3, 2, 2, 2, 868, 869, 7, 139, 2, 2, 869, 870, 7, 20,
	2, 2, 870, 871, 5, 176, 89, 2, 871, 61, 3, 2, 2, 2, 872, 873, 7, 168, 2,
	2, 873, 878, 5, 80, 41, 2, 874, 875, 7, 197, 2, 2, 875, 877, 5, 80, 41,
	2, 876, 874, 3, 2, 2, 2, 877, 880, 3, 2, 2, 2, 878, 876, 3, 2, 2, 2, 878,
	879, 3, 2, 2, 2, 879, 63, 3, 2, 2, 2, 880, 878, 3, 2, 2, 2, 881, 883, 7,
	54, 2, 2, 882, 884, 7, 202, 2, 2, 883, 882, 3, 2, 2, 2, 883, 884, 3, 2,
	2, 2, 884, 885, 3, 2, 2, 2, 885, 891, 5, 216, 109, 2, 886, 888, 7, 208,
	2, 2, 887, 889, 5, 172, 87, 2, 888, 887, 3, 2, 2, 2, 888, 889, 3, 2, 2,
	2, 889, 890, 3, 2, 2, 2, 890, 892, 7, 218, 2, 2, 891, 886, 3, 2, 2, 2,
	891, 892, 3, 2, 2, 2, 892, 65, 3, 2, 2, 2, 893, 904, 5, 68, 35, 2, 894,
	895, 7, 30, 2, 2, 895, 896, 5, 214, 108, 2, 896, 897, 7, 23, 2, 2, 897,
	898, 5, 176, 89, 2, 898, 904, 3, 2, 2, 2, 899, 900, 7, 80, 2, 2, 900, 904,
	5, 72, 37, 2, 901, 902, 7, 128, 2, 2, 902, 904, 5, 74, 38, 2, 903, 893,
	3, 2, 2, 2, 903, 894, 3, 2, 2, 2, 903, 899, 3, 2, 2, 2, 903, 901, 3, 2,
	2, 2, 904, 67, 3, 2, 2, 2, 905, 906, 5, 186, 94, 2, 906, 908, 5, 170, 86,
	2, 907, 909, 5, 70, 36, 2, 908, 907, 3, 2, 2, 2, 908, 909, 3, 2, 2, 2,
	909, 912, 3, 2, 2, 2, 910, 911, 7, 29, 2, 2, 911, 913, 7, 191, 2, 2, 912,
	910, 3, 2, 2, 2, 912, 913, 3, 2, 2, 2, 913, 915, 3, 2, 2, 2, 914, 916,
	5, 76, 39, 2, 915, 914, 3, 2, 2, 2, 915, 916, 3, 2, 2, 2, 916, 919, 3,
	2, 2, 2, 917, 918, 7, 168, 2, 2, 918, 920, 5, 176, 89, 2, 919, 917, 3,
	2, 2, 2, 919, 920, 3, 2, 2, 2, 920, 938, 3, 2, 2, 2, 921, 923, 5, 186,
	94, 2, 922, 924, 5, 170, 86, 2, 923, 922, 3, 2, 2, 2, 923, 924, 3, 2, 2,
	2, 924, 925, 3, 2, 2, 2, 925, 928, 5, 70, 36, 2, 926, 927, 7, 29, 2, 2,
	927, 929, 7, 191, 2, 2, 928, 926, 3, 2, 2, 2, 928, 929, 3, 2, 2, 2, 929,
	931, 3, 2, 2, 2, 930, 932, 5, 76, 39, 2, 931, 930, 3, 2, 2, 2, 931, 932,
	3, 2, 2, 2, 932, 935, 3, 2, 2, 2, 933, 934, 7, 168, 2, 2, 934, 936, 5,
	176, 89, 2, 935, 933, 3, 2, 2, 2, 935, 936, 3, 2, 2, 2, 936, 938, 3, 2,
	2, 2, 937, 905, 3, 2, 2, 2, 937, 921, 3, 2, 2, 2, 938, 69, 3, 2, 2, 2,
	939, 940, 9, 4, 2, 2, 940, 941, 5, 176, 89, 2, 941, 71, 3, 2, 2, 2, 942,
	943, 5, 186, 94, 2, 943, 944, 5, 176, 89, 2, 944, 945, 7, 169, 2, 2, 945,
	946, 5, 170, 86, 2, 946, 947, 7, 71, 2, 2, 947, 948, 7, 189, 2, 2, 948,
	73, 3, 2, 2, 2, 949, 950, 5, 186, 94, 2, 950, 951, 5, 102, 52, 2, 951,
	75, 3, 2, 2, 2, 952, 953, 7, 26, 2, 2, 953, 954, 7, 208, 2, 2, 954, 959,
	5, 78, 40, 2, 955, 956, 7, 197, 2, 2, 956, 958, 5, 78, 40, 2, 957, 955,
	3, 2, 2, 2, 958, 961, 3, 2, 2, 2, 959, 957, 3, 2, 2, 2, 959, 960, 3, 2,
	2, 2, 960, 962, 3, 2, 2, 2, 961, 959, 3, 2, 2, 2, 962, 963, 7, 218, 2,
	2, 963, 77, 3, 2, 2, 2, 964, 970, 5, 214, 108, 2, 965, 967, 7, 208, 2,
	2, 966, 968, 5, 172, 87, 2, 967, 966, 3, 2, 2, 2, 967, 968, 3, 2, 2, 2,
	968, 969, 3, 2, 2, 2, 969, 971, 7, 218, 2, 2, 970, 965, 3, 2, 2, 2, 970,
	971, 3, 2, 2, 2, 971, 79, 3, 2, 2, 2, 972, 980, 5, 176, 89, 2, 973, 981,
	7, 41, 2, 2, 974, 975, 7, 162, 2, 2, 975, 976, 7, 48, 2, 2, 976, 981, 7,
	191, 2, 2, 977, 978, 7, 162, 2, 2, 978, 979, 7, 177, 2, 2, 979, 981, 7,
	191, 2, 2, 980, 973, 3, 2, 2, 2, 980, 974, 3, 2, 2, 2, 980, 977, 3, 2,
	2, 2, 980, 981, 3, 2, 2, 2, 981, 81, 3, 2, 2, 2, 982, 984, 9, 5, 2, 2,
	983, 985, 7, 154, 2, 2, 984, 983, 3, 2, 2, 2, 984, 985, 3, 2, 2, 2, 985,
	986, 3, 2, 2, 2, 986, 987, 5, 188, 95, 2, 987, 83, 3, 2, 2, 2, 988, 989,
	9, 6, 2, 2, 989, 992, 7, 34, 2, 2, 990, 991, 7, 77, 2, 2, 991, 993, 7,
	56, 2, 2, 992, 990, 3, 2, 2, 2, 992, 993, 3, 2, 2, 2, 993, 994, 3, 2, 2,
	2, 994, 996, 5, 198, 100, 2, 995, 997, 5, 44, 23, 2, 996, 995, 3, 2, 2,
	2, 996, 997, 3, 2, 2, 2, 997, 1020, 3, 2, 2, 2, 998, 1005, 9, 6, 2, 2,
	999, 1006, 7, 47, 2, 2, 1000, 1002, 7, 156, 2, 2, 1001, 1000, 3, 2, 2,
	2, 1001, 1002, 3, 2, 2, 2, 1002, 1003, 3, 2, 2, 2, 1003, 1006, 7, 154,
	2, 2, 1004, 1006, 7, 176, 2, 2, 1005, 999, 3, 2, 2, 2, 1005, 1001, 3, 2,
	2, 2, 1005, 1004, 3, 2, 2, 2, 1006, 1009, 3, 2, 2, 2, 1007, 1008, 7, 77,
	2, 2, 1008, 1010, 7, 56, 2, 2, 1009, 1007, 3, 2, 2, 2, 1009, 1010, 3, 2,
	2, 2, 1010, 1011, 3, 2, 2, 2, 1011, 1013, 5, 192, 97, 2, 1012, 1014, 5,
	44, 23, 2, 1013, 1012, 3, 2, 2, 2, 1013, 1014, 3, 2, 2, 2, 1014, 1017,
	3, 2, 2, 2, 1015, 1016, 7, 113, 2, 2, 1016, 1018, 7, 40, 2, 2, 1017, 1015,
	3, 2, 2, 2, 1017, 1018, 3, 2, 2, 2, 1018, 1020, 3, 2, 2, 2, 1019, 988,
	3, 2, 2, 2, 1019, 998, 3, 2, 2, 2, 1020, 85, 3, 2, 2, 2, 1021, 1022, 7,
	56, 2, 2, 1022, 1023, 7, 34, 2, 2, 1023, 1035, 5, 198, 100, 2, 1024, 1031,
	7, 56, 2, 2, 1025, 1032, 7, 47, 2, 2, 1026, 1028, 7, 156, 2, 2, 1027, 1026,
	3, 2, 2, 2, 1027, 1028, 3, 2, 2, 2, 1028, 1029, 3, 2, 2, 2, 1029, 1032,
	7, 154, 2, 2, 1030, 1032, 7, 176, 2, 2, 1031, 1025, 3, 2, 2, 2, 1031, 1027,
	3, 2, 2, 2, 1031, 1030, 3, 2, 2, 2, 1031, 1032, 3, 2, 2, 2, 1032, 1033,
	3, 2, 2, 2, 1033, 1035, 5, 192, 97, 2, 1034, 1021, 3, 2, 2, 2, 1034, 1024,
	3, 2, 2, 2, 1035, 87, 3, 2, 2, 2, 1036, 1037, 7, 57, 2, 2, 1037, 1038,
	7, 15, 2, 2, 1038, 1043, 5, 4, 3, 2, 1039, 1040, 7, 57, 2, 2, 1040, 1041,
	7, 152, 2, 2, 1041, 1043, 5, 4, 3, 2, 1042, 1036, 3, 2, 2, 2, 1042, 1039,
	3, 2, 2, 2, 1043, 89, 3, 2, 2, 2, 1044, 1045, 7, 84, 2, 2, 1045, 1047,
	7, 86, 2, 2, 1046, 1048, 7, 154, 2, 2, 1047, 1046, 3, 2, 2, 2, 1047, 1048,
	3, 2, 2, 2, 1048, 1052, 3, 2, 2, 2, 1049, 1053, 5, 192, 97, 2, 1050, 1051,
	7, 69, 2, 2, 1051, 1053, 5, 190, 96, 2, 1052, 1049, 3, 2, 2, 2, 1052, 1050,
	3, 2, 2, 2, 1053, 1055, 3, 2, 2, 2, 1054, 1056, 5, 92, 47, 2, 1055, 1054,
	3, 2, 2, 2, 1055, 1056, 3, 2, 2, 2, 1056, 1057, 3, 2, 2, 2, 1057, 1058,
	5, 94, 48, 2, 1058, 91, 3, 2, 2, 2, 1059, 1060, 7, 208, 2, 2, 1060, 1065,
	5, 186, 94, 2, 1061, 1062, 7, 197, 2, 2, 1062, 1064, 5, 186, 94, 2, 1063,
	1061, 3, 2, 2, 2, 1064, 1067, 3, 2, 2, 2, 1065, 1063, 3, 2, 2, 2, 1065,
	1066, 3, 2, 2, 2, 1066, 1068, 3, 2, 2, 2, 1067, 1065, 3, 2, 2, 2, 1068,
	1069, 7, 218, 2, 2, 1069, 93, 3, 2, 2, 2, 1070, 1071, 7, 65, 2, 2, 1071,
	1080, 5, 214, 108, 2, 1072, 1080, 7, 175, 2, 2, 1073, 1075, 5, 104, 53,
	2, 1074, 1076, 7, 219, 2, 2, 1075, 1074, 3, 2, 2, 2, 1075, 1076, 3, 2,
	2, 2, 1076, 1077, 3, 2, 2, 2, 1077, 1078, 7, 2, 2, 3, 1078, 1080, 3, 2,
	2, 2, 1079, 1070, 3, 2, 2, 2, 1079, 1072, 3, 2, 2, 2, 1079, 1073, 3, 2,
	2, 2, 1080, 95, 3, 2, 2, 2, 1081, 1082, 7, 91, 2, 2, 1082, 1084, 7, 111,
	2, 2, 1083, 1085, 5, 44, 23, 2, 1084, 1083, 3, 2, 2, 2, 1084, 1085, 3,
	2, 2, 2, 1085, 1086, 3, 2, 2, 2, 1086, 1088, 5, 120, 61, 2, 1087, 1089,
	9, 7, 2, 2, 1088, 1087, 3, 2, 2, 2, 1088, 1089, 3, 2, 2, 2, 1089, 97, 3,
	2, 2, 2, 1090, 1091, 7, 119, 2, 2, 1091, 1092, 7, 154, 2, 2, 1092, 1094,
	5, 192, 97, 2, 1093, 1095, 5, 44, 23, 2, 1094, 1093, 3, 2, 2, 2, 1094,
	1095, 3, 2, 2, 2, 1095, 1097, 3, 2, 2, 2, 1096, 1098, 5, 16, 9, 2, 1097,
	1096, 3, 2, 2, 2, 1097, 1098, 3, 2, 2, 2, 1098, 1100, 3, 2, 2, 2, 1099,
	1101, 7, 61, 2, 2, 1100, 1099, 3, 2, 2, 2, 1100, 1101, 3, 2, 2, 2, 1101,
	1103, 3, 2, 2, 2, 1102, 1104, 7, 38, 2, 2, 1103, 1102, 3, 2, 2, 2, 1103,
	1104, 3, 2, 2, 2, 1104, 99, 3, 2, 2, 2, 1105, 1106, 7, 133, 2, 2, 1106,
	1107, 7, 154, 2, 2, 1107, 1108, 5, 192, 97, 2, 1108, 1109, 7, 162, 2, 2,
	1109, 1117, 5, 192, 97, 2, 1110, 1111, 7, 197, 2, 2, 1111, 1112, 5, 192,
	97, 2, 1112, 1113, 7, 162, 2, 2, 1113, 1114, 5, 192, 97, 2, 1114, 1116,
	3, 2, 2, 2, 1115, 1110, 3, 2, 2, 2, 1116, 1119, 3, 2, 2, 2, 1117, 1115,
	3, 2, 2, 2, 1117, 1118, 3, 2, 2, 2, 1118, 1121, 3, 2, 2, 2, 1119, 1117,
	3, 2, 2, 2, 1120, 1122, 5, 44, 23, 2, 1121, 1120, 3, 2, 2, 2, 1121, 1122,
	3, 2, 2, 2, 1122, 101, 3, 2, 2, 2, 1123, 1125, 7, 208, 2, 2, 1124, 1126,
	5, 110, 56, 2, 1125, 1124, 3, 2, 2, 2, 1125, 1126, 3, 2, 2, 2, 1126, 1127,
	3, 2, 2, 2, 1127, 1128, 7, 141, 2, 2, 1128, 1130, 5, 172, 87, 2, 1129,
	1131, 5, 122, 62, 2, 1130, 1129, 3, 2, 2, 2, 1130, 1131, 3, 2, 2, 2, 1131,
	1133, 3, 2, 2, 2, 1132, 1134, 5, 128, 65, 2, 1133, 1132, 3, 2, 2, 2, 1133,
	1134, 3, 2, 2, 2, 1134, 1135, 3, 2, 2, 2, 1135, 1136, 7, 218, 2, 2, 1136,
	103, 3, 2, 2, 2, 1137, 1143, 5, 106, 54, 2, 1138, 1139, 7, 170, 2, 2, 1139,
	1140, 7, 6, 2, 2, 1140, 1142, 5, 106, 54, 2, 1141, 1138, 3, 2, 2, 2, 1142,
	1145, 3, 2, 2, 2, 1143, 1141, 3, 2, 2, 2, 1143, 1144, 3, 2, 2, 2, 1144,
	105, 3, 2, 2, 2, 1145, 1143, 3, 2, 2, 2, 1146, 1152, 5, 108, 55, 2, 1147,
	1148, 7, 208, 2, 2, 1148, 1149, 5, 104, 53, 2, 1149, 1150, 7, 218, 2, 2,
	1150, 1152, 3, 2, 2, 2, 1151, 1146, 3, 2, 2, 2, 1151, 1147, 3, 2, 2, 2,
	1152, 107, 3, 2, 2, 2, 1153, 1155, 5, 110, 56, 2, 1154, 1153, 3, 2, 2,
	2, 1154, 1155, 3, 2, 2, 2, 1155, 1156, 3, 2, 2, 2, 1156, 1158, 7, 141,
	2, 2, 1157, 1159, 7, 49, 2, 2, 1158, 1157, 3, 2, 2, 2, 1158, 1159, 3, 2,
	2, 2, 1159, 1161, 3, 2, 2, 2, 1160, 1162, 5, 112, 57, 2, 1161, 1160, 3,
	2, 2, 2, 1161, 1162, 3, 2, 2, 2, 1162, 1163, 3, 2, 2, 2, 1163, 1165, 5,
	172, 87, 2, 1164, 1166, 5, 114, 58, 2, 1165, 1164, 3, 2, 2, 2, 1165, 1166,
	3, 2, 2, 2, 1166, 1168, 3, 2, 2, 2, 1167, 1169, 5, 116, 59, 2, 1168, 1167,
	3, 2, 2, 2, 1168, 1169, 3, 2, 2, 2, 1169, 1171, 3, 2, 2, 2, 1170, 1172,
	5, 118, 60, 2, 1171, 1170, 3, 2, 2, 2, 1171, 1172, 3, 2, 2, 2, 1172, 1174,
	3, 2, 2, 2, 1173, 1175, 5, 120, 61, 2, 1174, 1173, 3, 2, 2, 2, 1174, 1175,
	3, 2, 2, 2, 1175, 1177, 3, 2, 2, 2, 1176, 1178, 5, 122, 62, 2, 1177, 1176,
	3, 2, 2, 2, 1177, 1178, 3, 2, 2, 2, 1178, 1181, 3, 2, 2, 2, 1179, 1180,
	7, 182, 2, 2, 1180, 1182, 9, 8, 2, 2, 1181, 1179, 3, 2, 2, 2, 1181, 1182,
	3, 2, 2, 2, 1182, 1185, 3, 2, 2, 2, 1183, 1184, 7, 182, 2, 2, 1184, 1186,
	7, 164, 2, 2, 1185, 1183, 3, 2, 2, 2, 1185, 1186, 3, 2, 2, 2, 1186, 1188,
	3, 2, 2, 2, 1187, 1189, 5, 124, 63, 2, 1188, 1187, 3, 2, 2, 2, 1188, 1189,
	3, 2, 2, 2, 1189, 1191, 3, 2, 2, 2, 1190, 1192, 5, 126, 64, 2, 1191, 1190,
	3, 2, 2, 2, 1191, 1192, 3, 2, 2, 2, 1192, 1194, 3, 2, 2, 2, 1193, 1195,
	5, 130, 66, 2, 1194, 1193, 3, 2, 2, 2, 1194, 1195, 3, 2, 2, 2, 1195, 1197,
	3, 2, 2, 2, 1196, 1198, 5, 132, 67, 2, 1197, 1196, 3, 2, 2, 2, 1197, 1198,
	3, 2, 2, 2, 1198, 1200, 3, 2, 2, 2, 1199, 1201, 5, 134, 68, 2, 1200, 1199,
	3, 2, 2, 2, 1200, 1201, 3, 2, 2, 2, 1201, 109, 3, 2, 2, 2, 1202, 1203,
	7, 182, 2, 2, 1203, 1204, 5, 172, 87, 2, 1204, 111, 3, 2, 2, 2, 1205, 1206,
	7, 163, 2, 2, 1206, 1209, 7, 189, 2, 2, 1207, 1208, 7, 182, 2, 2, 1208,
	1210, 7, 159, 2, 2, 1209, 1207, 3, 2, 2, 2, 1209, 1210, 3, 2, 2, 2, 1210,
	113, 3, 2, 2, 2, 1211, 1212, 7, 67, 2, 2, 1212, 1213, 5, 136, 69, 2, 1213,
	115, 3, 2, 2, 2, 1214, 1216, 9, 9, 2, 2, 1215, 1214, 3, 2, 2, 2, 1215,
	1216, 3, 2, 2, 2, 1216, 1217, 3, 2, 2, 2, 1217, 1218, 7, 11, 2, 2, 1218,
	1219, 7, 89, 2, 2, 1219, 1220, 5, 172, 87, 2, 1220, 117, 3, 2, 2, 2, 1221,
	1222, 7, 126, 2, 2, 1222, 1223, 5, 176, 89, 2, 1223, 119, 3, 2, 2, 2, 1224,
	1225, 7, 181, 2, 2, 1225, 1226, 5, 176, 89, 2, 1226, 121, 3, 2, 2, 2, 1227,
	1228, 7, 72, 2, 2, 1228, 1235, 7, 20, 2, 2, 1229, 1230, 9, 8, 2, 2, 1230,
	1231, 7, 208, 2, 2, 1231, 1232, 5, 172, 87, 2, 1232, 1233, 7, 218, 2, 2,
	1233, 1236, 3, 2, 2, 2, 1234, 1236, 5, 172, 87, 2, 1235, 1229, 3, 2, 2,
	2, 1235, 1234, 3, 2, 2, 2, 1236, 123, 3, 2, 2, 2, 1237, 1238, 7, 73, 2,
	2, 1238, 1239, 5, 176, 89, 2, 1239, 125, 3, 2, 2, 2, 1240, 1241, 7, 121,
	2, 2, 1241, 1242, 7, 20, 2, 2, 1242, 1243, 5, 148, 75, 2, 1243, 127, 3,
	2, 2, 2, 1244, 1245, 7, 121, 2, 2, 1245, 1246, 7, 20, 2, 2, 1246, 1247,
	5, 172, 87, 2, 1247, 129, 3, 2, 2, 2, 1248, 1249, 7, 98, 2, 2, 1249, 1250,
	5, 146, 74, 2, 1250, 1251, 7, 20, 2, 2, 1251, 1252, 5, 172, 87, 2, 1252,
	131, 3, 2, 2, 2, 1253, 1254, 7, 98, 2, 2, 1254, 1257, 5, 146, 74, 2, 1255,
	1256, 7, 182, 2, 2, 1256, 1258, 7, 159, 2, 2, 1257, 1255, 3, 2, 2, 2, 1257,
	1258, 3, 2, 2, 2, 1258, 133, 3, 2, 2, 2, 1259, 1260, 7, 145, 2, 2, 1260,
	1261, 5, 154, 78, 2, 1261, 135, 3, 2, 2, 2, 1262, 1263, 8, 69, 1, 2, 1263,
	1265, 5, 188, 95, 2, 1264, 1266, 7, 61, 2, 2, 1265, 1264, 3, 2, 2, 2, 1265,
	1266, 3, 2, 2, 2, 1266, 1268, 3, 2, 2, 2, 1267, 1269, 5, 144, 73, 2, 1268,
	1267, 3, 2, 2, 2, 1268, 1269, 3, 2, 2, 2, 1269, 1275, 3, 2, 2, 2, 1270,
	1271, 7, 208, 2, 2, 1271, 1272, 5, 136, 69, 2, 1272, 1273, 7, 218, 2, 2,
	1273, 1275, 3, 2, 2, 2, 1274, 1262, 3, 2, 2, 2, 1274, 1270, 3, 2, 2, 2,
	1275, 1293, 3, 2, 2, 2, 1276, 1277, 12, 5, 2, 2, 1277, 1278, 5, 140, 71,
	2, 1278, 1279, 5, 136, 69, 6, 1279, 1292, 3, 2, 2, 2, 1280, 1282, 12, 6,
	2, 2, 1281, 1283, 9, 10, 2, 2, 1282, 1281, 3, 2, 2, 2, 1282, 1283, 3, 2,
	2, 2, 1283, 1285, 3, 2, 2, 2, 1284, 1286, 5, 138, 70, 2, 1285, 1284, 3,
	2, 2, 2, 1285, 1286, 3, 2, 2, 2, 1286, 1287, 3, 2, 2, 2, 1287, 1288, 7,
	89, 2, 2, 1288, 1289, 5, 136, 69, 2, 1289, 1290, 5, 142, 72, 2, 1290, 1292,
	3, 2, 2, 2, 1291, 1276, 3, 2, 2, 2, 1291, 1280, 3, 2, 2, 2, 1292, 1295,
	3, 2, 2, 2, 1293, 1291, 3, 2, 2, 2, 1293, 1294, 3, 2, 2, 2, 1294, 137,
	3, 2, 2, 2, 1295, 1293, 3, 2, 2, 2, 1296, 1298, 9, 11, 2, 2, 1297, 1296,
	3, 2, 2, 2, 1297, 1298, 3, 2, 2, 2, 1298, 1299, 3, 2, 2, 2, 1299, 1306,
	7, 83, 2, 2, 1300, 1302, 7, 83, 2, 2, 1301, 1303, 9, 11, 2, 2, 1302, 1301,
	3, 2, 2, 2, 1302, 1303, 3, 2, 2, 2, 1303, 1306, 3, 2, 2, 2, 1304, 1306,
	9, 11, 2, 2, 1305, 1297, 3, 2, 2, 2, 1305, 1300, 3, 2, 2, 2, 1305, 1304,
	3, 2, 2, 2, 1306, 1340, 3, 2, 2, 2, 1307, 1309, 9, 12, 2, 2, 1308, 1307,
	3, 2, 2, 2, 1308, 1309, 3, 2, 2, 2, 1309, 1310, 3, 2, 2, 2, 1310, 1312,
	9, 13, 2, 2, 1311, 1313, 7, 122, 2, 2, 1312, 1311, 3, 2, 2, 2, 1312, 1313,
	3, 2, 2, 2, 1313, 1322, 3, 2, 2, 2, 1314, 1316, 9, 13, 2, 2, 1315, 1317,
	7, 122, 2, 2, 1316, 1315, 3, 2, 2, 2, 1316, 1317, 3, 2, 2, 2, 1317, 1319,
	3, 2, 2, 2, 1318, 1320, 9, 12, 2, 2, 1319, 1318, 3, 2, 2, 2, 1319, 1320,
	3, 2, 2, 2, 1320, 1322, 3, 2, 2, 2, 1321, 1308, 3, 2, 2, 2, 1321, 1314,
	3, 2, 2, 2, 1322, 1340, 3, 2, 2, 2, 1323, 1325, 9, 14, 2, 2, 1324, 1323,
	3, 2, 2, 2, 1324, 1325, 3, 2, 2, 2, 1325, 1326, 3, 2, 2, 2, 1326, 1328,
	7, 68, 2, 2, 1327, 1329, 7, 122, 2, 2, 1328, 1327, 3, 2, 2, 2, 1328, 1329,
	3, 2, 2, 2, 1329, 1338, 3, 2, 2, 2, 1330, 1332, 7, 68, 2, 2, 1331, 1333,
	7, 122, 2, 2, 1332, 1331, 3, 2, 2, 2, 1332, 1333, 3, 2, 2, 2, 1333, 1335,
	3, 2, 2, 2, 1334, 1336, 9, 14, 2, 2, 1335, 1334, 3, 2, 2, 2, 1335, 1336,
	3, 2, 2, 2, 1336, 1338, 3, 2, 2, 2, 1337, 1324, 3, 2, 2, 2, 1337, 1330,
	3, 2, 2, 2, 1338, 1340, 3, 2, 2, 2, 1339, 1305, 3, 2, 2, 2, 1339, 1321,
	3, 2, 2, 2, 1339, 1337, 3, 2, 2, 2, 1340, 139, 3, 2, 2, 2, 1341, 1343,
	9, 10, 2, 2, 1342, 1341, 3, 2, 2, 2, 1342, 1343, 3, 2, 2, 2, 1343, 1344,
	3, 2, 2, 2, 1344, 1345, 7, 32, 2, 2, 1345, 1348, 7, 89, 2, 2, 1346, 1348,
	7, 197, 2, 2, 1347, 1342, 3, 2, 2, 2, 1347, 1346, 3, 2, 2, 2, 1348, 141,
	3, 2, 2, 2, 1349, 1350, 7, 118, 2, 2, 1350, 1359, 5, 172, 87, 2, 1351,
	1352, 7, 173, 2, 2, 1352, 1353, 7, 208, 2, 2, 1353, 1354, 5, 172, 87, 2,
	1354, 1355, 7, 218, 2, 2, 1355, 1359, 3, 2, 2, 2, 1356, 1357, 7, 173, 2,
	2, 1357, 1359, 5, 172, 87, 2, 1358, 1349, 3, 2, 2, 2, 1358, 1351, 3, 2,
	2, 2, 1358, 1356, 3, 2, 2, 2, 1359, 143, 3, 2, 2, 2, 1360, 1361, 7, 139,
	2, 2, 1361, 1364, 5, 152, 77, 2, 1362, 1363, 7, 117, 2, 2, 1363, 1365,
	5, 152, 77, 2, 1364, 1362, 3, 2, 2, 2, 1364, 1365, 3, 2, 2, 2, 1365, 145,
	3, 2, 2, 2, 1366, 1369, 5, 176, 89, 2, 1367, 1368, 9, 15, 2, 2, 1368, 1370,
	5, 176, 89, 2, 1369, 1367, 3, 2, 2, 2, 1369, 1370, 3, 2, 2, 2, 1370, 147,
	3, 2, 2, 2, 1371, 1376, 5, 150, 76, 2, 1372, 1373, 7, 197, 2, 2, 1373,
	1375, 5, 150, 76, 2, 1374, 1372, 3, 2, 2, 2, 1375, 1378, 3, 2, 2, 2, 1376,
	1374, 3, 2, 2, 2, 1376, 1377, 3, 2, 2, 2, 1377, 149, 3, 2, 2, 2, 1378,
	1376, 3, 2, 2, 2, 1379, 1381, 5, 176, 89, 2, 1380, 1382, 9, 16, 2, 2, 1381,
	1380, 3, 2, 2, 2, 1381, 1382, 3, 2, 2, 2, 1382, 1385, 3, 2, 2, 2, 1383,
	1384, 7, 116, 2, 2, 1384, 1386, 9, 17, 2, 2, 1385, 1383, 3, 2, 2, 2, 1385,
	1386, 3, 2, 2, 2, 1386, 1389, 3, 2, 2, 2, 1387, 1388, 7, 27, 2, 2, 1388,
	1390, 7, 191, 2, 2, 1389, 1387, 3, 2, 2, 2, 1389, 1390, 3, 2, 2, 2, 1390,
	151, 3, 2, 2, 2, 1391, 1394, 5, 202, 102, 2, 1392, 1393, 7, 220, 2, 2,
	1393, 1395, 5, 202, 102, 2, 1394, 1392, 3, 2, 2, 2, 1394, 1395, 3, 2, 2,
	2, 1395, 153, 3, 2, 2, 2, 1396, 1401, 5, 156, 79, 2, 1397, 1398, 7, 197,
	2, 2, 1398, 1400, 5, 156, 79, 2, 1399, 1397, 3, 2, 2, 2, 1400, 1403, 3,
	2, 2, 2, 1401, 1399, 3, 2, 2, 2, 1401, 1402, 3, 2, 2, 2, 1402, 155, 3,
	2, 2, 2, 1403, 1401, 3, 2, 2, 2, 1404, 1405, 5, 214, 108, 2, 1405, 1406,
	7, 202, 2, 2, 1406, 1407, 5, 204, 103, 2, 1407, 157, 3, 2, 2, 2, 1408,
	1409, 7, 144, 2, 2, 1409, 1410, 5, 154, 78, 2, 1410, 159, 3, 2, 2, 2, 1411,
	1412, 7, 146, 2, 2, 1412, 1413, 7, 31, 2, 2, 1413, 1414, 7, 34, 2, 2, 1414,
	1454, 5, 198, 100, 2, 1415, 1416, 7, 146, 2, 2, 1416, 1417, 7, 31, 2, 2,
	1417, 1418, 7, 47, 2, 2, 1418, 1454, 5, 192, 97, 2, 1419, 1420, 7, 146,
	2, 2, 1420, 1422, 7, 31, 2, 2, 1421, 1423, 7, 156, 2, 2, 1422, 1421, 3,
	2, 2, 2, 1422, 1423, 3, 2, 2, 2, 1423, 1425, 3, 2, 2, 2, 1424, 1426, 7,
	154, 2, 2, 1425, 1424, 3, 2, 2, 2, 1425, 1426, 3, 2, 2, 2, 1426, 1427,
	3, 2, 2, 2, 1427, 1454, 5, 192, 97, 2, 1428, 1429, 7, 146, 2, 2, 1429,
	1454, 7, 35, 2, 2, 1430, 1431, 7, 146, 2, 2, 1431, 1434, 7, 46, 2, 2, 1432,
	1433, 7, 67, 2, 2, 1433, 1435, 5, 198, 100, 2, 1434, 1432, 3, 2, 2, 2,
	1434, 1435, 3, 2, 2, 2, 1435, 1454, 3, 2, 2, 2, 1436, 1438, 7, 146, 2,
	2, 1437, 1439, 7, 156, 2, 2, 1438, 1437, 3, 2, 2, 2, 1438, 1439, 3, 2,
	2, 2, 1439, 1440, 3, 2, 2, 2, 1440, 1443, 7, 155, 2, 2, 1441, 1442, 9,
	18, 2, 2, 1442, 1444, 5, 198, 100, 2, 1443, 1441, 3, 2, 2, 2, 1443, 1444,
	3, 2, 2, 2, 1444, 1448, 3, 2, 2, 2, 1445, 1446, 7, 97, 2, 2, 1446, 1449,
	7, 191, 2, 2, 1447, 1449, 5, 120, 61, 2, 1448, 1445, 3, 2, 2, 2, 1448,
	1447, 3, 2, 2, 2, 1448, 1449, 3, 2, 2, 2, 1449, 1451, 3, 2, 2, 2, 1450,
	1452, 5, 132, 67, 2, 1451, 1450, 3, 2, 2, 2, 1451, 1452, 3, 2, 2, 2, 1452,
	1454, 3, 2, 2, 2, 1453, 1411, 3, 2, 2, 2, 1453, 1415, 3, 2, 2, 2, 1453,
	1419, 3, 2, 2, 2, 1453, 1428, 3, 2, 2, 2, 1453, 1430, 3, 2, 2, 2, 1453,
	1436, 3, 2, 2, 2, 1454, 161, 3, 2, 2, 2, 1455, 1456, 7, 153, 2, 2, 1456,
	1457, 7, 63, 2, 2, 1457, 1458, 7, 50, 2, 2, 1458, 1490, 5, 192, 97, 2,
	1459, 1460, 7, 153, 2, 2, 1460, 1461, 7, 63, 2, 2, 1461, 1490, 7, 101,
	2, 2, 1462, 1463, 7, 153, 2, 2, 1463, 1464, 7, 131, 2, 2, 1464, 1490, 7,
	46, 2, 2, 1465, 1466, 7, 153, 2, 2, 1466, 1467, 7, 131, 2, 2, 1467, 1468,
	7, 47, 2, 2, 1468, 1490, 5, 192, 97, 2, 1469, 1470, 7, 153, 2, 2, 1470,
	1478, 9, 19, 2, 2, 1471, 1472, 7, 50, 2, 2, 1472, 1479, 7, 143, 2, 2, 1473,
	1479, 7, 60, 2, 2, 1474, 1476, 7, 168, 2, 2, 1475, 1474, 3, 2, 2, 2, 1475,
	1476, 3, 2, 2, 2, 1476, 1477, 3, 2, 2, 2, 1477, 1479, 7, 105, 2, 2, 1478,
	1471, 3, 2, 2, 2, 1478, 1473, 3, 2, 2, 2, 1478, 1475, 3, 2, 2, 2, 1479,
	1480, 3, 2, 2, 2, 1480, 1490, 5, 192, 97, 2, 1481, 1482, 7, 153, 2, 2,
	1482, 1483, 9, 19, 2, 2, 1483, 1484, 7, 136, 2, 2, 1484, 1490, 7, 143,
	2, 2, 1485, 1486, 7, 153, 2, 2, 1486, 1487, 7, 151, 2, 2, 1487, 1488, 7,
	135, 2, 2, 1488, 1490, 5, 192, 97, 2, 1489, 1455, 3, 2, 2, 2, 1489, 1459,
	3, 2, 2, 2, 1489, 1462, 3, 2, 2, 2, 1489, 1465, 3, 2, 2, 2, 1489, 1469,
	3, 2, 2, 2, 1489, 1481, 3, 2, 2, 2, 1489, 1485, 3, 2, 2, 2, 1490, 163,
	3, 2, 2, 2, 1491, 1493, 7, 167, 2, 2, 1492, 1494, 7, 156, 2, 2, 1493, 1492,
	3, 2, 2, 2, 1493, 1494, 3, 2, 2, 2, 1494, 1496, 3, 2, 2, 2, 1495, 1497,
	7, 154, 2, 2, 1496, 1495, 3, 2, 2, 2, 1496, 1497, 3, 2, 2, 2, 1497, 1500,
	3, 2, 2, 2, 1498, 1499, 7, 77, 2, 2, 1499, 1501, 7, 56, 2, 2, 1500, 1498,
	3, 2, 2, 2, 1500, 1501, 3, 2, 2, 2, 1501, 1502, 3, 2, 2, 2, 1502, 1504,
	5, 192, 97, 2, 1503, 1505, 5, 44, 23, 2, 1504, 1503, 3, 2, 2, 2, 1504,
	1505, 3, 2, 2, 2, 1505, 165, 3, 2, 2, 2, 1506, 1507, 7, 172, 2, 2, 1507,
	1508, 5, 198, 100, 2, 1508, 167, 3, 2, 2, 2, 1509, 1510, 7, 178, 2, 2,
	1510, 1512, 5, 192, 97, 2, 1511, 1513, 7, 55, 2, 2, 1512, 1511, 3, 2, 2,
	2, 1512, 1513, 3, 2, 2, 2, 1513, 1516, 3, 2, 2, 2, 1514, 1515, 7, 98, 2,
	2, 1515, 1517, 7, 189, 2, 2, 1516, 1514, 3, 2, 2, 2, 1516, 1517, 3, 2,
	2, 2, 1517, 169, 3, 2, 2, 2, 1518, 1566, 5, 214, 108, 2, 1519, 1520, 5,
	214, 108, 2, 1520, 1521, 7, 208, 2, 2, 1521, 1522, 5, 214, 108, 2, 1522,
	1529, 5, 170, 86, 2, 1523, 1524, 7, 197, 2, 2, 1524, 1525, 5, 214, 108,
	2, 1525, 1526, 5, 170, 86, 2, 1526, 1528, 3, 2, 2, 2, 1527, 1523, 3, 2,
	2, 2, 1528, 1531, 3, 2, 2, 2, 1529, 1527, 3, 2, 2, 2, 1529, 1530, 3, 2,
	2, 2, 1530, 1532, 3, 2, 2, 2, 1531, 1529, 3, 2, 2, 2, 1532, 1533, 7, 218,
	2, 2, 1533, 1566, 3, 2, 2, 2, 1534, 1535, 5, 214, 108, 2, 1535, 1536, 7,
	208, 2, 2, 1536, 1541, 5, 218, 110, 2, 1537, 1538, 7, 197, 2, 2, 1538,
	1540, 5, 218, 110, 2, 1539, 1537, 3, 2, 2, 2, 1540, 1543, 3, 2, 2, 2, 1541,
	1539, 3, 2, 2, 2, 1541, 1542, 3, 2, 2, 2, 1542, 1544, 3, 2, 2, 2, 1543,
	1541, 3, 2, 2, 2, 1544, 1545, 7, 218, 2, 2, 1545, 1566, 3, 2, 2, 2, 1546,
	1547, 5, 214, 108, 2, 1547, 1548, 7, 208, 2, 2, 1548, 1553, 5, 170, 86,
	2, 1549, 1550, 7, 197, 2, 2, 1550, 1552, 5, 170, 86, 2, 1551, 1549, 3,
	2, 2, 2, 1552, 1555, 3, 2, 2, 2, 1553, 1551, 3, 2, 2, 2, 1553, 1554, 3,
	2, 2, 2, 1554, 1556, 3, 2, 2, 2, 1555, 1553, 3, 2, 2, 2, 1556, 1557, 7,
	218, 2, 2, 1557, 1566, 3, 2, 2, 2, 1558, 1559, 5, 214, 108, 2, 1559, 1561,
	7, 208, 2, 2, 1560, 1562, 5, 172, 87, 2, 1561, 1560, 3, 2, 2, 2, 1561,
	1562, 3, 2, 2, 2, 1562, 1563, 3, 2, 2, 2, 1563, 1564, 7, 218, 2, 2, 1564,
	1566, 3, 2, 2, 2, 1565, 1518, 3, 2, 2, 2, 1565, 1519, 3, 2, 2, 2, 1565,
	1534, 3, 2, 2, 2, 1565, 1546, 3, 2, 2, 2, 1565, 1558, 3, 2, 2, 2, 1566,
	171, 3, 2, 2, 2, 1567, 1572, 5, 174, 88, 2, 1568, 1569, 7, 197, 2, 2, 1569,
	1571, 5, 174, 88, 2, 1570, 1568, 3, 2, 2, 2, 1571, 1574, 3, 2, 2, 2, 1572,
	1570, 3, 2, 2, 2, 1572, 1573, 3, 2, 2, 2, 1573, 173, 3, 2, 2, 2, 1574,
	1572, 3, 2, 2, 2, 1575, 1576, 5, 192, 97, 2, 1576, 1577, 7, 200, 2, 2,
	1577, 1579, 3, 2, 2, 2, 1578, 1575, 3, 2, 2, 2, 1578, 1579, 3, 2, 2, 2,
	1579, 1580, 3, 2, 2, 2, 1580, 1587, 7, 193, 2, 2, 1581, 1582, 7, 208, 2,
	2, 1582, 1583, 5, 104, 53, 2, 1583, 1584, 7, 218, 2, 2, 1584, 1587, 3,
	2, 2, 2, 1585, 1587, 5, 176, 89, 2, 1586, 1578, 3, 2, 2, 2, 1586, 1581,
	3, 2, 2, 2, 1586, 1585, 3, 2, 2, 2, 1587, 175, 3, 2, 2, 2, 1588, 1589,
	8, 89, 1, 2, 1589, 1591, 7, 21, 2, 2, 1590, 1592, 5, 176, 89, 2, 1591,
	1590, 3, 2, 2, 2, 1591, 1592, 3, 2, 2, 2, 1592, 1598, 3, 2, 2, 2, 1593,
	1594, 7, 180, 2, 2, 1594, 1595, 5, 176, 89, 2, 1595, 1596, 7, 158, 2, 2,
	1596, 1597, 5, 176, 89, 2, 1597, 1599, 3, 2, 2, 2, 1598, 1593, 3, 2, 2,
	2, 1599, 1600, 3, 2, 2, 2, 1600, 1598, 3, 2, 2, 2, 1600, 1601, 3, 2, 2,
	2, 1601, 1604, 3, 2, 2, 2, 1602, 1603, 7, 52, 2, 2, 1603, 1605, 5, 176,
	89, 2, 1604, 1602, 3, 2, 2, 2, 1604, 1605, 3, 2, 2, 2, 1605, 1606, 3, 2,
	2, 2, 1606, 1607, 7, 53, 2, 2, 1607, 1696, 3, 2, 2, 2, 1608, 1609, 7, 22,
	2, 2, 1609, 1610, 7, 208, 2, 2, 1610, 1611, 5, 176, 89, 2, 1611, 1612,
	7, 12, 2, 2, 1612, 1613, 5, 170, 86, 2, 1613, 1614, 7, 218, 2, 2, 1614,
	1696, 3, 2, 2, 2, 1615, 1616, 7, 36, 2, 2, 1616, 1696, 7, 191, 2, 2, 1617,
	1618, 7, 59, 2, 2, 1618, 1619, 7, 208, 2, 2, 1619, 1620, 5, 206, 104, 2,
	1620, 1621, 7, 67, 2, 2, 1621, 1622, 5, 176, 89, 2, 1622, 1623, 7, 218,
	2, 2, 1623, 1696, 3, 2, 2, 2, 1624, 1625, 7, 85, 2, 2, 1625, 1626, 5, 176,
	89, 2, 1626, 1627, 5, 206, 104, 2, 1627, 1696, 3, 2, 2, 2, 1628, 1629,
	7, 150, 2, 2, 1629, 1630, 7, 208, 2, 2, 1630, 1631, 5, 176, 89, 2, 1631,
	1632, 7, 67, 2, 2, 1632, 1635, 5, 176, 89, 2, 1633, 1634, 7, 64, 2, 2,
	1634, 1636, 5, 176, 89, 2, 1635, 1633, 3, 2, 2, 2, 1635, 1636, 3, 2, 2,
	2, 1636, 1637, 3, 2, 2, 2, 1637, 1638, 7, 218, 2, 2, 1638, 1696, 3, 2,
	2, 2, 1639, 1640, 7, 161, 2, 2, 1640, 1696, 7, 191, 2, 2, 1641, 1642, 7,
	166, 2, 2, 1642, 1643, 7, 208, 2, 2, 1643, 1644, 9, 20, 2, 2, 1644, 1645,
	7, 191, 2, 2, 1645, 1646, 7, 67, 2, 2, 1646, 1647, 5, 176, 89, 2, 1647,
	1648, 7, 218, 2, 2, 1648, 1696, 3, 2, 2, 2, 1649, 1655, 5, 214, 108, 2,
	1650, 1652, 7, 208, 2, 2, 1651, 1653, 5, 172, 87, 2, 1652, 1651, 3, 2,
	2, 2, 1652, 1653, 3, 2, 2, 2, 1653, 1654, 3, 2, 2, 2, 1654, 1656, 7, 218,
	2, 2, 1655, 1650, 3, 2, 2, 2, 1655, 1656, 3, 2, 2, 2, 1656, 1657, 3, 2,
	2, 2, 1657, 1659, 7, 208, 2, 2, 1658, 1660, 7, 49, 2, 2, 1659, 1658, 3,
	2, 2, 2, 1659, 1660, 3, 2, 2, 2, 1660, 1662, 3, 2, 2, 2, 1661, 1663, 5,
	178, 90, 2, 1662, 1661, 3, 2, 2, 2, 1662, 1663, 3, 2, 2, 2, 1663, 1664,
	3, 2, 2, 2, 1664, 1665, 7, 218, 2, 2, 1665, 1696, 3, 2, 2, 2, 1666, 1696,
	5, 204, 103, 2, 1667, 1668, 7, 199, 2, 2, 1668, 1696, 5, 176, 89, 19, 1669,
	1670, 7, 114, 2, 2, 1670, 1696, 5, 176, 89, 14, 1671, 1672, 5, 192, 97,
	2, 1672, 1673, 7, 200, 2, 2, 1673, 1675, 3, 2, 2, 2, 1674, 1671, 3, 2,
	2, 2, 1674, 1675, 3, 2, 2, 2, 1675, 1676, 3, 2, 2, 2, 1676, 1696, 7, 193,
	2, 2, 1677, 1678, 7, 208, 2, 2, 1678, 1679, 5, 104, 53, 2, 1679, 1680,
	7, 218, 2, 2, 1680, 1696, 3, 2, 2, 2, 1681, 1682, 7, 208, 2, 2, 1682, 1683,
	5, 176, 89, 2, 1683, 1684, 7, 218, 2, 2, 1684, 1696, 3, 2, 2, 2, 1685,
	1686, 7, 208, 2, 2, 1686, 1687, 5, 172, 87, 2, 1687, 1688, 7, 218, 2, 2,
	1688, 1696, 3, 2, 2, 2, 1689, 1691, 7, 206, 2, 2, 1690, 1692, 5, 172, 87,
	2, 1691, 1690, 3, 2, 2, 2, 1691, 1692, 3, 2, 2, 2, 1692, 1693, 3, 2, 2,
	2, 1693, 1696, 7, 217, 2, 2, 1694, 1696, 5, 184, 93, 2, 1695, 1588, 3,
	2, 2, 2, 1695, 1608, 3, 2, 2, 2, 1695, 1615, 3, 2, 2, 2, 1695, 1617, 3,
	2, 2, 2, 1695, 1624, 3, 2, 2, 2, 1695, 1628, 3, 2, 2, 2, 1695, 1639, 3,
	2, 2, 2, 1695, 1641, 3, 2, 2, 2, 1695, 1649, 3, 2, 2, 2, 1695, 1666, 3,
	2, 2, 2, 1695, 1667, 3, 2, 2, 2, 1695, 1669, 3, 2, 2, 2, 1695, 1674, 3,
	2, 2, 2, 1695, 1677, 3, 2, 2, 2, 1695, 1681, 3, 2, 2, 2, 1695, 1685, 3,
	2, 2, 2, 1695, 1689, 3, 2, 2, 2, 1695, 1694, 3, 2, 2, 2, 1696, 1768, 3,
	2, 2, 2, 1697, 1698, 12, 18, 2, 2, 1698, 1699, 9, 21, 2, 2, 1699, 1767,
	5, 176, 89, 19, 1700, 1701, 12, 17, 2, 2, 1701, 1702, 9, 22, 2, 2, 1702,
	1767, 5, 176, 89, 18, 1703, 1722, 12, 16, 2, 2, 1704, 1723, 7, 201, 2,
	2, 1705, 1723, 7, 202, 2, 2, 1706, 1723, 7, 210, 2, 2, 1707, 1723, 7, 207,
	2, 2, 1708, 1723, 7, 203, 2, 2, 1709, 1723, 7, 209, 2, 2, 1710, 1723, 7,
	204, 2, 2, 1711, 1713, 7, 70, 2, 2, 1712, 1711, 3, 2, 2, 2, 1712, 1713,
	3, 2, 2, 2, 1713, 1715, 3, 2, 2, 2, 1714, 1716, 7, 114, 2, 2, 1715, 1714,
	3, 2, 2, 2, 1715, 1716, 3, 2, 2, 2, 1716, 1717, 3, 2, 2, 2, 1717, 1723,
	7, 79, 2, 2, 1718, 1720, 7, 114, 2, 2, 1719, 1718, 3, 2, 2, 2, 1719, 1720,
	3, 2, 2, 2, 1720, 1721, 3, 2, 2, 2, 1721, 1723, 9, 23, 2, 2, 1722, 1704,
	3, 2, 2, 2, 1722, 1705, 3, 2, 2, 2, 1722, 1706, 3, 2, 2, 2, 1722, 1707,
	3, 2, 2, 2, 1722, 1708, 3, 2, 2, 2, 1722, 1709, 3, 2, 2, 2, 1722, 1710,
	3, 2, 2, 2, 1722, 1712, 3, 2, 2, 2, 1722, 1719, 3, 2, 2, 2, 1723, 1724,
	3, 2, 2, 2, 1724, 1767, 5, 176, 89, 17, 1725, 1726, 12, 13, 2, 2, 1726,
	1727, 7, 8, 2, 2, 1727, 1767, 5, 176, 89, 14, 1728, 1729, 12, 12, 2, 2,
	1729, 1730, 7, 120, 2, 2, 1730, 1767, 5, 176, 89, 13, 1731, 1733, 12, 11,
	2, 2, 1732, 1734, 7, 114, 2, 2, 1733, 1732, 3, 2, 2, 2, 1733, 1734, 3,
	2, 2, 2, 1734, 1735, 3, 2, 2, 2, 1735, 1736, 7, 18, 2, 2, 1736, 1737, 5,
	176, 89, 2, 1737, 1738, 7, 8, 2, 2, 1738, 1739, 5, 176, 89, 12, 1739, 1767,
	3, 2, 2, 2, 1740, 1741, 12, 10, 2, 2, 1741, 1742, 7, 213, 2, 2, 1742, 1743,
	5, 176, 89, 2, 1743, 1744, 7, 196, 2, 2, 1744, 1745, 5, 176, 89, 10, 1745,
	1767, 3, 2, 2, 2, 1746, 1747, 12, 21, 2, 2, 1747, 1748, 7, 206, 2, 2, 1748,
	1749, 5, 176, 89, 2, 1749, 1750, 7, 217, 2, 2, 1750, 1767, 3, 2, 2, 2,
	1751, 1752, 12, 20, 2, 2, 1752, 1753, 7, 200, 2, 2, 1753, 1767, 7, 189,
	2, 2, 1754, 1755, 12, 15, 2, 2, 1755, 1757, 7, 87, 2, 2, 1756, 1758, 7,
	114, 2, 2, 1757, 1756, 3, 2, 2, 2, 1757, 1758, 3, 2, 2, 2, 1758, 1759,
	3, 2, 2, 2, 1759, 1767, 7, 115, 2, 2, 1760, 1764, 12, 9, 2, 2, 1761, 1765,
	5, 212, 107, 2, 1762, 1763, 7, 12, 2, 2, 1763, 1765, 5, 214, 108, 2, 1764,
	1761, 3, 2, 2, 2, 1764, 1762, 3, 2, 2, 2, 1765, 1767, 3, 2, 2, 2, 1766,
	1697, 3, 2, 2, 2, 1766, 1700, 3, 2, 2, 2, 1766, 1703, 3, 2, 2, 2, 1766,
	1725, 3, 2, 2, 2, 1766, 1728, 3, 2, 2, 2, 1766, 1731, 3, 2, 2, 2, 1766,
	1740, 3, 2, 2, 2, 1766, 1746, 3, 2, 2, 2, 1766, 1751, 3, 2, 2, 2, 1766,
	1754, 3, 2, 2, 2, 1766, 1760, 3, 2, 2, 2, 1767, 1770, 3, 2, 2, 2, 1768,
	1766, 3, 2, 2, 2, 1768, 1769, 3, 2, 2, 2, 1769, 177, 3, 2, 2, 2, 1770,
	1768, 3, 2, 2, 2, 1771, 1776, 5, 180, 91, 2, 1772, 1773, 7, 197, 2, 2,
	1773, 1775, 5, 180, 91, 2, 1774, 1772, 3, 2, 2, 2, 1775, 1778, 3, 2, 2,
	2, 1776, 1774, 3, 2, 2, 2, 1776, 1777, 3, 2, 2, 2, 1777, 179, 3, 2, 2,
	2, 1778, 1776, 3, 2, 2, 2, 1779, 1782, 5, 182, 92, 2, 1780, 1782, 5, 176,
	89, 2, 1781, 1779, 3, 2, 2, 2, 1781, 1780, 3, 2, 2, 2, 1782, 181, 3, 2,
	2, 2, 1783, 1784, 7, 208, 2, 2, 1784, 1789, 5, 214, 108, 2, 1785, 1786,
	7, 197, 2, 2, 1786, 1788, 5, 214, 108, 2, 1787, 1785, 3, 2, 2, 2, 1788,
	1791, 3, 2, 2, 2, 1789, 1787, 3, 2, 2, 2, 1789, 1790, 3, 2, 2, 2, 1790,
	1792, 3, 2, 2, 2, 1791, 1789, 3, 2, 2, 2, 1792, 1793, 7, 218, 2, 2, 1793,
	1803, 3, 2, 2, 2, 1794, 1799, 5, 214, 108, 2, 1795, 1796, 7, 197, 2, 2,
	1796, 1798, 5, 214, 108, 2, 1797, 1795, 3, 2, 2, 2, 1798, 1801, 3, 2, 2,
	2, 1799, 1797, 3, 2, 2, 2, 1799, 1800, 3, 2, 2, 2, 1800, 1803, 3, 2, 2,
	2, 1801, 1799, 3, 2, 2, 2, 1802, 1783, 3, 2, 2, 2, 1802, 1794, 3, 2, 2,
	2, 1803, 1804, 3, 2, 2, 2, 1804, 1805, 7, 192, 2, 2, 1805, 1806, 5, 176,
	89, 2, 1806, 183, 3, 2, 2, 2, 1807, 1808, 5, 192, 97, 2, 1808, 1809, 7,
	200, 2, 2, 1809, 1811, 3, 2, 2, 2, 1810, 1807, 3, 2, 2, 2, 1810, 1811,
	3, 2, 2, 2, 1811, 1812, 3, 2, 2, 2, 1812, 1813, 5, 186, 94, 2, 1813, 185,
	3, 2, 2, 2, 1814, 1817, 5, 214, 108, 2, 1815, 1816, 7, 200, 2, 2, 1816,
	1818, 5, 214, 108, 2, 1817, 1815, 3, 2, 2, 2, 1817, 1818, 3, 2, 2, 2, 1818,
	187, 3, 2, 2, 2, 1819, 1820, 8, 95, 1, 2, 1820, 1827, 5, 192, 97, 2, 1821,
	1827, 5, 190, 96, 2, 1822, 1823, 7, 208, 2, 2, 1823, 1824, 5, 104, 53,
	2, 1824, 1825, 7, 218, 2, 2, 1825, 1827, 3, 2, 2, 2, 1826, 1819, 3, 2,
	2, 2, 1826, 1821, 3, 2, 2, 2, 1826, 1822, 3, 2, 2, 2, 1827, 1836, 3, 2,
	2, 2, 1828, 1832, 12, 3, 2, 2, 1829, 1833, 5, 212, 107, 2, 1830, 1831,
	7, 12, 2, 2, 1831, 1833, 5, 214, 108, 2, 1832, 1829, 3, 2, 2, 2, 1832,
	1830, 3, 2, 2, 2, 1833, 1835, 3, 2, 2, 2, 1834, 1828, 3, 2, 2, 2, 1835,
	1838, 3, 2, 2, 2, 1836, 1834, 3, 2, 2, 2, 1836, 1837, 3, 2, 2, 2, 1837,
	189, 3, 2, 2, 2, 1838, 1836, 3, 2, 2, 2, 1839, 1840, 5, 214, 108, 2, 1840,
	1842, 7, 208, 2, 2, 1841, 1843, 5, 194, 98, 2, 1842, 1841, 3, 2, 2, 2,
	1842, 1843, 3, 2, 2, 2, 1843, 1844, 3, 2, 2, 2, 1844, 1845, 7, 218, 2,
	2, 1845, 191, 3, 2, 2, 2, 1846, 1847, 5, 198, 100, 2, 1847, 1848, 7, 200,
	2, 2, 1848, 1850, 3, 2, 2, 2, 1849, 1846, 3, 2, 2, 2, 1849, 1850, 3, 2,
	2, 2, 1850, 1851, 3, 2, 2, 2, 1851, 1852, 5, 214, 108, 2, 1852, 193, 3,
	2, 2, 2, 1853, 1858, 5, 196, 99, 2, 1854, 1855, 7, 197, 2, 2, 1855, 1857,
	5, 196, 99, 2, 1856, 1854, 3, 2, 2, 2, 1857, 1860, 3, 2, 2, 2, 1858, 1856,
	3, 2, 2, 2, 1858, 1859, 3, 2, 2, 2, 1859, 195, 3, 2, 2, 2, 1860, 1858,
	3, 2, 2, 2, 1861, 1865, 5, 186, 94, 2, 1862, 1865, 5, 190, 96, 2, 1863,
	1865, 5, 204, 103, 2, 1864, 1861, 3, 2, 2, 2, 1864, 1862, 3, 2, 2, 2, 1864,
	1863, 3, 2, 2, 2, 1865, 197, 3, 2, 2, 2, 1866, 1867, 5, 214, 108, 2, 1867,
	199, 3, 2, 2, 2, 1868, 1877, 7, 187, 2, 2, 1869, 1870, 7, 200, 2, 2, 1870,
	1877, 9, 24, 2, 2, 1871, 1872, 7, 189, 2, 2, 1872, 1874, 7, 200, 2, 2,
	1873, 1875, 9, 24, 2, 2, 1874, 1873, 3, 2, 2, 2, 1874, 1875, 3, 2, 2, 2,
	1875, 1877, 3, 2, 2, 2, 1876, 1868, 3, 2, 2, 2, 1876, 1869, 3, 2, 2, 2,
	1876, 1871, 3, 2, 2, 2, 1877, 201, 3, 2, 2, 2, 1878, 1880, 9, 25, 2, 2,
	1879, 1878, 3, 2, 2, 2, 1879, 1880, 3, 2, 2, 2, 1880, 1887, 3, 2, 2, 2,
	1881, 1888, 5, 200, 101, 2, 1882, 1888, 7, 188, 2, 2, 1883, 1888, 7, 189,
	2, 2, 1884, 1888, 7, 190, 2, 2, 1885, 1888, 7, 81, 2, 2, 1886, 1888, 7,
	112, 2, 2, 1887, 1881, 3, 2, 2, 2, 1887, 1882, 3, 2, 2, 2, 1887, 1883,
	3, 2, 2, 2, 1887, 1884, 3, 2, 2, 2, 1887, 1885, 3, 2, 2, 2, 1887, 1886,
	3, 2, 2, 2, 1888, 203, 3, 2, 2, 2, 1889, 1893, 5, 202, 102, 2, 1890, 1893,
	7, 191, 2, 2, 1891, 1893, 7, 115, 2, 2, 1892, 1889, 3, 2, 2, 2, 1892, 1890,
	3, 2, 2, 2, 1892, 1891, 3, 2, 2, 2, 1893, 205, 3, 2, 2, 2, 1894, 1895,
	9, 26, 2, 2, 1895, 207, 3, 2, 2, 2, 1896, 1897, 9, 27, 2, 2, 1897, 209,
	3, 2, 2, 2, 1898, 1899, 9, 28, 2, 2, 1899, 211, 3, 2, 2, 2, 1900, 1903,
	7, 186, 2, 2, 1901, 1903, 5, 210, 106, 2, 1902, 1900, 3, 2, 2, 2, 1902,
	1901, 3, 2, 2, 2, 1903, 213, 3, 2, 2, 2, 1904, 1908, 7, 186, 2, 2, 1905,
	1908, 5, 206, 104, 2, 1906, 1908, 5, 208, 105, 2, 1907, 1904, 3, 2, 2,
	2, 1907, 1905, 3, 2, 2, 2, 1907, 1906, 3, 2, 2, 2, 1908, 215, 3, 2, 2,
	2, 1909, 1912, 5, 214, 108, 2, 1910, 1912, 7, 115, 2, 2, 1911, 1909, 3,
	2, 2, 2, 1911, 1910, 3, 2, 2, 2, 1912, 217, 3, 2, 2, 2, 1913, 1914, 7,
	191, 2, 2, 1914, 1915, 7, 202, 2, 2, 1915, 1916, 5, 202, 102, 2, 1916,
	219, 3, 2, 2, 2, 259, 224, 228, 231, 234, 254, 260, 267, 275, 280, 287,
	292, 299, 304, 310, 316, 321, 327, 332, 338, 343, 349, 363, 370, 377, 384,
	390, 395, 401, 406, 412, 421, 431, 441, 461, 469, 484, 491, 505, 511, 517,
	524, 528, 531, 538, 542, 545, 556, 560, 563, 568, 570, 573, 576, 586, 590,
	593, 596, 601, 603, 609, 615, 619, 622, 625, 628, 631, 636, 642, 646, 649,
	652, 656, 664, 690, 692, 696, 718, 720, 731, 734, 743, 760, 771, 789, 802,
	819, 828, 855, 857, 878, 883, 888, 891, 903, 908, 912, 915, 919, 923, 928,
	931, 935, 937, 959, 967, 970, 980, 984, 992, 996, 1001, 1005, 1009, 1013,
	1017, 1019, 1027, 1031, 1034, 1042, 1047, 1052, 1055, 1065, 1075, 1079,
	1084, 1088, 1094, 1097, 1100, 1103, 1117, 1121, 1125, 1130, 1133, 1143,
	1151, 1154, 1158, 1161, 1165, 1168, 1171, 1174, 1177, 1181, 1185, 1188,
	1191, 1194, 1197, 1200, 1209, 1215, 1235, 1257, 1265, 1268, 1274, 1282,
	1285, 1291, 1293, 1297, 1302, 1305, 1308, 1312, 1316, 1319, 1321, 1324,
	1328, 1332, 1335, 1337, 1339, 1342, 1347, 1358, 1364, 1369, 1376, 1381,
	1385, 1389, 1394, 1401, 1422, 1425, 1434, 1438, 1443, 1448, 1451, 1453,
	1475, 1478, 1489, 1493, 1496, 1500, 1504, 1512, 1516, 1529, 1541, 1553,
	1561, 1565, 1572, 1578, 1586, 1591, 1600, 1604, 1635, 1652, 1655, 1659,
	1662, 1674, 1691, 1695, 1712, 1715, 1719, 1722, 1733, 1757, 1764, 1766,
	1768, 1776, 1781, 1789, 1799, 1802, 1810, 1817, 1826, 1832, 1836, 1842,
	1849, 1858, 1864, 1874, 1876, 1879, 1887, 1892, 1902, 1907, 1911,
}
var literalNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "'false'", "'true'", "", "", "", "", "", "", "'->'", "'*'", "'`'",
	"'\\'", "':'", "','", "'||'", "'-'", "'.'", "'=='", "'='", "'>='", "'>'",
	"'{'", "'['", "'<='", "'('", "'<'", "", "'%'", "'+'", "'?'", "'\"'", "'''",
	"'}'", "']'", "')'", "';'", "'/'", "'_'",
}
var symbolicNames = []string{
	"", "ADD", "AFTER", "ALIAS", "ALL", "ALTER", "AND", "ANTI", "ANY", "ARRAY",
	"AS", "ASCENDING", "ASOF", "AST", "ASYNC", "ATTACH", "BETWEEN", "BOTH",
	"BY", "CASE", "CAST", "CHECK", "CLEAR", "CLUSTER", "CODEC", "COLLATE",
	"COLUMN", "COMMENT", "CONSTRAINT", "CREATE", "CROSS", "CUBE", "DATABASE",
	"DATABASES", "DATE", "DAY", "DEDUPLICATE", "DEFAULT", "DELAY", "DELETE",
	"DESC", "DESCENDING", "DESCRIBE", "DETACH", "DICTIONARIES", "DICTIONARY",
	"DISK", "DISTINCT", "DISTRIBUTED", "DROP", "ELSE", "END", "ENGINE", "EVENTS",
	"EXISTS", "EXPLAIN", "EXPRESSION", "EXTRACT", "FETCHES", "FINAL", "FIRST",
	"FLUSH", "FOR", "FORMAT", "FREEZE", "FROM", "FULL", "FUNCTION", "GLOBAL",
	"GRANULARITY", "GROUP", "HAVING", "HIERARCHICAL", "HOUR", "ID", "IF", "ILIKE",
	"IN", "INDEX", "INF", "INJECTIVE", "INNER", "INSERT", "INTERVAL", "INTO",
	"IS", "IS_OBJECT_ID", "JOIN", "KEY", "KILL", "LAST", "LAYOUT", "LEADING",
	"LEFT", "LIFETIME", "LIKE", "LIMIT", "LIVE", "LOCAL", "LOGS", "MATERIALIZE",
	"MATERIALIZED", "MAX", "MERGES", "MIN", "MINUTE", "MODIFY", "MONTH", "MOVE",
	"MUTATION", "NAN_SQL", "NO", "NOT", "NULL_SQL", "NULLS", "OFFSET", "ON",
	"OPTIMIZE", "OR", "ORDER", "OUTER", "OUTFILE", "PARTITION", "POPULATE",
	"PREWHERE", "PRIMARY", "PROJECTION", "QUARTER", "RANGE", "RELOAD", "REMOVE",
	"RENAME", "REPLACE", "REPLICA", "REPLICATED", "RIGHT", "ROLLUP", "SAMPLE",
	"SECOND", "SELECT", "SEMI", "SENDS", "SET", "SETTINGS", "SHOW", "SOURCE",
	"START", "STOP", "SUBSTRING", "SYNC", "SYNTAX", "SYSTEM", "TABLE", "TABLES",
	"TEMPORARY", "TEST", "THEN", "TIES", "TIMEOUT", "TIMESTAMP", "TO", "TOP",
	"TOTALS", "TRAILING", "TRIM", "TRUNCATE", "TTL", "TYPE", "UNION", "UPDATE",
	"USE", "USING", "UUID", "VALUES", "VIEW", "VOLUME", "WATCH", "WEEK", "WHEN",
	"WHERE", "WITH", "YEAR", "JSON_FALSE", "JSON_TRUE", "IDENTIFIER", "FLOATING_LITERAL",
	"OCTAL_LITERAL", "DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "STRING_LITERAL",
	"ARROW", "ASTERISK", "BACKQUOTE", "BACKSLASH", "COLON", "COMMA", "CONCAT",
	"DASH", "DOT", "EQ_DOUBLE", "EQ_SINGLE", "GE", "GT", "LBRACE", "LBRACKET",
	"LE", "LPAREN", "LT", "NOT_EQ", "PERCENT", "PLUS", "QUERY", "QUOTE_DOUBLE",
	"QUOTE_SINGLE", "RBRACE", "RBRACKET", "RPAREN", "SEMICOLON", "SLASH", "UNDERSCORE",
	"MULTI_LINE_COMMENT", "SINGLE_LINE_COMMENT", "WHITESPACE",
}

var ruleNames = []string{
	"queryStmt", "query", "alterStmt", "alterTableClause", "assignmentExprList",
	"assignmentExpr", "tableColumnPropertyType", "partitionClause", "attachStmt",
	"checkStmt", "createStmt", "dictionarySchemaClause", "dictionaryAttrDfnt",
	"dictionaryEngineClause", "dictionaryPrimaryKeyClause", "dictionaryArgExpr",
	"sourceClause", "lifetimeClause", "layoutClause", "rangeClause", "dictionarySettingsClause",
	"clusterClause", "uuidClause", "destinationClause", "subqueryClause", "tableSchemaClause",
	"engineClause", "partitionByClause", "primaryKeyClause", "sampleByClause",
	"ttlClause", "engineExpr", "tableElementExpr", "tableColumnDfnt", "tableColumnPropertyExpr",
	"tableIndexDfnt", "tableProjectionDfnt", "codecExpr", "codecArgExpr", "ttlExpr",
	"describeStmt", "dropStmt", "existsStmt", "explainStmt", "insertStmt",
	"columnsClause", "dataClause", "killStmt", "optimizeStmt", "renameStmt",
	"projectionSelectStmt", "selectUnionStmt", "selectStmtWithParens", "selectStmt",
	"withClause", "topClause", "fromClause", "arrayJoinClause", "prewhereClause",
	"whereClause", "groupByClause", "havingClause", "orderByClause", "projectionOrderByClause",
	"limitByClause", "limitClause", "settingsClause", "joinExpr", "joinOp",
	"joinOpCross", "joinConstraintClause", "sampleClause", "limitExpr", "orderExprList",
	"orderExpr", "ratioExpr", "settingExprList", "settingExpr", "setStmt",
	"showStmt", "systemStmt", "truncateStmt", "useStmt", "watchStmt", "columnTypeExpr",
	"columnExprList", "columnsExpr", "columnExpr", "columnArgList", "columnArgExpr",
	"columnLambdaExpr", "columnIdentifier", "nestedIdentifier", "tableExpr",
	"tableFunctionExpr", "tableIdentifier", "tableArgList", "tableArgExpr",
	"databaseIdentifier", "floatingLiteral", "numberLiteral", "literal", "interval",
	"keyword", "keywordForAlias", "alias", "identifier", "identifierOrNull",
	"enumValue",
}

type ClickHouseParser struct {
	*antlr.BaseParser
}

// NewClickHouseParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *ClickHouseParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewClickHouseParser(input antlr.TokenStream) *ClickHouseParser {
	this := new(ClickHouseParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ClickHouseParser.g4"

	return this
}

// ClickHouseParser tokens.
const (
	ClickHouseParserEOF                 = antlr.TokenEOF
	ClickHouseParserADD                 = 1
	ClickHouseParserAFTER               = 2
	ClickHouseParserALIAS               = 3
	ClickHouseParserALL                 = 4
	ClickHouseParserALTER               = 5
	ClickHouseParserAND                 = 6
	ClickHouseParserANTI                = 7
	ClickHouseParserANY                 = 8
	ClickHouseParserARRAY               = 9
	ClickHouseParserAS                  = 10
	ClickHouseParserASCENDING           = 11
	ClickHouseParserASOF                = 12
	ClickHouseParserAST                 = 13
	ClickHouseParserASYNC               = 14
	ClickHouseParserATTACH              = 15
	ClickHouseParserBETWEEN             = 16
	ClickHouseParserBOTH                = 17
	ClickHouseParserBY                  = 18
	ClickHouseParserCASE                = 19
	ClickHouseParserCAST                = 20
	ClickHouseParserCHECK               = 21
	ClickHouseParserCLEAR               = 22
	ClickHouseParserCLUSTER             = 23
	ClickHouseParserCODEC               = 24
	ClickHouseParserCOLLATE             = 25
	ClickHouseParserCOLUMN              = 26
	ClickHouseParserCOMMENT             = 27
	ClickHouseParserCONSTRAINT          = 28
	ClickHouseParserCREATE              = 29
	ClickHouseParserCROSS               = 30
	ClickHouseParserCUBE                = 31
	ClickHouseParserDATABASE            = 32
	ClickHouseParserDATABASES           = 33
	ClickHouseParserDATE                = 34
	ClickHouseParserDAY                 = 35
	ClickHouseParserDEDUPLICATE         = 36
	ClickHouseParserDEFAULT             = 37
	ClickHouseParserDELAY               = 38
	ClickHouseParserDELETE              = 39
	ClickHouseParserDESC                = 40
	ClickHouseParserDESCENDING          = 41
	ClickHouseParserDESCRIBE            = 42
	ClickHouseParserDETACH              = 43
	ClickHouseParserDICTIONARIES        = 44
	ClickHouseParserDICTIONARY          = 45
	ClickHouseParserDISK                = 46
	ClickHouseParserDISTINCT            = 47
	ClickHouseParserDISTRIBUTED         = 48
	ClickHouseParserDROP                = 49
	ClickHouseParserELSE                = 50
	ClickHouseParserEND                 = 51
	ClickHouseParserENGINE              = 52
	ClickHouseParserEVENTS              = 53
	ClickHouseParserEXISTS              = 54
	ClickHouseParserEXPLAIN             = 55
	ClickHouseParserEXPRESSION          = 56
	ClickHouseParserEXTRACT             = 57
	ClickHouseParserFETCHES             = 58
	ClickHouseParserFINAL               = 59
	ClickHouseParserFIRST               = 60
	ClickHouseParserFLUSH               = 61
	ClickHouseParserFOR                 = 62
	ClickHouseParserFORMAT              = 63
	ClickHouseParserFREEZE              = 64
	ClickHouseParserFROM                = 65
	ClickHouseParserFULL                = 66
	ClickHouseParserFUNCTION            = 67
	ClickHouseParserGLOBAL              = 68
	ClickHouseParserGRANULARITY         = 69
	ClickHouseParserGROUP               = 70
	ClickHouseParserHAVING              = 71
	ClickHouseParserHIERARCHICAL        = 72
	ClickHouseParserHOUR                = 73
	ClickHouseParserID                  = 74
	ClickHouseParserIF                  = 75
	ClickHouseParserILIKE               = 76
	ClickHouseParserIN                  = 77
	ClickHouseParserINDEX               = 78
	ClickHouseParserINF                 = 79
	ClickHouseParserINJECTIVE           = 80
	ClickHouseParserINNER               = 81
	ClickHouseParserINSERT              = 82
	ClickHouseParserINTERVAL            = 83
	ClickHouseParserINTO                = 84
	ClickHouseParserIS                  = 85
	ClickHouseParserIS_OBJECT_ID        = 86
	ClickHouseParserJOIN                = 87
	ClickHouseParserKEY                 = 88
	ClickHouseParserKILL                = 89
	ClickHouseParserLAST                = 90
	ClickHouseParserLAYOUT              = 91
	ClickHouseParserLEADING             = 92
	ClickHouseParserLEFT                = 93
	ClickHouseParserLIFETIME            = 94
	ClickHouseParserLIKE                = 95
	ClickHouseParserLIMIT               = 96
	ClickHouseParserLIVE                = 97
	ClickHouseParserLOCAL               = 98
	ClickHouseParserLOGS                = 99
	ClickHouseParserMATERIALIZE         = 100
	ClickHouseParserMATERIALIZED        = 101
	ClickHouseParserMAX                 = 102
	ClickHouseParserMERGES              = 103
	ClickHouseParserMIN                 = 104
	ClickHouseParserMINUTE              = 105
	ClickHouseParserMODIFY              = 106
	ClickHouseParserMONTH               = 107
	ClickHouseParserMOVE                = 108
	ClickHouseParserMUTATION            = 109
	ClickHouseParserNAN_SQL             = 110
	ClickHouseParserNO                  = 111
	ClickHouseParserNOT                 = 112
	ClickHouseParserNULL_SQL            = 113
	ClickHouseParserNULLS               = 114
	ClickHouseParserOFFSET              = 115
	ClickHouseParserON                  = 116
	ClickHouseParserOPTIMIZE            = 117
	ClickHouseParserOR                  = 118
	ClickHouseParserORDER               = 119
	ClickHouseParserOUTER               = 120
	ClickHouseParserOUTFILE             = 121
	ClickHouseParserPARTITION           = 122
	ClickHouseParserPOPULATE            = 123
	ClickHouseParserPREWHERE            = 124
	ClickHouseParserPRIMARY             = 125
	ClickHouseParserPROJECTION          = 126
	ClickHouseParserQUARTER             = 127
	ClickHouseParserRANGE               = 128
	ClickHouseParserRELOAD              = 129
	ClickHouseParserREMOVE              = 130
	ClickHouseParserRENAME              = 131
	ClickHouseParserREPLACE             = 132
	ClickHouseParserREPLICA             = 133
	ClickHouseParserREPLICATED          = 134
	ClickHouseParserRIGHT               = 135
	ClickHouseParserROLLUP              = 136
	ClickHouseParserSAMPLE              = 137
	ClickHouseParserSECOND              = 138
	ClickHouseParserSELECT              = 139
	ClickHouseParserSEMI                = 140
	ClickHouseParserSENDS               = 141
	ClickHouseParserSET                 = 142
	ClickHouseParserSETTINGS            = 143
	ClickHouseParserSHOW                = 144
	ClickHouseParserSOURCE              = 145
	ClickHouseParserSTART               = 146
	ClickHouseParserSTOP                = 147
	ClickHouseParserSUBSTRING           = 148
	ClickHouseParserSYNC                = 149
	ClickHouseParserSYNTAX              = 150
	ClickHouseParserSYSTEM              = 151
	ClickHouseParserTABLE               = 152
	ClickHouseParserTABLES              = 153
	ClickHouseParserTEMPORARY           = 154
	ClickHouseParserTEST                = 155
	ClickHouseParserTHEN                = 156
	ClickHouseParserTIES                = 157
	ClickHouseParserTIMEOUT             = 158
	ClickHouseParserTIMESTAMP           = 159
	ClickHouseParserTO                  = 160
	ClickHouseParserTOP                 = 161
	ClickHouseParserTOTALS              = 162
	ClickHouseParserTRAILING            = 163
	ClickHouseParserTRIM                = 164
	ClickHouseParserTRUNCATE            = 165
	ClickHouseParserTTL                 = 166
	ClickHouseParserTYPE                = 167
	ClickHouseParserUNION               = 168
	ClickHouseParserUPDATE              = 169
	ClickHouseParserUSE                 = 170
	ClickHouseParserUSING               = 171
	ClickHouseParserUUID                = 172
	ClickHouseParserVALUES              = 173
	ClickHouseParserVIEW                = 174
	ClickHouseParserVOLUME              = 175
	ClickHouseParserWATCH               = 176
	ClickHouseParserWEEK                = 177
	ClickHouseParserWHEN                = 178
	ClickHouseParserWHERE               = 179
	ClickHouseParserWITH                = 180
	ClickHouseParserYEAR                = 181
	ClickHouseParserJSON_FALSE          = 182
	ClickHouseParserJSON_TRUE           = 183
	ClickHouseParserIDENTIFIER          = 184
	ClickHouseParserFLOATING_LITERAL    = 185
	ClickHouseParserOCTAL_LITERAL       = 186
	ClickHouseParserDECIMAL_LITERAL     = 187
	ClickHouseParserHEXADECIMAL_LITERAL = 188
	ClickHouseParserSTRING_LITERAL      = 189
	ClickHouseParserARROW               = 190
	ClickHouseParserASTERISK            = 191
	ClickHouseParserBACKQUOTE           = 192
	ClickHouseParserBACKSLASH           = 193
	ClickHouseParserCOLON               = 194
	ClickHouseParserCOMMA               = 195
	ClickHouseParserCONCAT              = 196
	ClickHouseParserDASH                = 197
	ClickHouseParserDOT                 = 198
	ClickHouseParserEQ_DOUBLE           = 199
	ClickHouseParserEQ_SINGLE           = 200
	ClickHouseParserGE                  = 201
	ClickHouseParserGT                  = 202
	ClickHouseParserLBRACE              = 203
	ClickHouseParserLBRACKET            = 204
	ClickHouseParserLE                  = 205
	ClickHouseParserLPAREN              = 206
	ClickHouseParserLT                  = 207
	ClickHouseParserNOT_EQ              = 208
	ClickHouseParserPERCENT             = 209
	ClickHouseParserPLUS                = 210
	ClickHouseParserQUERY               = 211
	ClickHouseParserQUOTE_DOUBLE        = 212
	ClickHouseParserQUOTE_SINGLE        = 213
	ClickHouseParserRBRACE              = 214
	ClickHouseParserRBRACKET            = 215
	ClickHouseParserRPAREN              = 216
	ClickHouseParserSEMICOLON           = 217
	ClickHouseParserSLASH               = 218
	ClickHouseParserUNDERSCORE          = 219
	ClickHouseParserMULTI_LINE_COMMENT  = 220
	ClickHouseParserSINGLE_LINE_COMMENT = 221
	ClickHouseParserWHITESPACE          = 222
)

// ClickHouseParser rules.
const (
	ClickHouseParserRULE_queryStmt                  = 0
	ClickHouseParserRULE_query                      = 1
	ClickHouseParserRULE_alterStmt                  = 2
	ClickHouseParserRULE_alterTableClause           = 3
	ClickHouseParserRULE_assignmentExprList         = 4
	ClickHouseParserRULE_assignmentExpr             = 5
	ClickHouseParserRULE_tableColumnPropertyType    = 6
	ClickHouseParserRULE_partitionClause            = 7
	ClickHouseParserRULE_attachStmt                 = 8
	ClickHouseParserRULE_checkStmt                  = 9
	ClickHouseParserRULE_createStmt                 = 10
	ClickHouseParserRULE_dictionarySchemaClause     = 11
	ClickHouseParserRULE_dictionaryAttrDfnt         = 12
	ClickHouseParserRULE_dictionaryEngineClause     = 13
	ClickHouseParserRULE_dictionaryPrimaryKeyClause = 14
	ClickHouseParserRULE_dictionaryArgExpr          = 15
	ClickHouseParserRULE_sourceClause               = 16
	ClickHouseParserRULE_lifetimeClause             = 17
	ClickHouseParserRULE_layoutClause               = 18
	ClickHouseParserRULE_rangeClause                = 19
	ClickHouseParserRULE_dictionarySettingsClause   = 20
	ClickHouseParserRULE_clusterClause              = 21
	ClickHouseParserRULE_uuidClause                 = 22
	ClickHouseParserRULE_destinationClause          = 23
	ClickHouseParserRULE_subqueryClause             = 24
	ClickHouseParserRULE_tableSchemaClause          = 25
	ClickHouseParserRULE_engineClause               = 26
	ClickHouseParserRULE_partitionByClause          = 27
	ClickHouseParserRULE_primaryKeyClause           = 28
	ClickHouseParserRULE_sampleByClause             = 29
	ClickHouseParserRULE_ttlClause                  = 30
	ClickHouseParserRULE_engineExpr                 = 31
	ClickHouseParserRULE_tableElementExpr           = 32
	ClickHouseParserRULE_tableColumnDfnt            = 33
	ClickHouseParserRULE_tableColumnPropertyExpr    = 34
	ClickHouseParserRULE_tableIndexDfnt             = 35
	ClickHouseParserRULE_tableProjectionDfnt        = 36
	ClickHouseParserRULE_codecExpr                  = 37
	ClickHouseParserRULE_codecArgExpr               = 38
	ClickHouseParserRULE_ttlExpr                    = 39
	ClickHouseParserRULE_describeStmt               = 40
	ClickHouseParserRULE_dropStmt                   = 41
	ClickHouseParserRULE_existsStmt                 = 42
	ClickHouseParserRULE_explainStmt                = 43
	ClickHouseParserRULE_insertStmt                 = 44
	ClickHouseParserRULE_columnsClause              = 45
	ClickHouseParserRULE_dataClause                 = 46
	ClickHouseParserRULE_killStmt                   = 47
	ClickHouseParserRULE_optimizeStmt               = 48
	ClickHouseParserRULE_renameStmt                 = 49
	ClickHouseParserRULE_projectionSelectStmt       = 50
	ClickHouseParserRULE_selectUnionStmt            = 51
	ClickHouseParserRULE_selectStmtWithParens       = 52
	ClickHouseParserRULE_selectStmt                 = 53
	ClickHouseParserRULE_withClause                 = 54
	ClickHouseParserRULE_topClause                  = 55
	ClickHouseParserRULE_fromClause                 = 56
	ClickHouseParserRULE_arrayJoinClause            = 57
	ClickHouseParserRULE_prewhereClause             = 58
	ClickHouseParserRULE_whereClause                = 59
	ClickHouseParserRULE_groupByClause              = 60
	ClickHouseParserRULE_havingClause               = 61
	ClickHouseParserRULE_orderByClause              = 62
	ClickHouseParserRULE_projectionOrderByClause    = 63
	ClickHouseParserRULE_limitByClause              = 64
	ClickHouseParserRULE_limitClause                = 65
	ClickHouseParserRULE_settingsClause             = 66
	ClickHouseParserRULE_joinExpr                   = 67
	ClickHouseParserRULE_joinOp                     = 68
	ClickHouseParserRULE_joinOpCross                = 69
	ClickHouseParserRULE_joinConstraintClause       = 70
	ClickHouseParserRULE_sampleClause               = 71
	ClickHouseParserRULE_limitExpr                  = 72
	ClickHouseParserRULE_orderExprList              = 73
	ClickHouseParserRULE_orderExpr                  = 74
	ClickHouseParserRULE_ratioExpr                  = 75
	ClickHouseParserRULE_settingExprList            = 76
	ClickHouseParserRULE_settingExpr                = 77
	ClickHouseParserRULE_setStmt                    = 78
	ClickHouseParserRULE_showStmt                   = 79
	ClickHouseParserRULE_systemStmt                 = 80
	ClickHouseParserRULE_truncateStmt               = 81
	ClickHouseParserRULE_useStmt                    = 82
	ClickHouseParserRULE_watchStmt                  = 83
	ClickHouseParserRULE_columnTypeExpr             = 84
	ClickHouseParserRULE_columnExprList             = 85
	ClickHouseParserRULE_columnsExpr                = 86
	ClickHouseParserRULE_columnExpr                 = 87
	ClickHouseParserRULE_columnArgList              = 88
	ClickHouseParserRULE_columnArgExpr              = 89
	ClickHouseParserRULE_columnLambdaExpr           = 90
	ClickHouseParserRULE_columnIdentifier           = 91
	ClickHouseParserRULE_nestedIdentifier           = 92
	ClickHouseParserRULE_tableExpr                  = 93
	ClickHouseParserRULE_tableFunctionExpr          = 94
	ClickHouseParserRULE_tableIdentifier            = 95
	ClickHouseParserRULE_tableArgList               = 96
	ClickHouseParserRULE_tableArgExpr               = 97
	ClickHouseParserRULE_databaseIdentifier         = 98
	ClickHouseParserRULE_floatingLiteral            = 99
	ClickHouseParserRULE_numberLiteral              = 100
	ClickHouseParserRULE_literal                    = 101
	ClickHouseParserRULE_interval                   = 102
	ClickHouseParserRULE_keyword                    = 103
	ClickHouseParserRULE_keywordForAlias            = 104
	ClickHouseParserRULE_alias                      = 105
	ClickHouseParserRULE_identifier                 = 106
	ClickHouseParserRULE_identifierOrNull           = 107
	ClickHouseParserRULE_enumValue                  = 108
)

// IQueryStmtContext is an interface to support dynamic dispatch.
type IQueryStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryStmtContext differentiates from other interfaces.
	IsQueryStmtContext()
}

type QueryStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryStmtContext() *QueryStmtContext {
	var p = new(QueryStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_queryStmt
	return p
}

func (*QueryStmtContext) IsQueryStmtContext() {}

func NewQueryStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStmtContext {
	var p = new(QueryStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_queryStmt

	return p
}

func (s *QueryStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStmtContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QueryStmtContext) INTO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTO, 0)
}

func (s *QueryStmtContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOUTFILE, 0)
}

func (s *QueryStmtContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *QueryStmtContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFORMAT, 0)
}

func (s *QueryStmtContext) IdentifierOrNull() IIdentifierOrNullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierOrNullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrNullContext)
}

func (s *QueryStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSEMICOLON, 0)
}

func (s *QueryStmtContext) InsertStmt() IInsertStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsertStmtContext)
}

func (s *QueryStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterQueryStmt(s)
	}
}

func (s *QueryStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitQueryStmt(s)
	}
}

func (p *ClickHouseParser) QueryStmt() (localctx IQueryStmtContext) {
	localctx = NewQueryStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ClickHouseParserRULE_queryStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(232)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserALTER, ClickHouseParserATTACH, ClickHouseParserCHECK, ClickHouseParserCREATE, ClickHouseParserDESC, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDROP, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserKILL, ClickHouseParserOPTIMIZE, ClickHouseParserRENAME, ClickHouseParserSELECT, ClickHouseParserSET, ClickHouseParserSHOW, ClickHouseParserSYSTEM, ClickHouseParserTRUNCATE, ClickHouseParserUSE, ClickHouseParserWATCH, ClickHouseParserWITH, ClickHouseParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(218)
			p.Query()
		}
		p.SetState(222)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserINTO {
			{
				p.SetState(219)
				p.Match(ClickHouseParserINTO)
			}
			{
				p.SetState(220)
				p.Match(ClickHouseParserOUTFILE)
			}
			{
				p.SetState(221)
				p.Match(ClickHouseParserSTRING_LITERAL)
			}

		}
		p.SetState(226)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFORMAT {
			{
				p.SetState(224)
				p.Match(ClickHouseParserFORMAT)
			}
			{
				p.SetState(225)
				p.IdentifierOrNull()
			}

		}
		p.SetState(229)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserSEMICOLON {
			{
				p.SetState(228)
				p.Match(ClickHouseParserSEMICOLON)
			}

		}

	case ClickHouseParserINSERT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(231)
			p.InsertStmt()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) AlterStmt() IAlterStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterStmtContext)
}

func (s *QueryContext) AttachStmt() IAttachStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttachStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttachStmtContext)
}

func (s *QueryContext) CheckStmt() ICheckStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheckStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheckStmtContext)
}

func (s *QueryContext) CreateStmt() ICreateStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateStmtContext)
}

func (s *QueryContext) DescribeStmt() IDescribeStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDescribeStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDescribeStmtContext)
}

func (s *QueryContext) DropStmt() IDropStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropStmtContext)
}

func (s *QueryContext) ExistsStmt() IExistsStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExistsStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExistsStmtContext)
}

func (s *QueryContext) ExplainStmt() IExplainStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplainStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplainStmtContext)
}

func (s *QueryContext) KillStmt() IKillStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKillStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKillStmtContext)
}

func (s *QueryContext) OptimizeStmt() IOptimizeStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptimizeStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptimizeStmtContext)
}

func (s *QueryContext) RenameStmt() IRenameStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRenameStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRenameStmtContext)
}

func (s *QueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectUnionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *QueryContext) SetStmt() ISetStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetStmtContext)
}

func (s *QueryContext) ShowStmt() IShowStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShowStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShowStmtContext)
}

func (s *QueryContext) SystemStmt() ISystemStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystemStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystemStmtContext)
}

func (s *QueryContext) TruncateStmt() ITruncateStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITruncateStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITruncateStmtContext)
}

func (s *QueryContext) UseStmt() IUseStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseStmtContext)
}

func (s *QueryContext) WatchStmt() IWatchStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWatchStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWatchStmtContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *ClickHouseParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ClickHouseParserRULE_query)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(252)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(234)
			p.AlterStmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(235)
			p.AttachStmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(236)
			p.CheckStmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(237)
			p.CreateStmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(238)
			p.DescribeStmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(239)
			p.DropStmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(240)
			p.ExistsStmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(241)
			p.ExplainStmt()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(242)
			p.KillStmt()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(243)
			p.OptimizeStmt()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(244)
			p.RenameStmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(245)
			p.SelectUnionStmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(246)
			p.SetStmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(247)
			p.ShowStmt()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(248)
			p.SystemStmt()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(249)
			p.TruncateStmt()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(250)
			p.UseStmt()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(251)
			p.WatchStmt()
		}

	}

	return localctx
}

// IAlterStmtContext is an interface to support dynamic dispatch.
type IAlterStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterStmtContext differentiates from other interfaces.
	IsAlterStmtContext()
}

type AlterStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStmtContext() *AlterStmtContext {
	var p = new(AlterStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alterStmt
	return p
}

func (*AlterStmtContext) IsAlterStmtContext() {}

func NewAlterStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStmtContext {
	var p = new(AlterStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_alterStmt

	return p
}

func (s *AlterStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStmtContext) CopyFrom(ctx *AlterStmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AlterStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterTableStmtContext struct {
	*AlterStmtContext
}

func NewAlterTableStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableStmtContext {
	var p = new(AlterTableStmtContext)

	p.AlterStmtContext = NewEmptyAlterStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterStmtContext))

	return p
}

func (s *AlterTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableStmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALTER, 0)
}

func (s *AlterTableStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *AlterTableStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *AlterTableStmtContext) AllAlterTableClause() []IAlterTableClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterTableClauseContext)(nil)).Elem())
	var tst = make([]IAlterTableClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterTableClauseContext)
		}
	}

	return tst
}

func (s *AlterTableStmtContext) AlterTableClause(i int) IAlterTableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterTableClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterTableClauseContext)
}

func (s *AlterTableStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *AlterTableStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *AlterTableStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *AlterTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableStmt(s)
	}
}

func (s *AlterTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableStmt(s)
	}
}

func (p *ClickHouseParser) AlterStmt() (localctx IAlterStmtContext) {
	localctx = NewAlterStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ClickHouseParserRULE_alterStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewAlterTableStmtContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(254)
		p.Match(ClickHouseParserALTER)
	}
	{
		p.SetState(255)
		p.Match(ClickHouseParserTABLE)
	}
	{
		p.SetState(256)
		p.TableIdentifier()
	}
	p.SetState(258)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(257)
			p.ClusterClause()
		}

	}
	{
		p.SetState(260)
		p.AlterTableClause()
	}
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(261)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(262)
			p.AlterTableClause()
		}

		p.SetState(267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterTableClauseContext is an interface to support dynamic dispatch.
type IAlterTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterTableClauseContext differentiates from other interfaces.
	IsAlterTableClauseContext()
}

type AlterTableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableClauseContext() *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alterTableClause
	return p
}

func (*AlterTableClauseContext) IsAlterTableClauseContext() {}

func NewAlterTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_alterTableClause

	return p
}

func (s *AlterTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableClauseContext) CopyFrom(ctx *AlterTableClauseContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AlterTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterTableClauseReplaceContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseReplaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseReplaceContext {
	var p = new(AlterTableClauseReplaceContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLACE, 0)
}

func (s *AlterTableClauseReplaceContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseReplaceContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *AlterTableClauseReplaceContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *AlterTableClauseReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseReplace(s)
	}
}

func (s *AlterTableClauseReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseReplace(s)
	}
}

type AlterTableClauseModifyOrderByContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseModifyOrderByContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyOrderByContext {
	var p = new(AlterTableClauseModifyOrderByContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyOrderByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyOrderByContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyOrderByContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserORDER, 0)
}

func (s *AlterTableClauseModifyOrderByContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *AlterTableClauseModifyOrderByContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *AlterTableClauseModifyOrderByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModifyOrderBy(s)
	}
}

func (s *AlterTableClauseModifyOrderByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModifyOrderBy(s)
	}
}

type AlterTableClauseUpdateContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseUpdateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseUpdateContext {
	var p = new(AlterTableClauseUpdateContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseUpdateContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUPDATE, 0)
}

func (s *AlterTableClauseUpdateContext) AssignmentExprList() IAssignmentExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprListContext)
}

func (s *AlterTableClauseUpdateContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *AlterTableClauseUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseUpdate(s)
	}
}

func (s *AlterTableClauseUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseUpdate(s)
	}
}

type AlterTableClauseClearProjectionContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseClearProjectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseClearProjectionContext {
	var p = new(AlterTableClauseClearProjectionContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseClearProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseClearProjectionContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLEAR, 0)
}

func (s *AlterTableClauseClearProjectionContext) PROJECTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROJECTION, 0)
}

func (s *AlterTableClauseClearProjectionContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseClearProjectionContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseClearProjectionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseClearProjectionContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *AlterTableClauseClearProjectionContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseClearProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseClearProjection(s)
	}
}

func (s *AlterTableClauseClearProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseClearProjection(s)
	}
}

type AlterTableClauseModifyRemoveContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseModifyRemoveContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyRemoveContext {
	var p = new(AlterTableClauseModifyRemoveContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyRemoveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyRemoveContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyRemoveContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseModifyRemoveContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseModifyRemoveContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREMOVE, 0)
}

func (s *AlterTableClauseModifyRemoveContext) TableColumnPropertyType() ITableColumnPropertyTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableColumnPropertyTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableColumnPropertyTypeContext)
}

func (s *AlterTableClauseModifyRemoveContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseModifyRemoveContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseModifyRemoveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModifyRemove(s)
	}
}

func (s *AlterTableClauseModifyRemoveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModifyRemove(s)
	}
}

type AlterTableClauseDeleteContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDeleteContext {
	var p = new(AlterTableClauseDeleteContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDELETE, 0)
}

func (s *AlterTableClauseDeleteContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHERE, 0)
}

func (s *AlterTableClauseDeleteContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *AlterTableClauseDeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDelete(s)
	}
}

func (s *AlterTableClauseDeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDelete(s)
	}
}

type AlterTableClauseCommentContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseCommentContext {
	var p = new(AlterTableClauseCommentContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMENT, 0)
}

func (s *AlterTableClauseCommentContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseCommentContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *AlterTableClauseCommentContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseCommentContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseComment(s)
	}
}

func (s *AlterTableClauseCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseComment(s)
	}
}

type AlterTableClauseDropColumnContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseDropColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDropColumnContext {
	var p = new(AlterTableClauseDropColumnContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDropColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDropColumnContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *AlterTableClauseDropColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseDropColumnContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseDropColumnContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseDropColumnContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseDropColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDropColumn(s)
	}
}

func (s *AlterTableClauseDropColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDropColumn(s)
	}
}

type AlterTableClauseDetachContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseDetachContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDetachContext {
	var p = new(AlterTableClauseDetachContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDetachContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDetachContext) DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDETACH, 0)
}

func (s *AlterTableClauseDetachContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseDetachContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDetach(s)
	}
}

func (s *AlterTableClauseDetachContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDetach(s)
	}
}

type AlterTableClauseAddIndexContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseAddIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseAddIndexContext {
	var p = new(AlterTableClauseAddIndexContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseAddIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseAddIndexContext) ADD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserADD, 0)
}

func (s *AlterTableClauseAddIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *AlterTableClauseAddIndexContext) TableIndexDfnt() ITableIndexDfntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIndexDfntContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIndexDfntContext)
}

func (s *AlterTableClauseAddIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseAddIndexContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *AlterTableClauseAddIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseAddIndexContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAFTER, 0)
}

func (s *AlterTableClauseAddIndexContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseAddIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseAddIndex(s)
	}
}

func (s *AlterTableClauseAddIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseAddIndex(s)
	}
}

type AlterTableClauseDropPartitionContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseDropPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDropPartitionContext {
	var p = new(AlterTableClauseDropPartitionContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDropPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDropPartitionContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *AlterTableClauseDropPartitionContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseDropPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDropPartition(s)
	}
}

func (s *AlterTableClauseDropPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDropPartition(s)
	}
}

type AlterTableClauseMaterializeIndexContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseMaterializeIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseMaterializeIndexContext {
	var p = new(AlterTableClauseMaterializeIndexContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseMaterializeIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseMaterializeIndexContext) MATERIALIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZE, 0)
}

func (s *AlterTableClauseMaterializeIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *AlterTableClauseMaterializeIndexContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseMaterializeIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseMaterializeIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseMaterializeIndexContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *AlterTableClauseMaterializeIndexContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseMaterializeIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseMaterializeIndex(s)
	}
}

func (s *AlterTableClauseMaterializeIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseMaterializeIndex(s)
	}
}

type AlterTableClauseMaterializeProjectionContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseMaterializeProjectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseMaterializeProjectionContext {
	var p = new(AlterTableClauseMaterializeProjectionContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseMaterializeProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseMaterializeProjectionContext) MATERIALIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZE, 0)
}

func (s *AlterTableClauseMaterializeProjectionContext) PROJECTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROJECTION, 0)
}

func (s *AlterTableClauseMaterializeProjectionContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseMaterializeProjectionContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseMaterializeProjectionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseMaterializeProjectionContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *AlterTableClauseMaterializeProjectionContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseMaterializeProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseMaterializeProjection(s)
	}
}

func (s *AlterTableClauseMaterializeProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseMaterializeProjection(s)
	}
}

type AlterTableClauseMovePartitionContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseMovePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseMovePartitionContext {
	var p = new(AlterTableClauseMovePartitionContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseMovePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseMovePartitionContext) MOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMOVE, 0)
}

func (s *AlterTableClauseMovePartitionContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseMovePartitionContext) TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, 0)
}

func (s *AlterTableClauseMovePartitionContext) DISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISK, 0)
}

func (s *AlterTableClauseMovePartitionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *AlterTableClauseMovePartitionContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVOLUME, 0)
}

func (s *AlterTableClauseMovePartitionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *AlterTableClauseMovePartitionContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *AlterTableClauseMovePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseMovePartition(s)
	}
}

func (s *AlterTableClauseMovePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseMovePartition(s)
	}
}

type AlterTableClauseRenameContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseRenameContext {
	var p = new(AlterTableClauseRenameContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRENAME, 0)
}

func (s *AlterTableClauseRenameContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseRenameContext) AllNestedIdentifier() []INestedIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem())
	var tst = make([]INestedIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INestedIdentifierContext)
		}
	}

	return tst
}

func (s *AlterTableClauseRenameContext) NestedIdentifier(i int) INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseRenameContext) TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, 0)
}

func (s *AlterTableClauseRenameContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseRenameContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseRename(s)
	}
}

func (s *AlterTableClauseRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseRename(s)
	}
}

type AlterTableClauseFreezePartitionContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseFreezePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseFreezePartitionContext {
	var p = new(AlterTableClauseFreezePartitionContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseFreezePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseFreezePartitionContext) FREEZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFREEZE, 0)
}

func (s *AlterTableClauseFreezePartitionContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseFreezePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseFreezePartition(s)
	}
}

func (s *AlterTableClauseFreezePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseFreezePartition(s)
	}
}

type AlterTableClauseClearColumnContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseClearColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseClearColumnContext {
	var p = new(AlterTableClauseClearColumnContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseClearColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseClearColumnContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLEAR, 0)
}

func (s *AlterTableClauseClearColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseClearColumnContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseClearColumnContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseClearColumnContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseClearColumnContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *AlterTableClauseClearColumnContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseClearColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseClearColumn(s)
	}
}

func (s *AlterTableClauseClearColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseClearColumn(s)
	}
}

type AlterTableClauseModifyContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseModifyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyContext {
	var p = new(AlterTableClauseModifyContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseModifyContext) TableColumnDfnt() ITableColumnDfntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableColumnDfntContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableColumnDfntContext)
}

func (s *AlterTableClauseModifyContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseModifyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseModifyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModify(s)
	}
}

func (s *AlterTableClauseModifyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModify(s)
	}
}

type AlterTableClauseClearIndexContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseClearIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseClearIndexContext {
	var p = new(AlterTableClauseClearIndexContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseClearIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseClearIndexContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLEAR, 0)
}

func (s *AlterTableClauseClearIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *AlterTableClauseClearIndexContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseClearIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseClearIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseClearIndexContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *AlterTableClauseClearIndexContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseClearIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseClearIndex(s)
	}
}

func (s *AlterTableClauseClearIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseClearIndex(s)
	}
}

type AlterTableClauseRemoveTTLContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseRemoveTTLContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseRemoveTTLContext {
	var p = new(AlterTableClauseRemoveTTLContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseRemoveTTLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseRemoveTTLContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREMOVE, 0)
}

func (s *AlterTableClauseRemoveTTLContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *AlterTableClauseRemoveTTLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseRemoveTTL(s)
	}
}

func (s *AlterTableClauseRemoveTTLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseRemoveTTL(s)
	}
}

type AlterTableClauseModifyCodecContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseModifyCodecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyCodecContext {
	var p = new(AlterTableClauseModifyCodecContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyCodecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyCodecContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyCodecContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseModifyCodecContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseModifyCodecContext) CodecExpr() ICodecExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodecExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodecExprContext)
}

func (s *AlterTableClauseModifyCodecContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseModifyCodecContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseModifyCodecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModifyCodec(s)
	}
}

func (s *AlterTableClauseModifyCodecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModifyCodec(s)
	}
}

type AlterTableClauseAttachContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseAttachContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseAttachContext {
	var p = new(AlterTableClauseAttachContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseAttachContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseAttachContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *AlterTableClauseAttachContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseAttachContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *AlterTableClauseAttachContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *AlterTableClauseAttachContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseAttach(s)
	}
}

func (s *AlterTableClauseAttachContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseAttach(s)
	}
}

type AlterTableClauseDropProjectionContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseDropProjectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDropProjectionContext {
	var p = new(AlterTableClauseDropProjectionContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDropProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDropProjectionContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *AlterTableClauseDropProjectionContext) PROJECTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROJECTION, 0)
}

func (s *AlterTableClauseDropProjectionContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseDropProjectionContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseDropProjectionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseDropProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDropProjection(s)
	}
}

func (s *AlterTableClauseDropProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDropProjection(s)
	}
}

type AlterTableClauseDropIndexContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDropIndexContext {
	var p = new(AlterTableClauseDropIndexContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *AlterTableClauseDropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *AlterTableClauseDropIndexContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseDropIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseDropIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseDropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDropIndex(s)
	}
}

func (s *AlterTableClauseDropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDropIndex(s)
	}
}

type AlterTableClauseModifyCommentContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseModifyCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyCommentContext {
	var p = new(AlterTableClauseModifyCommentContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyCommentContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyCommentContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseModifyCommentContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseModifyCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMENT, 0)
}

func (s *AlterTableClauseModifyCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *AlterTableClauseModifyCommentContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseModifyCommentContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseModifyCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModifyComment(s)
	}
}

func (s *AlterTableClauseModifyCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModifyComment(s)
	}
}

type AlterTableClauseModifyTTLContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseModifyTTLContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyTTLContext {
	var p = new(AlterTableClauseModifyTTLContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyTTLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyTTLContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyTTLContext) TtlClause() ITtlClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITtlClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITtlClauseContext)
}

func (s *AlterTableClauseModifyTTLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModifyTTL(s)
	}
}

func (s *AlterTableClauseModifyTTLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModifyTTL(s)
	}
}

type AlterTableClauseAddProjectionContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseAddProjectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseAddProjectionContext {
	var p = new(AlterTableClauseAddProjectionContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseAddProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseAddProjectionContext) ADD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserADD, 0)
}

func (s *AlterTableClauseAddProjectionContext) PROJECTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROJECTION, 0)
}

func (s *AlterTableClauseAddProjectionContext) TableProjectionDfnt() ITableProjectionDfntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableProjectionDfntContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableProjectionDfntContext)
}

func (s *AlterTableClauseAddProjectionContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseAddProjectionContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *AlterTableClauseAddProjectionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseAddProjectionContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAFTER, 0)
}

func (s *AlterTableClauseAddProjectionContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseAddProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseAddProjection(s)
	}
}

func (s *AlterTableClauseAddProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseAddProjection(s)
	}
}

type AlterTableClauseAddColumnContext struct {
	*AlterTableClauseContext
}

func NewAlterTableClauseAddColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseAddColumnContext {
	var p = new(AlterTableClauseAddColumnContext)

	p.AlterTableClauseContext = NewEmptyAlterTableClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseAddColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseAddColumnContext) ADD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserADD, 0)
}

func (s *AlterTableClauseAddColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseAddColumnContext) TableColumnDfnt() ITableColumnDfntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableColumnDfntContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableColumnDfntContext)
}

func (s *AlterTableClauseAddColumnContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseAddColumnContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *AlterTableClauseAddColumnContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseAddColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAFTER, 0)
}

func (s *AlterTableClauseAddColumnContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseAddColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseAddColumn(s)
	}
}

func (s *AlterTableClauseAddColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseAddColumn(s)
	}
}

func (p *ClickHouseParser) AlterTableClause() (localctx IAlterTableClauseContext) {
	localctx = NewAlterTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ClickHouseParserRULE_alterTableClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterTableClauseAddColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(268)
			p.Match(ClickHouseParserADD)
		}
		{
			p.SetState(269)
			p.Match(ClickHouseParserCOLUMN)
		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(270)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(271)
				p.Match(ClickHouseParserNOT)
			}
			{
				p.SetState(272)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(275)
			p.TableColumnDfnt()
		}
		p.SetState(278)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserAFTER {
			{
				p.SetState(276)
				p.Match(ClickHouseParserAFTER)
			}
			{
				p.SetState(277)
				p.NestedIdentifier()
			}

		}

	case 2:
		localctx = NewAlterTableClauseAddIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(280)
			p.Match(ClickHouseParserADD)
		}
		{
			p.SetState(281)
			p.Match(ClickHouseParserINDEX)
		}
		p.SetState(285)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(282)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(283)
				p.Match(ClickHouseParserNOT)
			}
			{
				p.SetState(284)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(287)
			p.TableIndexDfnt()
		}
		p.SetState(290)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserAFTER {
			{
				p.SetState(288)
				p.Match(ClickHouseParserAFTER)
			}
			{
				p.SetState(289)
				p.NestedIdentifier()
			}

		}

	case 3:
		localctx = NewAlterTableClauseAddProjectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(292)
			p.Match(ClickHouseParserADD)
		}
		{
			p.SetState(293)
			p.Match(ClickHouseParserPROJECTION)
		}
		p.SetState(297)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(294)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(295)
				p.Match(ClickHouseParserNOT)
			}
			{
				p.SetState(296)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(299)
			p.TableProjectionDfnt()
		}
		p.SetState(302)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserAFTER {
			{
				p.SetState(300)
				p.Match(ClickHouseParserAFTER)
			}
			{
				p.SetState(301)
				p.NestedIdentifier()
			}

		}

	case 4:
		localctx = NewAlterTableClauseAttachContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(304)
			p.Match(ClickHouseParserATTACH)
		}
		{
			p.SetState(305)
			p.PartitionClause()
		}
		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFROM {
			{
				p.SetState(306)
				p.Match(ClickHouseParserFROM)
			}
			{
				p.SetState(307)
				p.TableIdentifier()
			}

		}

	case 5:
		localctx = NewAlterTableClauseClearColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(310)
			p.Match(ClickHouseParserCLEAR)
		}
		{
			p.SetState(311)
			p.Match(ClickHouseParserCOLUMN)
		}
		p.SetState(314)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(312)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(313)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(316)
			p.NestedIdentifier()
		}
		p.SetState(319)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserIN {
			{
				p.SetState(317)
				p.Match(ClickHouseParserIN)
			}
			{
				p.SetState(318)
				p.PartitionClause()
			}

		}

	case 6:
		localctx = NewAlterTableClauseClearIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(321)
			p.Match(ClickHouseParserCLEAR)
		}
		{
			p.SetState(322)
			p.Match(ClickHouseParserINDEX)
		}
		p.SetState(325)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(323)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(324)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(327)
			p.NestedIdentifier()
		}
		p.SetState(330)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserIN {
			{
				p.SetState(328)
				p.Match(ClickHouseParserIN)
			}
			{
				p.SetState(329)
				p.PartitionClause()
			}

		}

	case 7:
		localctx = NewAlterTableClauseClearProjectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(332)
			p.Match(ClickHouseParserCLEAR)
		}
		{
			p.SetState(333)
			p.Match(ClickHouseParserPROJECTION)
		}
		p.SetState(336)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(334)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(335)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(338)
			p.NestedIdentifier()
		}
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserIN {
			{
				p.SetState(339)
				p.Match(ClickHouseParserIN)
			}
			{
				p.SetState(340)
				p.PartitionClause()
			}

		}

	case 8:
		localctx = NewAlterTableClauseCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(343)
			p.Match(ClickHouseParserCOMMENT)
		}
		{
			p.SetState(344)
			p.Match(ClickHouseParserCOLUMN)
		}
		p.SetState(347)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(345)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(346)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(349)
			p.NestedIdentifier()
		}
		{
			p.SetState(350)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	case 9:
		localctx = NewAlterTableClauseDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(352)
			p.Match(ClickHouseParserDELETE)
		}
		{
			p.SetState(353)
			p.Match(ClickHouseParserWHERE)
		}
		{
			p.SetState(354)
			p.columnExpr(0)
		}

	case 10:
		localctx = NewAlterTableClauseDetachContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(355)
			p.Match(ClickHouseParserDETACH)
		}
		{
			p.SetState(356)
			p.PartitionClause()
		}

	case 11:
		localctx = NewAlterTableClauseDropColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(357)
			p.Match(ClickHouseParserDROP)
		}
		{
			p.SetState(358)
			p.Match(ClickHouseParserCOLUMN)
		}
		p.SetState(361)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(359)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(360)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(363)
			p.NestedIdentifier()
		}

	case 12:
		localctx = NewAlterTableClauseDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(364)
			p.Match(ClickHouseParserDROP)
		}
		{
			p.SetState(365)
			p.Match(ClickHouseParserINDEX)
		}
		p.SetState(368)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(366)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(367)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(370)
			p.NestedIdentifier()
		}

	case 13:
		localctx = NewAlterTableClauseDropProjectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(371)
			p.Match(ClickHouseParserDROP)
		}
		{
			p.SetState(372)
			p.Match(ClickHouseParserPROJECTION)
		}
		p.SetState(375)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(373)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(374)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(377)
			p.NestedIdentifier()
		}

	case 14:
		localctx = NewAlterTableClauseDropPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(378)
			p.Match(ClickHouseParserDROP)
		}
		{
			p.SetState(379)
			p.PartitionClause()
		}

	case 15:
		localctx = NewAlterTableClauseFreezePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(380)
			p.Match(ClickHouseParserFREEZE)
		}
		p.SetState(382)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserPARTITION {
			{
				p.SetState(381)
				p.PartitionClause()
			}

		}

	case 16:
		localctx = NewAlterTableClauseMaterializeIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(384)
			p.Match(ClickHouseParserMATERIALIZE)
		}
		{
			p.SetState(385)
			p.Match(ClickHouseParserINDEX)
		}
		p.SetState(388)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(386)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(387)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(390)
			p.NestedIdentifier()
		}
		p.SetState(393)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserIN {
			{
				p.SetState(391)
				p.Match(ClickHouseParserIN)
			}
			{
				p.SetState(392)
				p.PartitionClause()
			}

		}

	case 17:
		localctx = NewAlterTableClauseMaterializeProjectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(395)
			p.Match(ClickHouseParserMATERIALIZE)
		}
		{
			p.SetState(396)
			p.Match(ClickHouseParserPROJECTION)
		}
		p.SetState(399)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(397)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(398)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(401)
			p.NestedIdentifier()
		}
		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserIN {
			{
				p.SetState(402)
				p.Match(ClickHouseParserIN)
			}
			{
				p.SetState(403)
				p.PartitionClause()
			}

		}

	case 18:
		localctx = NewAlterTableClauseModifyCodecContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(406)
			p.Match(ClickHouseParserMODIFY)
		}
		{
			p.SetState(407)
			p.Match(ClickHouseParserCOLUMN)
		}
		p.SetState(410)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(408)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(409)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(412)
			p.NestedIdentifier()
		}
		{
			p.SetState(413)
			p.CodecExpr()
		}

	case 19:
		localctx = NewAlterTableClauseModifyCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(415)
			p.Match(ClickHouseParserMODIFY)
		}
		{
			p.SetState(416)
			p.Match(ClickHouseParserCOLUMN)
		}
		p.SetState(419)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(417)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(418)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(421)
			p.NestedIdentifier()
		}
		{
			p.SetState(422)
			p.Match(ClickHouseParserCOMMENT)
		}
		{
			p.SetState(423)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	case 20:
		localctx = NewAlterTableClauseModifyRemoveContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(425)
			p.Match(ClickHouseParserMODIFY)
		}
		{
			p.SetState(426)
			p.Match(ClickHouseParserCOLUMN)
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(427)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(428)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(431)
			p.NestedIdentifier()
		}
		{
			p.SetState(432)
			p.Match(ClickHouseParserREMOVE)
		}
		{
			p.SetState(433)
			p.TableColumnPropertyType()
		}

	case 21:
		localctx = NewAlterTableClauseModifyContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(435)
			p.Match(ClickHouseParserMODIFY)
		}
		{
			p.SetState(436)
			p.Match(ClickHouseParserCOLUMN)
		}
		p.SetState(439)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(437)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(438)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(441)
			p.TableColumnDfnt()
		}

	case 22:
		localctx = NewAlterTableClauseModifyOrderByContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(442)
			p.Match(ClickHouseParserMODIFY)
		}
		{
			p.SetState(443)
			p.Match(ClickHouseParserORDER)
		}
		{
			p.SetState(444)
			p.Match(ClickHouseParserBY)
		}
		{
			p.SetState(445)
			p.columnExpr(0)
		}

	case 23:
		localctx = NewAlterTableClauseModifyTTLContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(446)
			p.Match(ClickHouseParserMODIFY)
		}
		{
			p.SetState(447)
			p.TtlClause()
		}

	case 24:
		localctx = NewAlterTableClauseMovePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(448)
			p.Match(ClickHouseParserMOVE)
		}
		{
			p.SetState(449)
			p.PartitionClause()
		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(450)
				p.Match(ClickHouseParserTO)
			}
			{
				p.SetState(451)
				p.Match(ClickHouseParserDISK)
			}
			{
				p.SetState(452)
				p.Match(ClickHouseParserSTRING_LITERAL)
			}

		case 2:
			{
				p.SetState(453)
				p.Match(ClickHouseParserTO)
			}
			{
				p.SetState(454)
				p.Match(ClickHouseParserVOLUME)
			}
			{
				p.SetState(455)
				p.Match(ClickHouseParserSTRING_LITERAL)
			}

		case 3:
			{
				p.SetState(456)
				p.Match(ClickHouseParserTO)
			}
			{
				p.SetState(457)
				p.Match(ClickHouseParserTABLE)
			}
			{
				p.SetState(458)
				p.TableIdentifier()
			}

		}

	case 25:
		localctx = NewAlterTableClauseRemoveTTLContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(461)
			p.Match(ClickHouseParserREMOVE)
		}
		{
			p.SetState(462)
			p.Match(ClickHouseParserTTL)
		}

	case 26:
		localctx = NewAlterTableClauseRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(463)
			p.Match(ClickHouseParserRENAME)
		}
		{
			p.SetState(464)
			p.Match(ClickHouseParserCOLUMN)
		}
		p.SetState(467)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(465)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(466)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(469)
			p.NestedIdentifier()
		}
		{
			p.SetState(470)
			p.Match(ClickHouseParserTO)
		}
		{
			p.SetState(471)
			p.NestedIdentifier()
		}

	case 27:
		localctx = NewAlterTableClauseReplaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(473)
			p.Match(ClickHouseParserREPLACE)
		}
		{
			p.SetState(474)
			p.PartitionClause()
		}
		{
			p.SetState(475)
			p.Match(ClickHouseParserFROM)
		}
		{
			p.SetState(476)
			p.TableIdentifier()
		}

	case 28:
		localctx = NewAlterTableClauseUpdateContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(478)
			p.Match(ClickHouseParserUPDATE)
		}
		{
			p.SetState(479)
			p.AssignmentExprList()
		}
		{
			p.SetState(480)
			p.WhereClause()
		}

	}

	return localctx
}

// IAssignmentExprListContext is an interface to support dynamic dispatch.
type IAssignmentExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentExprListContext differentiates from other interfaces.
	IsAssignmentExprListContext()
}

type AssignmentExprListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExprListContext() *AssignmentExprListContext {
	var p = new(AssignmentExprListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignmentExprList
	return p
}

func (*AssignmentExprListContext) IsAssignmentExprListContext() {}

func NewAssignmentExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExprListContext {
	var p = new(AssignmentExprListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_assignmentExprList

	return p
}

func (s *AssignmentExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExprListContext) AllAssignmentExpr() []IAssignmentExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentExprContext)(nil)).Elem())
	var tst = make([]IAssignmentExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentExprContext)
		}
	}

	return tst
}

func (s *AssignmentExprListContext) AssignmentExpr(i int) IAssignmentExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *AssignmentExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *AssignmentExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *AssignmentExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAssignmentExprList(s)
	}
}

func (s *AssignmentExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAssignmentExprList(s)
	}
}

func (p *ClickHouseParser) AssignmentExprList() (localctx IAssignmentExprListContext) {
	localctx = NewAssignmentExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ClickHouseParserRULE_assignmentExprList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(484)
		p.AssignmentExpr()
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(485)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(486)
			p.AssignmentExpr()
		}

		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignmentExprContext is an interface to support dynamic dispatch.
type IAssignmentExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentExprContext differentiates from other interfaces.
	IsAssignmentExprContext()
}

type AssignmentExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExprContext() *AssignmentExprContext {
	var p = new(AssignmentExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignmentExpr
	return p
}

func (*AssignmentExprContext) IsAssignmentExprContext() {}

func NewAssignmentExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExprContext {
	var p = new(AssignmentExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_assignmentExpr

	return p
}

func (s *AssignmentExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExprContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AssignmentExprContext) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_SINGLE, 0)
}

func (s *AssignmentExprContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *AssignmentExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAssignmentExpr(s)
	}
}

func (p *ClickHouseParser) AssignmentExpr() (localctx IAssignmentExprContext) {
	localctx = NewAssignmentExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ClickHouseParserRULE_assignmentExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(492)
		p.NestedIdentifier()
	}
	{
		p.SetState(493)
		p.Match(ClickHouseParserEQ_SINGLE)
	}
	{
		p.SetState(494)
		p.columnExpr(0)
	}

	return localctx
}

// ITableColumnPropertyTypeContext is an interface to support dynamic dispatch.
type ITableColumnPropertyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableColumnPropertyTypeContext differentiates from other interfaces.
	IsTableColumnPropertyTypeContext()
}

type TableColumnPropertyTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableColumnPropertyTypeContext() *TableColumnPropertyTypeContext {
	var p = new(TableColumnPropertyTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableColumnPropertyType
	return p
}

func (*TableColumnPropertyTypeContext) IsTableColumnPropertyTypeContext() {}

func NewTableColumnPropertyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableColumnPropertyTypeContext {
	var p = new(TableColumnPropertyTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableColumnPropertyType

	return p
}

func (s *TableColumnPropertyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TableColumnPropertyTypeContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALIAS, 0)
}

func (s *TableColumnPropertyTypeContext) CODEC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCODEC, 0)
}

func (s *TableColumnPropertyTypeContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMENT, 0)
}

func (s *TableColumnPropertyTypeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEFAULT, 0)
}

func (s *TableColumnPropertyTypeContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZED, 0)
}

func (s *TableColumnPropertyTypeContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *TableColumnPropertyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableColumnPropertyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableColumnPropertyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableColumnPropertyType(s)
	}
}

func (s *TableColumnPropertyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableColumnPropertyType(s)
	}
}

func (p *ClickHouseParser) TableColumnPropertyType() (localctx ITableColumnPropertyTypeContext) {
	localctx = NewTableColumnPropertyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ClickHouseParserRULE_tableColumnPropertyType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserALIAS)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOMMENT))) != 0) || _la == ClickHouseParserDEFAULT || _la == ClickHouseParserMATERIALIZED || _la == ClickHouseParserTTL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_partitionClause
	return p
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPARTITION, 0)
}

func (s *PartitionClauseContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *PartitionClauseContext) ID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserID, 0)
}

func (s *PartitionClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterPartitionClause(s)
	}
}

func (s *PartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitPartitionClause(s)
	}
}

func (p *ClickHouseParser) PartitionClause() (localctx IPartitionClauseContext) {
	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ClickHouseParserRULE_partitionClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(498)
			p.Match(ClickHouseParserPARTITION)
		}
		{
			p.SetState(499)
			p.columnExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(500)
			p.Match(ClickHouseParserPARTITION)
		}
		{
			p.SetState(501)
			p.Match(ClickHouseParserID)
		}
		{
			p.SetState(502)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	}

	return localctx
}

// IAttachStmtContext is an interface to support dynamic dispatch.
type IAttachStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttachStmtContext differentiates from other interfaces.
	IsAttachStmtContext()
}

type AttachStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttachStmtContext() *AttachStmtContext {
	var p = new(AttachStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_attachStmt
	return p
}

func (*AttachStmtContext) IsAttachStmtContext() {}

func NewAttachStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttachStmtContext {
	var p = new(AttachStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_attachStmt

	return p
}

func (s *AttachStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AttachStmtContext) CopyFrom(ctx *AttachStmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AttachStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttachStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AttachDictionaryStmtContext struct {
	*AttachStmtContext
}

func NewAttachDictionaryStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AttachDictionaryStmtContext {
	var p = new(AttachDictionaryStmtContext)

	p.AttachStmtContext = NewEmptyAttachStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AttachStmtContext))

	return p
}

func (s *AttachDictionaryStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttachDictionaryStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *AttachDictionaryStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *AttachDictionaryStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *AttachDictionaryStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *AttachDictionaryStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAttachDictionaryStmt(s)
	}
}

func (s *AttachDictionaryStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAttachDictionaryStmt(s)
	}
}

func (p *ClickHouseParser) AttachStmt() (localctx IAttachStmtContext) {
	localctx = NewAttachStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ClickHouseParserRULE_attachStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewAttachDictionaryStmtContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(505)
		p.Match(ClickHouseParserATTACH)
	}
	{
		p.SetState(506)
		p.Match(ClickHouseParserDICTIONARY)
	}
	{
		p.SetState(507)
		p.TableIdentifier()
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(508)
			p.ClusterClause()
		}

	}

	return localctx
}

// ICheckStmtContext is an interface to support dynamic dispatch.
type ICheckStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCheckStmtContext differentiates from other interfaces.
	IsCheckStmtContext()
}

type CheckStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckStmtContext() *CheckStmtContext {
	var p = new(CheckStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_checkStmt
	return p
}

func (*CheckStmtContext) IsCheckStmtContext() {}

func NewCheckStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckStmtContext {
	var p = new(CheckStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_checkStmt

	return p
}

func (s *CheckStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckStmtContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCHECK, 0)
}

func (s *CheckStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *CheckStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CheckStmtContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *CheckStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCheckStmt(s)
	}
}

func (s *CheckStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCheckStmt(s)
	}
}

func (p *ClickHouseParser) CheckStmt() (localctx ICheckStmtContext) {
	localctx = NewCheckStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ClickHouseParserRULE_checkStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(511)
		p.Match(ClickHouseParserCHECK)
	}
	{
		p.SetState(512)
		p.Match(ClickHouseParserTABLE)
	}
	{
		p.SetState(513)
		p.TableIdentifier()
	}
	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserPARTITION {
		{
			p.SetState(514)
			p.PartitionClause()
		}

	}

	return localctx
}

// ICreateStmtContext is an interface to support dynamic dispatch.
type ICreateStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateStmtContext differentiates from other interfaces.
	IsCreateStmtContext()
}

type CreateStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateStmtContext() *CreateStmtContext {
	var p = new(CreateStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_createStmt
	return p
}

func (*CreateStmtContext) IsCreateStmtContext() {}

func NewCreateStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateStmtContext {
	var p = new(CreateStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_createStmt

	return p
}

func (s *CreateStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateStmtContext) CopyFrom(ctx *CreateStmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CreateStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateViewStmtContext struct {
	*CreateStmtContext
}

func NewCreateViewStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewStmtContext {
	var p = new(CreateViewStmtContext)

	p.CreateStmtContext = NewEmptyCreateStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateViewStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewStmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *CreateViewStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateViewStmtContext) SubqueryClause() ISubqueryClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryClauseContext)
}

func (s *CreateViewStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateViewStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateViewStmtContext) OR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOR, 0)
}

func (s *CreateViewStmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLACE, 0)
}

func (s *CreateViewStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateViewStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateViewStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateViewStmtContext) UuidClause() IUuidClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUuidClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUuidClauseContext)
}

func (s *CreateViewStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateViewStmtContext) TableSchemaClause() ITableSchemaClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSchemaClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSchemaClauseContext)
}

func (s *CreateViewStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateViewStmt(s)
	}
}

func (s *CreateViewStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateViewStmt(s)
	}
}

type CreateDictionaryStmtContext struct {
	*CreateStmtContext
}

func NewCreateDictionaryStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDictionaryStmtContext {
	var p = new(CreateDictionaryStmtContext)

	p.CreateStmtContext = NewEmptyCreateStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateDictionaryStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDictionaryStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *CreateDictionaryStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateDictionaryStmtContext) DictionarySchemaClause() IDictionarySchemaClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionarySchemaClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionarySchemaClauseContext)
}

func (s *CreateDictionaryStmtContext) DictionaryEngineClause() IDictionaryEngineClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryEngineClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryEngineClauseContext)
}

func (s *CreateDictionaryStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateDictionaryStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateDictionaryStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateDictionaryStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateDictionaryStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateDictionaryStmtContext) UuidClause() IUuidClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUuidClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUuidClauseContext)
}

func (s *CreateDictionaryStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateDictionaryStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateDictionaryStmt(s)
	}
}

func (s *CreateDictionaryStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateDictionaryStmt(s)
	}
}

type CreateDatabaseStmtContext struct {
	*CreateStmtContext
}

func NewCreateDatabaseStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDatabaseStmtContext {
	var p = new(CreateDatabaseStmtContext)

	p.CreateStmtContext = NewEmptyCreateStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateDatabaseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASE, 0)
}

func (s *CreateDatabaseStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *CreateDatabaseStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateDatabaseStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateDatabaseStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateDatabaseStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateDatabaseStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateDatabaseStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateDatabaseStmtContext) EngineExpr() IEngineExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEngineExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEngineExprContext)
}

func (s *CreateDatabaseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateDatabaseStmt(s)
	}
}

func (s *CreateDatabaseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateDatabaseStmt(s)
	}
}

type CreateLiveViewStmtContext struct {
	*CreateStmtContext
}

func NewCreateLiveViewStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateLiveViewStmtContext {
	var p = new(CreateLiveViewStmtContext)

	p.CreateStmtContext = NewEmptyCreateStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateLiveViewStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateLiveViewStmtContext) LIVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIVE, 0)
}

func (s *CreateLiveViewStmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *CreateLiveViewStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateLiveViewStmtContext) SubqueryClause() ISubqueryClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryClauseContext)
}

func (s *CreateLiveViewStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateLiveViewStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateLiveViewStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateLiveViewStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateLiveViewStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateLiveViewStmtContext) UuidClause() IUuidClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUuidClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUuidClauseContext)
}

func (s *CreateLiveViewStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateLiveViewStmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *CreateLiveViewStmtContext) TIMEOUT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIMEOUT, 0)
}

func (s *CreateLiveViewStmtContext) DestinationClause() IDestinationClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDestinationClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDestinationClauseContext)
}

func (s *CreateLiveViewStmtContext) TableSchemaClause() ITableSchemaClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSchemaClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSchemaClauseContext)
}

func (s *CreateLiveViewStmtContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *CreateLiveViewStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateLiveViewStmt(s)
	}
}

func (s *CreateLiveViewStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateLiveViewStmt(s)
	}
}

type CreateMaterializedViewStmtContext struct {
	*CreateStmtContext
}

func NewCreateMaterializedViewStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateMaterializedViewStmtContext {
	var p = new(CreateMaterializedViewStmtContext)

	p.CreateStmtContext = NewEmptyCreateStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateMaterializedViewStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewStmtContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZED, 0)
}

func (s *CreateMaterializedViewStmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *CreateMaterializedViewStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateMaterializedViewStmtContext) SubqueryClause() ISubqueryClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryClauseContext)
}

func (s *CreateMaterializedViewStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateMaterializedViewStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateMaterializedViewStmtContext) DestinationClause() IDestinationClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDestinationClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDestinationClauseContext)
}

func (s *CreateMaterializedViewStmtContext) EngineClause() IEngineClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEngineClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEngineClauseContext)
}

func (s *CreateMaterializedViewStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateMaterializedViewStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateMaterializedViewStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateMaterializedViewStmtContext) UuidClause() IUuidClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUuidClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUuidClauseContext)
}

func (s *CreateMaterializedViewStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateMaterializedViewStmtContext) TableSchemaClause() ITableSchemaClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSchemaClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSchemaClauseContext)
}

func (s *CreateMaterializedViewStmtContext) POPULATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPOPULATE, 0)
}

func (s *CreateMaterializedViewStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateMaterializedViewStmt(s)
	}
}

func (s *CreateMaterializedViewStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateMaterializedViewStmt(s)
	}
}

type CreateTableStmtContext struct {
	*CreateStmtContext
}

func NewCreateTableStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableStmtContext {
	var p = new(CreateTableStmtContext)

	p.CreateStmtContext = NewEmptyCreateStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *CreateTableStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateTableStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateTableStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateTableStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *CreateTableStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateTableStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateTableStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateTableStmtContext) UuidClause() IUuidClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUuidClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUuidClauseContext)
}

func (s *CreateTableStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateTableStmtContext) TableSchemaClause() ITableSchemaClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSchemaClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSchemaClauseContext)
}

func (s *CreateTableStmtContext) EngineClause() IEngineClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEngineClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEngineClauseContext)
}

func (s *CreateTableStmtContext) SubqueryClause() ISubqueryClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryClauseContext)
}

func (s *CreateTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateTableStmt(s)
	}
}

func (s *CreateTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateTableStmt(s)
	}
}

func (p *ClickHouseParser) CreateStmt() (localctx ICreateStmtContext) {
	localctx = NewCreateStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ClickHouseParserRULE_createStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateDatabaseStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(517)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserATTACH || _la == ClickHouseParserCREATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(518)
			p.Match(ClickHouseParserDATABASE)
		}
		p.SetState(522)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(519)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(520)
				p.Match(ClickHouseParserNOT)
			}
			{
				p.SetState(521)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(524)
			p.DatabaseIdentifier()
		}
		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(525)
				p.ClusterClause()
			}

		}
		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserENGINE {
			{
				p.SetState(528)
				p.EngineExpr()
			}

		}

	case 2:
		localctx = NewCreateDictionaryStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(531)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserATTACH || _la == ClickHouseParserCREATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(532)
			p.Match(ClickHouseParserDICTIONARY)
		}
		p.SetState(536)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(533)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(534)
				p.Match(ClickHouseParserNOT)
			}
			{
				p.SetState(535)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(538)
			p.TableIdentifier()
		}
		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserUUID {
			{
				p.SetState(539)
				p.UuidClause()
			}

		}
		p.SetState(543)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(542)
				p.ClusterClause()
			}

		}
		{
			p.SetState(545)
			p.DictionarySchemaClause()
		}
		{
			p.SetState(546)
			p.DictionaryEngineClause()
		}

	case 3:
		localctx = NewCreateLiveViewStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(548)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserATTACH || _la == ClickHouseParserCREATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(549)
			p.Match(ClickHouseParserLIVE)
		}
		{
			p.SetState(550)
			p.Match(ClickHouseParserVIEW)
		}
		p.SetState(554)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(551)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(552)
				p.Match(ClickHouseParserNOT)
			}
			{
				p.SetState(553)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(556)
			p.TableIdentifier()
		}
		p.SetState(558)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserUUID {
			{
				p.SetState(557)
				p.UuidClause()
			}

		}
		p.SetState(561)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(560)
				p.ClusterClause()
			}

		}
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserWITH {
			{
				p.SetState(563)
				p.Match(ClickHouseParserWITH)
			}
			{
				p.SetState(564)
				p.Match(ClickHouseParserTIMEOUT)
			}
			p.SetState(566)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserDECIMAL_LITERAL {
				{
					p.SetState(565)
					p.Match(ClickHouseParserDECIMAL_LITERAL)
				}

			}

		}
		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserTO {
			{
				p.SetState(570)
				p.DestinationClause()
			}

		}
		p.SetState(574)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(573)
				p.TableSchemaClause()
			}

		}
		{
			p.SetState(576)
			p.SubqueryClause()
		}

	case 4:
		localctx = NewCreateMaterializedViewStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(578)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserATTACH || _la == ClickHouseParserCREATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(579)
			p.Match(ClickHouseParserMATERIALIZED)
		}
		{
			p.SetState(580)
			p.Match(ClickHouseParserVIEW)
		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(581)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(582)
				p.Match(ClickHouseParserNOT)
			}
			{
				p.SetState(583)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(586)
			p.TableIdentifier()
		}
		p.SetState(588)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserUUID {
			{
				p.SetState(587)
				p.UuidClause()
			}

		}
		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(590)
				p.ClusterClause()
			}

		}
		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserAS || _la == ClickHouseParserLPAREN {
			{
				p.SetState(593)
				p.TableSchemaClause()
			}

		}
		p.SetState(601)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserTO:
			{
				p.SetState(596)
				p.DestinationClause()
			}

		case ClickHouseParserENGINE:
			{
				p.SetState(597)
				p.EngineClause()
			}
			p.SetState(599)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserPOPULATE {
				{
					p.SetState(598)
					p.Match(ClickHouseParserPOPULATE)
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(603)
			p.SubqueryClause()
		}

	case 5:
		localctx = NewCreateTableStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(605)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserATTACH || _la == ClickHouseParserCREATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(607)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserTEMPORARY {
			{
				p.SetState(606)
				p.Match(ClickHouseParserTEMPORARY)
			}

		}
		{
			p.SetState(609)
			p.Match(ClickHouseParserTABLE)
		}
		p.SetState(613)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(610)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(611)
				p.Match(ClickHouseParserNOT)
			}
			{
				p.SetState(612)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(615)
			p.TableIdentifier()
		}
		p.SetState(617)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserUUID {
			{
				p.SetState(616)
				p.UuidClause()
			}

		}
		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(619)
				p.ClusterClause()
			}

		}
		p.SetState(623)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(622)
				p.TableSchemaClause()
			}

		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserENGINE {
			{
				p.SetState(625)
				p.EngineClause()
			}

		}
		p.SetState(629)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserAS {
			{
				p.SetState(628)
				p.SubqueryClause()
			}

		}

	case 6:
		localctx = NewCreateViewStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(631)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserATTACH || _la == ClickHouseParserCREATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserOR {
			{
				p.SetState(632)
				p.Match(ClickHouseParserOR)
			}
			{
				p.SetState(633)
				p.Match(ClickHouseParserREPLACE)
			}

		}
		{
			p.SetState(636)
			p.Match(ClickHouseParserVIEW)
		}
		p.SetState(640)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(637)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(638)
				p.Match(ClickHouseParserNOT)
			}
			{
				p.SetState(639)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(642)
			p.TableIdentifier()
		}
		p.SetState(644)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserUUID {
			{
				p.SetState(643)
				p.UuidClause()
			}

		}
		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(646)
				p.ClusterClause()
			}

		}
		p.SetState(650)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(649)
				p.TableSchemaClause()
			}

		}
		{
			p.SetState(652)
			p.SubqueryClause()
		}

	}

	return localctx
}

// IDictionarySchemaClauseContext is an interface to support dynamic dispatch.
type IDictionarySchemaClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionarySchemaClauseContext differentiates from other interfaces.
	IsDictionarySchemaClauseContext()
}

type DictionarySchemaClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionarySchemaClauseContext() *DictionarySchemaClauseContext {
	var p = new(DictionarySchemaClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionarySchemaClause
	return p
}

func (*DictionarySchemaClauseContext) IsDictionarySchemaClauseContext() {}

func NewDictionarySchemaClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionarySchemaClauseContext {
	var p = new(DictionarySchemaClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionarySchemaClause

	return p
}

func (s *DictionarySchemaClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionarySchemaClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *DictionarySchemaClauseContext) AllDictionaryAttrDfnt() []IDictionaryAttrDfntContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDictionaryAttrDfntContext)(nil)).Elem())
	var tst = make([]IDictionaryAttrDfntContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDictionaryAttrDfntContext)
		}
	}

	return tst
}

func (s *DictionarySchemaClauseContext) DictionaryAttrDfnt(i int) IDictionaryAttrDfntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryAttrDfntContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDictionaryAttrDfntContext)
}

func (s *DictionarySchemaClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *DictionarySchemaClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *DictionarySchemaClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *DictionarySchemaClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionarySchemaClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionarySchemaClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionarySchemaClause(s)
	}
}

func (s *DictionarySchemaClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionarySchemaClause(s)
	}
}

func (p *ClickHouseParser) DictionarySchemaClause() (localctx IDictionarySchemaClauseContext) {
	localctx = NewDictionarySchemaClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ClickHouseParserRULE_dictionarySchemaClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(ClickHouseParserLPAREN)
	}
	{
		p.SetState(657)
		p.DictionaryAttrDfnt()
	}
	p.SetState(662)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(658)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(659)
			p.DictionaryAttrDfnt()
		}

		p.SetState(664)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(665)
		p.Match(ClickHouseParserRPAREN)
	}

	return localctx
}

// IDictionaryAttrDfntContext is an interface to support dynamic dispatch.
type IDictionaryAttrDfntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAttrs returns the attrs attribute.
	GetAttrs() map[string]bool

	// SetAttrs sets the attrs attribute.
	SetAttrs(map[string]bool)

	// IsDictionaryAttrDfntContext differentiates from other interfaces.
	IsDictionaryAttrDfntContext()
}

type DictionaryAttrDfntContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	attrs  map[string]bool
}

func NewEmptyDictionaryAttrDfntContext() *DictionaryAttrDfntContext {
	var p = new(DictionaryAttrDfntContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryAttrDfnt
	return p
}

func (*DictionaryAttrDfntContext) IsDictionaryAttrDfntContext() {}

func NewDictionaryAttrDfntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryAttrDfntContext {
	var p = new(DictionaryAttrDfntContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionaryAttrDfnt
	p.attrs = make(map[string]bool)
	return p
}

func (s *DictionaryAttrDfntContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryAttrDfntContext) GetAttrs() map[string]bool { return s.attrs }

func (s *DictionaryAttrDfntContext) SetAttrs(v map[string]bool) { s.attrs = v }

func (s *DictionaryAttrDfntContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DictionaryAttrDfntContext) ColumnTypeExpr() IColumnTypeExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnTypeExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *DictionaryAttrDfntContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserDEFAULT)
}

func (s *DictionaryAttrDfntContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEFAULT, i)
}

func (s *DictionaryAttrDfntContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *DictionaryAttrDfntContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DictionaryAttrDfntContext) AllEXPRESSION() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserEXPRESSION)
}

func (s *DictionaryAttrDfntContext) EXPRESSION(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXPRESSION, i)
}

func (s *DictionaryAttrDfntContext) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *DictionaryAttrDfntContext) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *DictionaryAttrDfntContext) AllHIERARCHICAL() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserHIERARCHICAL)
}

func (s *DictionaryAttrDfntContext) HIERARCHICAL(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHIERARCHICAL, i)
}

func (s *DictionaryAttrDfntContext) AllINJECTIVE() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserINJECTIVE)
}

func (s *DictionaryAttrDfntContext) INJECTIVE(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINJECTIVE, i)
}

func (s *DictionaryAttrDfntContext) AllIS_OBJECT_ID() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserIS_OBJECT_ID)
}

func (s *DictionaryAttrDfntContext) IS_OBJECT_ID(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIS_OBJECT_ID, i)
}

func (s *DictionaryAttrDfntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryAttrDfntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryAttrDfntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionaryAttrDfnt(s)
	}
}

func (s *DictionaryAttrDfntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionaryAttrDfnt(s)
	}
}

func (p *ClickHouseParser) DictionaryAttrDfnt() (localctx IDictionaryAttrDfntContext) {
	localctx = NewDictionaryAttrDfntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ClickHouseParserRULE_dictionaryAttrDfnt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.Identifier()
	}
	{
		p.SetState(668)
		p.ColumnTypeExpr()
	}
	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(688)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) {
			case 1:
				p.SetState(669)

				if !(!localctx.(*DictionaryAttrDfntContext).attrs["default"]) {
					panic(antlr.NewFailedPredicateException(p, "!$attrs[\"default\"]", ""))
				}
				{
					p.SetState(670)
					p.Match(ClickHouseParserDEFAULT)
				}
				{
					p.SetState(671)
					p.Literal()
				}
				localctx.(*DictionaryAttrDfntContext).attrs["default"] = true

			case 2:
				p.SetState(674)

				if !(!localctx.(*DictionaryAttrDfntContext).attrs["expression"]) {
					panic(antlr.NewFailedPredicateException(p, "!$attrs[\"expression\"]", ""))
				}
				{
					p.SetState(675)
					p.Match(ClickHouseParserEXPRESSION)
				}
				{
					p.SetState(676)
					p.columnExpr(0)
				}
				localctx.(*DictionaryAttrDfntContext).attrs["expression"] = true

			case 3:
				p.SetState(679)

				if !(!localctx.(*DictionaryAttrDfntContext).attrs["hierarchical"]) {
					panic(antlr.NewFailedPredicateException(p, "!$attrs[\"hierarchical\"]", ""))
				}
				{
					p.SetState(680)
					p.Match(ClickHouseParserHIERARCHICAL)
				}
				localctx.(*DictionaryAttrDfntContext).attrs["hierarchical"] = true

			case 4:
				p.SetState(682)

				if !(!localctx.(*DictionaryAttrDfntContext).attrs["injective"]) {
					panic(antlr.NewFailedPredicateException(p, "!$attrs[\"injective\"]", ""))
				}
				{
					p.SetState(683)
					p.Match(ClickHouseParserINJECTIVE)
				}
				localctx.(*DictionaryAttrDfntContext).attrs["injective"] = true

			case 5:
				p.SetState(685)

				if !(!localctx.(*DictionaryAttrDfntContext).attrs["is_object_id"]) {
					panic(antlr.NewFailedPredicateException(p, "!$attrs[\"is_object_id\"]", ""))
				}
				{
					p.SetState(686)
					p.Match(ClickHouseParserIS_OBJECT_ID)
				}
				localctx.(*DictionaryAttrDfntContext).attrs["is_object_id"] = true

			}

		}
		p.SetState(692)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext())
	}

	return localctx
}

// IDictionaryEngineClauseContext is an interface to support dynamic dispatch.
type IDictionaryEngineClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetClauses returns the clauses attribute.
	GetClauses() map[string]bool

	// SetClauses sets the clauses attribute.
	SetClauses(map[string]bool)

	// IsDictionaryEngineClauseContext differentiates from other interfaces.
	IsDictionaryEngineClauseContext()
}

type DictionaryEngineClauseContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	clauses map[string]bool
}

func NewEmptyDictionaryEngineClauseContext() *DictionaryEngineClauseContext {
	var p = new(DictionaryEngineClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryEngineClause
	p.clauses = make(map[string]bool)
	return p
}

func (*DictionaryEngineClauseContext) IsDictionaryEngineClauseContext() {}

func NewDictionaryEngineClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryEngineClauseContext {
	var p = new(DictionaryEngineClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionaryEngineClause
	p.clauses = make(map[string]bool)
	return p
}

func (s *DictionaryEngineClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryEngineClauseContext) GetClauses() map[string]bool { return s.clauses }

func (s *DictionaryEngineClauseContext) SetClauses(v map[string]bool) { s.clauses = v }

func (s *DictionaryEngineClauseContext) DictionaryPrimaryKeyClause() IDictionaryPrimaryKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryPrimaryKeyClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryPrimaryKeyClauseContext)
}

func (s *DictionaryEngineClauseContext) AllSourceClause() []ISourceClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISourceClauseContext)(nil)).Elem())
	var tst = make([]ISourceClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISourceClauseContext)
		}
	}

	return tst
}

func (s *DictionaryEngineClauseContext) SourceClause(i int) ISourceClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISourceClauseContext)
}

func (s *DictionaryEngineClauseContext) AllLifetimeClause() []ILifetimeClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILifetimeClauseContext)(nil)).Elem())
	var tst = make([]ILifetimeClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILifetimeClauseContext)
		}
	}

	return tst
}

func (s *DictionaryEngineClauseContext) LifetimeClause(i int) ILifetimeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILifetimeClauseContext)
}

func (s *DictionaryEngineClauseContext) AllLayoutClause() []ILayoutClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILayoutClauseContext)(nil)).Elem())
	var tst = make([]ILayoutClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILayoutClauseContext)
		}
	}

	return tst
}

func (s *DictionaryEngineClauseContext) LayoutClause(i int) ILayoutClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILayoutClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILayoutClauseContext)
}

func (s *DictionaryEngineClauseContext) AllRangeClause() []IRangeClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRangeClauseContext)(nil)).Elem())
	var tst = make([]IRangeClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRangeClauseContext)
		}
	}

	return tst
}

func (s *DictionaryEngineClauseContext) RangeClause(i int) IRangeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRangeClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRangeClauseContext)
}

func (s *DictionaryEngineClauseContext) AllDictionarySettingsClause() []IDictionarySettingsClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDictionarySettingsClauseContext)(nil)).Elem())
	var tst = make([]IDictionarySettingsClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDictionarySettingsClauseContext)
		}
	}

	return tst
}

func (s *DictionaryEngineClauseContext) DictionarySettingsClause(i int) IDictionarySettingsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionarySettingsClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDictionarySettingsClauseContext)
}

func (s *DictionaryEngineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryEngineClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryEngineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionaryEngineClause(s)
	}
}

func (s *DictionaryEngineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionaryEngineClause(s)
	}
}

func (p *ClickHouseParser) DictionaryEngineClause() (localctx IDictionaryEngineClauseContext) {
	localctx = NewDictionaryEngineClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ClickHouseParserRULE_dictionaryEngineClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(694)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(693)
			p.DictionaryPrimaryKeyClause()
		}

	}
	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(716)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
			case 1:
				p.SetState(696)

				if !(!localctx.(*DictionaryEngineClauseContext).clauses["source"]) {
					panic(antlr.NewFailedPredicateException(p, "!$clauses[\"source\"]", ""))
				}
				{
					p.SetState(697)
					p.SourceClause()
				}
				localctx.(*DictionaryEngineClauseContext).clauses["source"] = true

			case 2:
				p.SetState(700)

				if !(!localctx.(*DictionaryEngineClauseContext).clauses["lifetime"]) {
					panic(antlr.NewFailedPredicateException(p, "!$clauses[\"lifetime\"]", ""))
				}
				{
					p.SetState(701)
					p.LifetimeClause()
				}
				localctx.(*DictionaryEngineClauseContext).clauses["lifetime"] = true

			case 3:
				p.SetState(704)

				if !(!localctx.(*DictionaryEngineClauseContext).clauses["layout"]) {
					panic(antlr.NewFailedPredicateException(p, "!$clauses[\"layout\"]", ""))
				}
				{
					p.SetState(705)
					p.LayoutClause()
				}
				localctx.(*DictionaryEngineClauseContext).clauses["layout"] = true

			case 4:
				p.SetState(708)

				if !(!localctx.(*DictionaryEngineClauseContext).clauses["range"]) {
					panic(antlr.NewFailedPredicateException(p, "!$clauses[\"range\"]", ""))
				}
				{
					p.SetState(709)
					p.RangeClause()
				}
				localctx.(*DictionaryEngineClauseContext).clauses["range"] = true

			case 5:
				p.SetState(712)

				if !(!localctx.(*DictionaryEngineClauseContext).clauses["settings"]) {
					panic(antlr.NewFailedPredicateException(p, "!$clauses[\"settings\"]", ""))
				}
				{
					p.SetState(713)
					p.DictionarySettingsClause()
				}
				localctx.(*DictionaryEngineClauseContext).clauses["settings"] = true

			}

		}
		p.SetState(720)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())
	}

	return localctx
}

// IDictionaryPrimaryKeyClauseContext is an interface to support dynamic dispatch.
type IDictionaryPrimaryKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryPrimaryKeyClauseContext differentiates from other interfaces.
	IsDictionaryPrimaryKeyClauseContext()
}

type DictionaryPrimaryKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryPrimaryKeyClauseContext() *DictionaryPrimaryKeyClauseContext {
	var p = new(DictionaryPrimaryKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryPrimaryKeyClause
	return p
}

func (*DictionaryPrimaryKeyClauseContext) IsDictionaryPrimaryKeyClauseContext() {}

func NewDictionaryPrimaryKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryPrimaryKeyClauseContext {
	var p = new(DictionaryPrimaryKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionaryPrimaryKeyClause

	return p
}

func (s *DictionaryPrimaryKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryPrimaryKeyClauseContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRIMARY, 0)
}

func (s *DictionaryPrimaryKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKEY, 0)
}

func (s *DictionaryPrimaryKeyClauseContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *DictionaryPrimaryKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryPrimaryKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryPrimaryKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionaryPrimaryKeyClause(s)
	}
}

func (s *DictionaryPrimaryKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionaryPrimaryKeyClause(s)
	}
}

func (p *ClickHouseParser) DictionaryPrimaryKeyClause() (localctx IDictionaryPrimaryKeyClauseContext) {
	localctx = NewDictionaryPrimaryKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ClickHouseParserRULE_dictionaryPrimaryKeyClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		p.Match(ClickHouseParserPRIMARY)
	}
	{
		p.SetState(722)
		p.Match(ClickHouseParserKEY)
	}
	{
		p.SetState(723)
		p.ColumnExprList()
	}

	return localctx
}

// IDictionaryArgExprContext is an interface to support dynamic dispatch.
type IDictionaryArgExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryArgExprContext differentiates from other interfaces.
	IsDictionaryArgExprContext()
}

type DictionaryArgExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryArgExprContext() *DictionaryArgExprContext {
	var p = new(DictionaryArgExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryArgExpr
	return p
}

func (*DictionaryArgExprContext) IsDictionaryArgExprContext() {}

func NewDictionaryArgExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryArgExprContext {
	var p = new(DictionaryArgExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionaryArgExpr

	return p
}

func (s *DictionaryArgExprContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryArgExprContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *DictionaryArgExprContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DictionaryArgExprContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DictionaryArgExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *DictionaryArgExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *DictionaryArgExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryArgExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryArgExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionaryArgExpr(s)
	}
}

func (s *DictionaryArgExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionaryArgExpr(s)
	}
}

func (p *ClickHouseParser) DictionaryArgExpr() (localctx IDictionaryArgExprContext) {
	localctx = NewDictionaryArgExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ClickHouseParserRULE_dictionaryArgExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(725)
		p.Identifier()
	}
	p.SetState(732)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALL, ClickHouseParserALTER, ClickHouseParserAND, ClickHouseParserANTI, ClickHouseParserANY, ClickHouseParserARRAY, ClickHouseParserAS, ClickHouseParserASCENDING, ClickHouseParserASOF, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBETWEEN, ClickHouseParserBOTH, ClickHouseParserBY, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCODEC, ClickHouseParserCOLLATE, ClickHouseParserCOLUMN, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCROSS, ClickHouseParserCUBE, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDAY, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDELETE, ClickHouseParserDESC, ClickHouseParserDESCENDING, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTINCT, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserELSE, ClickHouseParserEND, ClickHouseParserENGINE, ClickHouseParserEVENTS, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFINAL, ClickHouseParserFIRST, ClickHouseParserFLUSH, ClickHouseParserFOR, ClickHouseParserFORMAT, ClickHouseParserFREEZE, ClickHouseParserFROM, ClickHouseParserFULL, ClickHouseParserFUNCTION, ClickHouseParserGLOBAL, ClickHouseParserGRANULARITY, ClickHouseParserGROUP, ClickHouseParserHAVING, ClickHouseParserHIERARCHICAL, ClickHouseParserHOUR, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserILIKE, ClickHouseParserIN, ClickHouseParserINDEX, ClickHouseParserINJECTIVE, ClickHouseParserINNER, ClickHouseParserINSERT, ClickHouseParserINTERVAL, ClickHouseParserINTO, ClickHouseParserIS, ClickHouseParserIS_OBJECT_ID, ClickHouseParserJOIN, ClickHouseParserKEY, ClickHouseParserKILL, ClickHouseParserLAST, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLEFT, ClickHouseParserLIFETIME, ClickHouseParserLIKE, ClickHouseParserLIMIT, ClickHouseParserLIVE, ClickHouseParserLOCAL, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMIN, ClickHouseParserMINUTE, ClickHouseParserMODIFY, ClickHouseParserMONTH, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNO, ClickHouseParserNOT, ClickHouseParserNULLS, ClickHouseParserOFFSET, ClickHouseParserON, ClickHouseParserOPTIMIZE, ClickHouseParserOR, ClickHouseParserORDER, ClickHouseParserOUTER, ClickHouseParserOUTFILE, ClickHouseParserPARTITION, ClickHouseParserPOPULATE, ClickHouseParserPREWHERE, ClickHouseParserPRIMARY, ClickHouseParserQUARTER, ClickHouseParserRANGE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserRIGHT, ClickHouseParserROLLUP, ClickHouseParserSAMPLE, ClickHouseParserSECOND, ClickHouseParserSELECT, ClickHouseParserSEMI, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSETTINGS, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTHEN, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTO, ClickHouseParserTOP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNION, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUSING, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserWEEK, ClickHouseParserWHEN, ClickHouseParserWHERE, ClickHouseParserWITH, ClickHouseParserYEAR, ClickHouseParserJSON_FALSE, ClickHouseParserJSON_TRUE, ClickHouseParserIDENTIFIER:
		{
			p.SetState(726)
			p.Identifier()
		}
		p.SetState(729)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserLPAREN {
			{
				p.SetState(727)
				p.Match(ClickHouseParserLPAREN)
			}
			{
				p.SetState(728)
				p.Match(ClickHouseParserRPAREN)
			}

		}

	case ClickHouseParserINF, ClickHouseParserNAN_SQL, ClickHouseParserNULL_SQL, ClickHouseParserFLOATING_LITERAL, ClickHouseParserOCTAL_LITERAL, ClickHouseParserDECIMAL_LITERAL, ClickHouseParserHEXADECIMAL_LITERAL, ClickHouseParserSTRING_LITERAL, ClickHouseParserDASH, ClickHouseParserDOT, ClickHouseParserPLUS:
		{
			p.SetState(731)
			p.Literal()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISourceClauseContext is an interface to support dynamic dispatch.
type ISourceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceClauseContext differentiates from other interfaces.
	IsSourceClauseContext()
}

type SourceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceClauseContext() *SourceClauseContext {
	var p = new(SourceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_sourceClause
	return p
}

func (*SourceClauseContext) IsSourceClauseContext() {}

func NewSourceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceClauseContext {
	var p = new(SourceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_sourceClause

	return p
}

func (s *SourceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceClauseContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSOURCE, 0)
}

func (s *SourceClauseContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserLPAREN)
}

func (s *SourceClauseContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, i)
}

func (s *SourceClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SourceClauseContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserRPAREN)
}

func (s *SourceClauseContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, i)
}

func (s *SourceClauseContext) AllDictionaryArgExpr() []IDictionaryArgExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDictionaryArgExprContext)(nil)).Elem())
	var tst = make([]IDictionaryArgExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDictionaryArgExprContext)
		}
	}

	return tst
}

func (s *SourceClauseContext) DictionaryArgExpr(i int) IDictionaryArgExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryArgExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDictionaryArgExprContext)
}

func (s *SourceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSourceClause(s)
	}
}

func (s *SourceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSourceClause(s)
	}
}

func (p *ClickHouseParser) SourceClause() (localctx ISourceClauseContext) {
	localctx = NewSourceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ClickHouseParserRULE_sourceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		p.Match(ClickHouseParserSOURCE)
	}
	{
		p.SetState(735)
		p.Match(ClickHouseParserLPAREN)
	}
	{
		p.SetState(736)
		p.Identifier()
	}
	{
		p.SetState(737)
		p.Match(ClickHouseParserLPAREN)
	}
	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDAY-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserHOUR-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMINUTE-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMONTH-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96))|(1<<(ClickHouseParserQUARTER-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSECOND-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWEEK-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserYEAR-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160))|(1<<(ClickHouseParserIDENTIFIER-160)))) != 0) {
		{
			p.SetState(738)
			p.DictionaryArgExpr()
		}

		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(744)
		p.Match(ClickHouseParserRPAREN)
	}
	{
		p.SetState(745)
		p.Match(ClickHouseParserRPAREN)
	}

	return localctx
}

// ILifetimeClauseContext is an interface to support dynamic dispatch.
type ILifetimeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLifetimeClauseContext differentiates from other interfaces.
	IsLifetimeClauseContext()
}

type LifetimeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLifetimeClauseContext() *LifetimeClauseContext {
	var p = new(LifetimeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_lifetimeClause
	return p
}

func (*LifetimeClauseContext) IsLifetimeClauseContext() {}

func NewLifetimeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LifetimeClauseContext {
	var p = new(LifetimeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_lifetimeClause

	return p
}

func (s *LifetimeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LifetimeClauseContext) LIFETIME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIFETIME, 0)
}

func (s *LifetimeClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *LifetimeClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *LifetimeClauseContext) AllDECIMAL_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserDECIMAL_LITERAL)
}

func (s *LifetimeClauseContext) DECIMAL_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, i)
}

func (s *LifetimeClauseContext) MIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMIN, 0)
}

func (s *LifetimeClauseContext) MAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMAX, 0)
}

func (s *LifetimeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LifetimeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LifetimeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLifetimeClause(s)
	}
}

func (s *LifetimeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLifetimeClause(s)
	}
}

func (p *ClickHouseParser) LifetimeClause() (localctx ILifetimeClauseContext) {
	localctx = NewLifetimeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ClickHouseParserRULE_lifetimeClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(ClickHouseParserLIFETIME)
	}
	{
		p.SetState(748)
		p.Match(ClickHouseParserLPAREN)
	}
	p.SetState(758)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserDECIMAL_LITERAL:
		{
			p.SetState(749)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
		}

	case ClickHouseParserMIN:
		{
			p.SetState(750)
			p.Match(ClickHouseParserMIN)
		}
		{
			p.SetState(751)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
		}
		{
			p.SetState(752)
			p.Match(ClickHouseParserMAX)
		}
		{
			p.SetState(753)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
		}

	case ClickHouseParserMAX:
		{
			p.SetState(754)
			p.Match(ClickHouseParserMAX)
		}
		{
			p.SetState(755)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
		}
		{
			p.SetState(756)
			p.Match(ClickHouseParserMIN)
		}
		{
			p.SetState(757)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(760)
		p.Match(ClickHouseParserRPAREN)
	}

	return localctx
}

// ILayoutClauseContext is an interface to support dynamic dispatch.
type ILayoutClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLayoutClauseContext differentiates from other interfaces.
	IsLayoutClauseContext()
}

type LayoutClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLayoutClauseContext() *LayoutClauseContext {
	var p = new(LayoutClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_layoutClause
	return p
}

func (*LayoutClauseContext) IsLayoutClauseContext() {}

func NewLayoutClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LayoutClauseContext {
	var p = new(LayoutClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_layoutClause

	return p
}

func (s *LayoutClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LayoutClauseContext) LAYOUT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLAYOUT, 0)
}

func (s *LayoutClauseContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserLPAREN)
}

func (s *LayoutClauseContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, i)
}

func (s *LayoutClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LayoutClauseContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserRPAREN)
}

func (s *LayoutClauseContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, i)
}

func (s *LayoutClauseContext) AllDictionaryArgExpr() []IDictionaryArgExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDictionaryArgExprContext)(nil)).Elem())
	var tst = make([]IDictionaryArgExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDictionaryArgExprContext)
		}
	}

	return tst
}

func (s *LayoutClauseContext) DictionaryArgExpr(i int) IDictionaryArgExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryArgExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDictionaryArgExprContext)
}

func (s *LayoutClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LayoutClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LayoutClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLayoutClause(s)
	}
}

func (s *LayoutClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLayoutClause(s)
	}
}

func (p *ClickHouseParser) LayoutClause() (localctx ILayoutClauseContext) {
	localctx = NewLayoutClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ClickHouseParserRULE_layoutClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(762)
		p.Match(ClickHouseParserLAYOUT)
	}
	{
		p.SetState(763)
		p.Match(ClickHouseParserLPAREN)
	}
	{
		p.SetState(764)
		p.Identifier()
	}
	{
		p.SetState(765)
		p.Match(ClickHouseParserLPAREN)
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDAY-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserHOUR-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMINUTE-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMONTH-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96))|(1<<(ClickHouseParserQUARTER-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSECOND-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWEEK-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserYEAR-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160))|(1<<(ClickHouseParserIDENTIFIER-160)))) != 0) {
		{
			p.SetState(766)
			p.DictionaryArgExpr()
		}

		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(772)
		p.Match(ClickHouseParserRPAREN)
	}
	{
		p.SetState(773)
		p.Match(ClickHouseParserRPAREN)
	}

	return localctx
}

// IRangeClauseContext is an interface to support dynamic dispatch.
type IRangeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeClauseContext differentiates from other interfaces.
	IsRangeClauseContext()
}

type RangeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeClauseContext() *RangeClauseContext {
	var p = new(RangeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_rangeClause
	return p
}

func (*RangeClauseContext) IsRangeClauseContext() {}

func NewRangeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeClauseContext {
	var p = new(RangeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_rangeClause

	return p
}

func (s *RangeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeClauseContext) RANGE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRANGE, 0)
}

func (s *RangeClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *RangeClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *RangeClauseContext) MIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMIN, 0)
}

func (s *RangeClauseContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *RangeClauseContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RangeClauseContext) MAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMAX, 0)
}

func (s *RangeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterRangeClause(s)
	}
}

func (s *RangeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitRangeClause(s)
	}
}

func (p *ClickHouseParser) RangeClause() (localctx IRangeClauseContext) {
	localctx = NewRangeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ClickHouseParserRULE_rangeClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.Match(ClickHouseParserRANGE)
	}
	{
		p.SetState(776)
		p.Match(ClickHouseParserLPAREN)
	}
	p.SetState(787)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserMIN:
		{
			p.SetState(777)
			p.Match(ClickHouseParserMIN)
		}
		{
			p.SetState(778)
			p.Identifier()
		}
		{
			p.SetState(779)
			p.Match(ClickHouseParserMAX)
		}
		{
			p.SetState(780)
			p.Identifier()
		}

	case ClickHouseParserMAX:
		{
			p.SetState(782)
			p.Match(ClickHouseParserMAX)
		}
		{
			p.SetState(783)
			p.Identifier()
		}
		{
			p.SetState(784)
			p.Match(ClickHouseParserMIN)
		}
		{
			p.SetState(785)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(789)
		p.Match(ClickHouseParserRPAREN)
	}

	return localctx
}

// IDictionarySettingsClauseContext is an interface to support dynamic dispatch.
type IDictionarySettingsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionarySettingsClauseContext differentiates from other interfaces.
	IsDictionarySettingsClauseContext()
}

type DictionarySettingsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionarySettingsClauseContext() *DictionarySettingsClauseContext {
	var p = new(DictionarySettingsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionarySettingsClause
	return p
}

func (*DictionarySettingsClauseContext) IsDictionarySettingsClauseContext() {}

func NewDictionarySettingsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionarySettingsClauseContext {
	var p = new(DictionarySettingsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionarySettingsClause

	return p
}

func (s *DictionarySettingsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionarySettingsClauseContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETTINGS, 0)
}

func (s *DictionarySettingsClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *DictionarySettingsClauseContext) SettingExprList() ISettingExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISettingExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISettingExprListContext)
}

func (s *DictionarySettingsClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *DictionarySettingsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionarySettingsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionarySettingsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionarySettingsClause(s)
	}
}

func (s *DictionarySettingsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionarySettingsClause(s)
	}
}

func (p *ClickHouseParser) DictionarySettingsClause() (localctx IDictionarySettingsClauseContext) {
	localctx = NewDictionarySettingsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ClickHouseParserRULE_dictionarySettingsClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(791)
		p.Match(ClickHouseParserSETTINGS)
	}
	{
		p.SetState(792)
		p.Match(ClickHouseParserLPAREN)
	}
	{
		p.SetState(793)
		p.SettingExprList()
	}
	{
		p.SetState(794)
		p.Match(ClickHouseParserRPAREN)
	}

	return localctx
}

// IClusterClauseContext is an interface to support dynamic dispatch.
type IClusterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClusterClauseContext differentiates from other interfaces.
	IsClusterClauseContext()
}

type ClusterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusterClauseContext() *ClusterClauseContext {
	var p = new(ClusterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_clusterClause
	return p
}

func (*ClusterClauseContext) IsClusterClauseContext() {}

func NewClusterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusterClauseContext {
	var p = new(ClusterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_clusterClause

	return p
}

func (s *ClusterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusterClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserON, 0)
}

func (s *ClusterClauseContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLUSTER, 0)
}

func (s *ClusterClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClusterClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *ClusterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterClusterClause(s)
	}
}

func (s *ClusterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitClusterClause(s)
	}
}

func (p *ClickHouseParser) ClusterClause() (localctx IClusterClauseContext) {
	localctx = NewClusterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ClickHouseParserRULE_clusterClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(796)
		p.Match(ClickHouseParserON)
	}
	{
		p.SetState(797)
		p.Match(ClickHouseParserCLUSTER)
	}
	p.SetState(800)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALL, ClickHouseParserALTER, ClickHouseParserAND, ClickHouseParserANTI, ClickHouseParserANY, ClickHouseParserARRAY, ClickHouseParserAS, ClickHouseParserASCENDING, ClickHouseParserASOF, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBETWEEN, ClickHouseParserBOTH, ClickHouseParserBY, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCODEC, ClickHouseParserCOLLATE, ClickHouseParserCOLUMN, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCROSS, ClickHouseParserCUBE, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDAY, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDELETE, ClickHouseParserDESC, ClickHouseParserDESCENDING, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTINCT, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserELSE, ClickHouseParserEND, ClickHouseParserENGINE, ClickHouseParserEVENTS, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFINAL, ClickHouseParserFIRST, ClickHouseParserFLUSH, ClickHouseParserFOR, ClickHouseParserFORMAT, ClickHouseParserFREEZE, ClickHouseParserFROM, ClickHouseParserFULL, ClickHouseParserFUNCTION, ClickHouseParserGLOBAL, ClickHouseParserGRANULARITY, ClickHouseParserGROUP, ClickHouseParserHAVING, ClickHouseParserHIERARCHICAL, ClickHouseParserHOUR, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserILIKE, ClickHouseParserIN, ClickHouseParserINDEX, ClickHouseParserINJECTIVE, ClickHouseParserINNER, ClickHouseParserINSERT, ClickHouseParserINTERVAL, ClickHouseParserINTO, ClickHouseParserIS, ClickHouseParserIS_OBJECT_ID, ClickHouseParserJOIN, ClickHouseParserKEY, ClickHouseParserKILL, ClickHouseParserLAST, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLEFT, ClickHouseParserLIFETIME, ClickHouseParserLIKE, ClickHouseParserLIMIT, ClickHouseParserLIVE, ClickHouseParserLOCAL, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMIN, ClickHouseParserMINUTE, ClickHouseParserMODIFY, ClickHouseParserMONTH, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNO, ClickHouseParserNOT, ClickHouseParserNULLS, ClickHouseParserOFFSET, ClickHouseParserON, ClickHouseParserOPTIMIZE, ClickHouseParserOR, ClickHouseParserORDER, ClickHouseParserOUTER, ClickHouseParserOUTFILE, ClickHouseParserPARTITION, ClickHouseParserPOPULATE, ClickHouseParserPREWHERE, ClickHouseParserPRIMARY, ClickHouseParserQUARTER, ClickHouseParserRANGE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserRIGHT, ClickHouseParserROLLUP, ClickHouseParserSAMPLE, ClickHouseParserSECOND, ClickHouseParserSELECT, ClickHouseParserSEMI, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSETTINGS, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTHEN, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTO, ClickHouseParserTOP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNION, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUSING, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserWEEK, ClickHouseParserWHEN, ClickHouseParserWHERE, ClickHouseParserWITH, ClickHouseParserYEAR, ClickHouseParserJSON_FALSE, ClickHouseParserJSON_TRUE, ClickHouseParserIDENTIFIER:
		{
			p.SetState(798)
			p.Identifier()
		}

	case ClickHouseParserSTRING_LITERAL:
		{
			p.SetState(799)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUuidClauseContext is an interface to support dynamic dispatch.
type IUuidClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUuidClauseContext differentiates from other interfaces.
	IsUuidClauseContext()
}

type UuidClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUuidClauseContext() *UuidClauseContext {
	var p = new(UuidClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_uuidClause
	return p
}

func (*UuidClauseContext) IsUuidClauseContext() {}

func NewUuidClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UuidClauseContext {
	var p = new(UuidClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_uuidClause

	return p
}

func (s *UuidClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UuidClauseContext) UUID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUUID, 0)
}

func (s *UuidClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *UuidClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UuidClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UuidClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterUuidClause(s)
	}
}

func (s *UuidClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitUuidClause(s)
	}
}

func (p *ClickHouseParser) UuidClause() (localctx IUuidClauseContext) {
	localctx = NewUuidClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ClickHouseParserRULE_uuidClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		p.Match(ClickHouseParserUUID)
	}
	{
		p.SetState(803)
		p.Match(ClickHouseParserSTRING_LITERAL)
	}

	return localctx
}

// IDestinationClauseContext is an interface to support dynamic dispatch.
type IDestinationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDestinationClauseContext differentiates from other interfaces.
	IsDestinationClauseContext()
}

type DestinationClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestinationClauseContext() *DestinationClauseContext {
	var p = new(DestinationClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_destinationClause
	return p
}

func (*DestinationClauseContext) IsDestinationClauseContext() {}

func NewDestinationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationClauseContext {
	var p = new(DestinationClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_destinationClause

	return p
}

func (s *DestinationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DestinationClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, 0)
}

func (s *DestinationClauseContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *DestinationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestinationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDestinationClause(s)
	}
}

func (s *DestinationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDestinationClause(s)
	}
}

func (p *ClickHouseParser) DestinationClause() (localctx IDestinationClauseContext) {
	localctx = NewDestinationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ClickHouseParserRULE_destinationClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(805)
		p.Match(ClickHouseParserTO)
	}
	{
		p.SetState(806)
		p.TableIdentifier()
	}

	return localctx
}

// ISubqueryClauseContext is an interface to support dynamic dispatch.
type ISubqueryClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubqueryClauseContext differentiates from other interfaces.
	IsSubqueryClauseContext()
}

type SubqueryClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryClauseContext() *SubqueryClauseContext {
	var p = new(SubqueryClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_subqueryClause
	return p
}

func (*SubqueryClauseContext) IsSubqueryClauseContext() {}

func NewSubqueryClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryClauseContext {
	var p = new(SubqueryClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_subqueryClause

	return p
}

func (s *SubqueryClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *SubqueryClauseContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectUnionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *SubqueryClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSubqueryClause(s)
	}
}

func (s *SubqueryClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSubqueryClause(s)
	}
}

func (p *ClickHouseParser) SubqueryClause() (localctx ISubqueryClauseContext) {
	localctx = NewSubqueryClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ClickHouseParserRULE_subqueryClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(808)
		p.Match(ClickHouseParserAS)
	}
	{
		p.SetState(809)
		p.SelectUnionStmt()
	}

	return localctx
}

// ITableSchemaClauseContext is an interface to support dynamic dispatch.
type ITableSchemaClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableSchemaClauseContext differentiates from other interfaces.
	IsTableSchemaClauseContext()
}

type TableSchemaClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSchemaClauseContext() *TableSchemaClauseContext {
	var p = new(TableSchemaClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableSchemaClause
	return p
}

func (*TableSchemaClauseContext) IsTableSchemaClauseContext() {}

func NewTableSchemaClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSchemaClauseContext {
	var p = new(TableSchemaClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableSchemaClause

	return p
}

func (s *TableSchemaClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSchemaClauseContext) CopyFrom(ctx *TableSchemaClauseContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableSchemaClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSchemaClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SchemaAsTableClauseContext struct {
	*TableSchemaClauseContext
}

func NewSchemaAsTableClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SchemaAsTableClauseContext {
	var p = new(SchemaAsTableClauseContext)

	p.TableSchemaClauseContext = NewEmptyTableSchemaClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSchemaClauseContext))

	return p
}

func (s *SchemaAsTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaAsTableClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *SchemaAsTableClauseContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *SchemaAsTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSchemaAsTableClause(s)
	}
}

func (s *SchemaAsTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSchemaAsTableClause(s)
	}
}

type SchemaAsFunctionClauseContext struct {
	*TableSchemaClauseContext
}

func NewSchemaAsFunctionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SchemaAsFunctionClauseContext {
	var p = new(SchemaAsFunctionClauseContext)

	p.TableSchemaClauseContext = NewEmptyTableSchemaClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSchemaClauseContext))

	return p
}

func (s *SchemaAsFunctionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaAsFunctionClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *SchemaAsFunctionClauseContext) TableFunctionExpr() ITableFunctionExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableFunctionExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableFunctionExprContext)
}

func (s *SchemaAsFunctionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSchemaAsFunctionClause(s)
	}
}

func (s *SchemaAsFunctionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSchemaAsFunctionClause(s)
	}
}

type SchemaDescriptionClauseContext struct {
	*TableSchemaClauseContext
}

func NewSchemaDescriptionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SchemaDescriptionClauseContext {
	var p = new(SchemaDescriptionClauseContext)

	p.TableSchemaClauseContext = NewEmptyTableSchemaClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSchemaClauseContext))

	return p
}

func (s *SchemaDescriptionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaDescriptionClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *SchemaDescriptionClauseContext) AllTableElementExpr() []ITableElementExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableElementExprContext)(nil)).Elem())
	var tst = make([]ITableElementExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableElementExprContext)
		}
	}

	return tst
}

func (s *SchemaDescriptionClauseContext) TableElementExpr(i int) ITableElementExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableElementExprContext)
}

func (s *SchemaDescriptionClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *SchemaDescriptionClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *SchemaDescriptionClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *SchemaDescriptionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSchemaDescriptionClause(s)
	}
}

func (s *SchemaDescriptionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSchemaDescriptionClause(s)
	}
}

func (p *ClickHouseParser) TableSchemaClause() (localctx ITableSchemaClauseContext) {
	localctx = NewTableSchemaClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ClickHouseParserRULE_tableSchemaClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSchemaDescriptionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(811)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(812)
			p.TableElementExpr()
		}
		p.SetState(817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(813)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(814)
				p.TableElementExpr()
			}

			p.SetState(819)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(820)
			p.Match(ClickHouseParserRPAREN)
		}

	case 2:
		localctx = NewSchemaAsTableClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(822)
			p.Match(ClickHouseParserAS)
		}
		{
			p.SetState(823)
			p.TableIdentifier()
		}

	case 3:
		localctx = NewSchemaAsFunctionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(824)
			p.Match(ClickHouseParserAS)
		}
		{
			p.SetState(825)
			p.TableFunctionExpr()
		}

	}

	return localctx
}

// IEngineClauseContext is an interface to support dynamic dispatch.
type IEngineClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetClauses returns the clauses attribute.
	GetClauses() map[string]bool

	// SetClauses sets the clauses attribute.
	SetClauses(map[string]bool)

	// IsEngineClauseContext differentiates from other interfaces.
	IsEngineClauseContext()
}

type EngineClauseContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	clauses map[string]bool
}

func NewEmptyEngineClauseContext() *EngineClauseContext {
	var p = new(EngineClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_engineClause
	return p
}

func (*EngineClauseContext) IsEngineClauseContext() {}

func NewEngineClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineClauseContext {
	var p = new(EngineClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_engineClause
	p.clauses = make(map[string]bool)
	return p
}

func (s *EngineClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineClauseContext) GetClauses() map[string]bool { return s.clauses }

func (s *EngineClauseContext) SetClauses(v map[string]bool) { s.clauses = v }

func (s *EngineClauseContext) EngineExpr() IEngineExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEngineExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEngineExprContext)
}

func (s *EngineClauseContext) AllOrderByClause() []IOrderByClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem())
	var tst = make([]IOrderByClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderByClauseContext)
		}
	}

	return tst
}

func (s *EngineClauseContext) OrderByClause(i int) IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *EngineClauseContext) AllPartitionByClause() []IPartitionByClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPartitionByClauseContext)(nil)).Elem())
	var tst = make([]IPartitionByClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPartitionByClauseContext)
		}
	}

	return tst
}

func (s *EngineClauseContext) PartitionByClause(i int) IPartitionByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionByClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPartitionByClauseContext)
}

func (s *EngineClauseContext) AllPrimaryKeyClause() []IPrimaryKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrimaryKeyClauseContext)(nil)).Elem())
	var tst = make([]IPrimaryKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrimaryKeyClauseContext)
		}
	}

	return tst
}

func (s *EngineClauseContext) PrimaryKeyClause(i int) IPrimaryKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyClauseContext)
}

func (s *EngineClauseContext) AllSampleByClause() []ISampleByClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISampleByClauseContext)(nil)).Elem())
	var tst = make([]ISampleByClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISampleByClauseContext)
		}
	}

	return tst
}

func (s *EngineClauseContext) SampleByClause(i int) ISampleByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampleByClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISampleByClauseContext)
}

func (s *EngineClauseContext) AllTtlClause() []ITtlClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITtlClauseContext)(nil)).Elem())
	var tst = make([]ITtlClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITtlClauseContext)
		}
	}

	return tst
}

func (s *EngineClauseContext) TtlClause(i int) ITtlClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITtlClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITtlClauseContext)
}

func (s *EngineClauseContext) AllSettingsClause() []ISettingsClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISettingsClauseContext)(nil)).Elem())
	var tst = make([]ISettingsClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISettingsClauseContext)
		}
	}

	return tst
}

func (s *EngineClauseContext) SettingsClause(i int) ISettingsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISettingsClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISettingsClauseContext)
}

func (s *EngineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterEngineClause(s)
	}
}

func (s *EngineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitEngineClause(s)
	}
}

func (p *ClickHouseParser) EngineClause() (localctx IEngineClauseContext) {
	localctx = NewEngineClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ClickHouseParserRULE_engineClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.EngineExpr()
	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(853)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
			case 1:
				p.SetState(829)

				if !(!localctx.(*EngineClauseContext).clauses["orderByClause"]) {
					panic(antlr.NewFailedPredicateException(p, "!$clauses[\"orderByClause\"]", ""))
				}
				{
					p.SetState(830)
					p.OrderByClause()
				}
				localctx.(*EngineClauseContext).clauses["orderByClause"] = true

			case 2:
				p.SetState(833)

				if !(!localctx.(*EngineClauseContext).clauses["partitionByClause"]) {
					panic(antlr.NewFailedPredicateException(p, "!$clauses[\"partitionByClause\"]", ""))
				}
				{
					p.SetState(834)
					p.PartitionByClause()
				}
				localctx.(*EngineClauseContext).clauses["partitionByClause"] = true

			case 3:
				p.SetState(837)

				if !(!localctx.(*EngineClauseContext).clauses["primaryKeyClause"]) {
					panic(antlr.NewFailedPredicateException(p, "!$clauses[\"primaryKeyClause\"]", ""))
				}
				{
					p.SetState(838)
					p.PrimaryKeyClause()
				}
				localctx.(*EngineClauseContext).clauses["primaryKeyClause"] = true

			case 4:
				p.SetState(841)

				if !(!localctx.(*EngineClauseContext).clauses["sampleByClause"]) {
					panic(antlr.NewFailedPredicateException(p, "!$clauses[\"sampleByClause\"]", ""))
				}
				{
					p.SetState(842)
					p.SampleByClause()
				}
				localctx.(*EngineClauseContext).clauses["sampleByClause"] = true

			case 5:
				p.SetState(845)

				if !(!localctx.(*EngineClauseContext).clauses["ttlClause"]) {
					panic(antlr.NewFailedPredicateException(p, "!$clauses[\"ttlClause\"]", ""))
				}
				{
					p.SetState(846)
					p.TtlClause()
				}
				localctx.(*EngineClauseContext).clauses["ttlClause"] = true

			case 6:
				p.SetState(849)

				if !(!localctx.(*EngineClauseContext).clauses["settingsClause"]) {
					panic(antlr.NewFailedPredicateException(p, "!$clauses[\"settingsClause\"]", ""))
				}
				{
					p.SetState(850)
					p.SettingsClause()
				}
				localctx.(*EngineClauseContext).clauses["settingsClause"] = true

			}

		}
		p.SetState(857)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())
	}

	return localctx
}

// IPartitionByClauseContext is an interface to support dynamic dispatch.
type IPartitionByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionByClauseContext differentiates from other interfaces.
	IsPartitionByClauseContext()
}

type PartitionByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionByClauseContext() *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_partitionByClause
	return p
}

func (*PartitionByClauseContext) IsPartitionByClauseContext() {}

func NewPartitionByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_partitionByClause

	return p
}

func (s *PartitionByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionByClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPARTITION, 0)
}

func (s *PartitionByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *PartitionByClauseContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *PartitionByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterPartitionByClause(s)
	}
}

func (s *PartitionByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitPartitionByClause(s)
	}
}

func (p *ClickHouseParser) PartitionByClause() (localctx IPartitionByClauseContext) {
	localctx = NewPartitionByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ClickHouseParserRULE_partitionByClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(858)
		p.Match(ClickHouseParserPARTITION)
	}
	{
		p.SetState(859)
		p.Match(ClickHouseParserBY)
	}
	{
		p.SetState(860)
		p.columnExpr(0)
	}

	return localctx
}

// IPrimaryKeyClauseContext is an interface to support dynamic dispatch.
type IPrimaryKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryKeyClauseContext differentiates from other interfaces.
	IsPrimaryKeyClauseContext()
}

type PrimaryKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyClauseContext() *PrimaryKeyClauseContext {
	var p = new(PrimaryKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_primaryKeyClause
	return p
}

func (*PrimaryKeyClauseContext) IsPrimaryKeyClauseContext() {}

func NewPrimaryKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyClauseContext {
	var p = new(PrimaryKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_primaryKeyClause

	return p
}

func (s *PrimaryKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyClauseContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRIMARY, 0)
}

func (s *PrimaryKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKEY, 0)
}

func (s *PrimaryKeyClauseContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *PrimaryKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterPrimaryKeyClause(s)
	}
}

func (s *PrimaryKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitPrimaryKeyClause(s)
	}
}

func (p *ClickHouseParser) PrimaryKeyClause() (localctx IPrimaryKeyClauseContext) {
	localctx = NewPrimaryKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ClickHouseParserRULE_primaryKeyClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(862)
		p.Match(ClickHouseParserPRIMARY)
	}
	{
		p.SetState(863)
		p.Match(ClickHouseParserKEY)
	}
	{
		p.SetState(864)
		p.columnExpr(0)
	}

	return localctx
}

// ISampleByClauseContext is an interface to support dynamic dispatch.
type ISampleByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSampleByClauseContext differentiates from other interfaces.
	IsSampleByClauseContext()
}

type SampleByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleByClauseContext() *SampleByClauseContext {
	var p = new(SampleByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_sampleByClause
	return p
}

func (*SampleByClauseContext) IsSampleByClauseContext() {}

func NewSampleByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleByClauseContext {
	var p = new(SampleByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_sampleByClause

	return p
}

func (s *SampleByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleByClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSAMPLE, 0)
}

func (s *SampleByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *SampleByClauseContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *SampleByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSampleByClause(s)
	}
}

func (s *SampleByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSampleByClause(s)
	}
}

func (p *ClickHouseParser) SampleByClause() (localctx ISampleByClauseContext) {
	localctx = NewSampleByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ClickHouseParserRULE_sampleByClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		p.Match(ClickHouseParserSAMPLE)
	}
	{
		p.SetState(867)
		p.Match(ClickHouseParserBY)
	}
	{
		p.SetState(868)
		p.columnExpr(0)
	}

	return localctx
}

// ITtlClauseContext is an interface to support dynamic dispatch.
type ITtlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTtlClauseContext differentiates from other interfaces.
	IsTtlClauseContext()
}

type TtlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtlClauseContext() *TtlClauseContext {
	var p = new(TtlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_ttlClause
	return p
}

func (*TtlClauseContext) IsTtlClauseContext() {}

func NewTtlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtlClauseContext {
	var p = new(TtlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_ttlClause

	return p
}

func (s *TtlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TtlClauseContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *TtlClauseContext) AllTtlExpr() []ITtlExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITtlExprContext)(nil)).Elem())
	var tst = make([]ITtlExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITtlExprContext)
		}
	}

	return tst
}

func (s *TtlClauseContext) TtlExpr(i int) ITtlExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITtlExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITtlExprContext)
}

func (s *TtlClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *TtlClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *TtlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTtlClause(s)
	}
}

func (s *TtlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTtlClause(s)
	}
}

func (p *ClickHouseParser) TtlClause() (localctx ITtlClauseContext) {
	localctx = NewTtlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ClickHouseParserRULE_ttlClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		p.Match(ClickHouseParserTTL)
	}
	{
		p.SetState(871)
		p.TtlExpr()
	}
	p.SetState(876)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(872)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(873)
				p.TtlExpr()
			}

		}
		p.SetState(878)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())
	}

	return localctx
}

// IEngineExprContext is an interface to support dynamic dispatch.
type IEngineExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEngineExprContext differentiates from other interfaces.
	IsEngineExprContext()
}

type EngineExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineExprContext() *EngineExprContext {
	var p = new(EngineExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_engineExpr
	return p
}

func (*EngineExprContext) IsEngineExprContext() {}

func NewEngineExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineExprContext {
	var p = new(EngineExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_engineExpr

	return p
}

func (s *EngineExprContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineExprContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserENGINE, 0)
}

func (s *EngineExprContext) IdentifierOrNull() IIdentifierOrNullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierOrNullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrNullContext)
}

func (s *EngineExprContext) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_SINGLE, 0)
}

func (s *EngineExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *EngineExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *EngineExprContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *EngineExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterEngineExpr(s)
	}
}

func (s *EngineExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitEngineExpr(s)
	}
}

func (p *ClickHouseParser) EngineExpr() (localctx IEngineExprContext) {
	localctx = NewEngineExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ClickHouseParserRULE_engineExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.Match(ClickHouseParserENGINE)
	}
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserEQ_SINGLE {
		{
			p.SetState(880)
			p.Match(ClickHouseParserEQ_SINGLE)
		}

	}
	{
		p.SetState(883)
		p.IdentifierOrNull()
	}
	p.SetState(889)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(884)
			p.Match(ClickHouseParserLPAREN)
		}
		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDAY-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserHOUR-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINF-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMINUTE-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMONTH-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNAN_SQL-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULL_SQL-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96))|(1<<(ClickHouseParserQUARTER-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSECOND-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWEEK-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserYEAR-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160))|(1<<(ClickHouseParserIDENTIFIER-160))|(1<<(ClickHouseParserFLOATING_LITERAL-160))|(1<<(ClickHouseParserOCTAL_LITERAL-160))|(1<<(ClickHouseParserDECIMAL_LITERAL-160))|(1<<(ClickHouseParserHEXADECIMAL_LITERAL-160))|(1<<(ClickHouseParserSTRING_LITERAL-160))|(1<<(ClickHouseParserASTERISK-160)))) != 0) || (((_la-197)&-(0x1f+1)) == 0 && ((1<<uint((_la-197)))&((1<<(ClickHouseParserDASH-197))|(1<<(ClickHouseParserDOT-197))|(1<<(ClickHouseParserLBRACKET-197))|(1<<(ClickHouseParserLPAREN-197))|(1<<(ClickHouseParserPLUS-197)))) != 0) {
			{
				p.SetState(885)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(888)
			p.Match(ClickHouseParserRPAREN)
		}

	}

	return localctx
}

// ITableElementExprContext is an interface to support dynamic dispatch.
type ITableElementExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableElementExprContext differentiates from other interfaces.
	IsTableElementExprContext()
}

type TableElementExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementExprContext() *TableElementExprContext {
	var p = new(TableElementExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableElementExpr
	return p
}

func (*TableElementExprContext) IsTableElementExprContext() {}

func NewTableElementExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementExprContext {
	var p = new(TableElementExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableElementExpr

	return p
}

func (s *TableElementExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementExprContext) CopyFrom(ctx *TableElementExprContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableElementExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableElementExprProjectionContext struct {
	*TableElementExprContext
}

func NewTableElementExprProjectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableElementExprProjectionContext {
	var p = new(TableElementExprProjectionContext)

	p.TableElementExprContext = NewEmptyTableElementExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableElementExprContext))

	return p
}

func (s *TableElementExprProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementExprProjectionContext) PROJECTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROJECTION, 0)
}

func (s *TableElementExprProjectionContext) TableProjectionDfnt() ITableProjectionDfntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableProjectionDfntContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableProjectionDfntContext)
}

func (s *TableElementExprProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableElementExprProjection(s)
	}
}

func (s *TableElementExprProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableElementExprProjection(s)
	}
}

type TableElementExprConstraintContext struct {
	*TableElementExprContext
}

func NewTableElementExprConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableElementExprConstraintContext {
	var p = new(TableElementExprConstraintContext)

	p.TableElementExprContext = NewEmptyTableElementExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableElementExprContext))

	return p
}

func (s *TableElementExprConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementExprConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCONSTRAINT, 0)
}

func (s *TableElementExprConstraintContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableElementExprConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCHECK, 0)
}

func (s *TableElementExprConstraintContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *TableElementExprConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableElementExprConstraint(s)
	}
}

func (s *TableElementExprConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableElementExprConstraint(s)
	}
}

type TableElementExprColumnContext struct {
	*TableElementExprContext
}

func NewTableElementExprColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableElementExprColumnContext {
	var p = new(TableElementExprColumnContext)

	p.TableElementExprContext = NewEmptyTableElementExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableElementExprContext))

	return p
}

func (s *TableElementExprColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementExprColumnContext) TableColumnDfnt() ITableColumnDfntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableColumnDfntContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableColumnDfntContext)
}

func (s *TableElementExprColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableElementExprColumn(s)
	}
}

func (s *TableElementExprColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableElementExprColumn(s)
	}
}

type TableElementExprIndexContext struct {
	*TableElementExprContext
}

func NewTableElementExprIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableElementExprIndexContext {
	var p = new(TableElementExprIndexContext)

	p.TableElementExprContext = NewEmptyTableElementExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableElementExprContext))

	return p
}

func (s *TableElementExprIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementExprIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *TableElementExprIndexContext) TableIndexDfnt() ITableIndexDfntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIndexDfntContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIndexDfntContext)
}

func (s *TableElementExprIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableElementExprIndex(s)
	}
}

func (s *TableElementExprIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableElementExprIndex(s)
	}
}

func (p *ClickHouseParser) TableElementExpr() (localctx ITableElementExprContext) {
	localctx = NewTableElementExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ClickHouseParserRULE_tableElementExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableElementExprColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(891)
			p.TableColumnDfnt()
		}

	case 2:
		localctx = NewTableElementExprConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(892)
			p.Match(ClickHouseParserCONSTRAINT)
		}
		{
			p.SetState(893)
			p.Identifier()
		}
		{
			p.SetState(894)
			p.Match(ClickHouseParserCHECK)
		}
		{
			p.SetState(895)
			p.columnExpr(0)
		}

	case 3:
		localctx = NewTableElementExprIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(897)
			p.Match(ClickHouseParserINDEX)
		}
		{
			p.SetState(898)
			p.TableIndexDfnt()
		}

	case 4:
		localctx = NewTableElementExprProjectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(899)
			p.Match(ClickHouseParserPROJECTION)
		}
		{
			p.SetState(900)
			p.TableProjectionDfnt()
		}

	}

	return localctx
}

// ITableColumnDfntContext is an interface to support dynamic dispatch.
type ITableColumnDfntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableColumnDfntContext differentiates from other interfaces.
	IsTableColumnDfntContext()
}

type TableColumnDfntContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableColumnDfntContext() *TableColumnDfntContext {
	var p = new(TableColumnDfntContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableColumnDfnt
	return p
}

func (*TableColumnDfntContext) IsTableColumnDfntContext() {}

func NewTableColumnDfntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableColumnDfntContext {
	var p = new(TableColumnDfntContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableColumnDfnt

	return p
}

func (s *TableColumnDfntContext) GetParser() antlr.Parser { return s.parser }

func (s *TableColumnDfntContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *TableColumnDfntContext) ColumnTypeExpr() IColumnTypeExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnTypeExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *TableColumnDfntContext) TableColumnPropertyExpr() ITableColumnPropertyExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableColumnPropertyExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableColumnPropertyExprContext)
}

func (s *TableColumnDfntContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMENT, 0)
}

func (s *TableColumnDfntContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *TableColumnDfntContext) CodecExpr() ICodecExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodecExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodecExprContext)
}

func (s *TableColumnDfntContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *TableColumnDfntContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *TableColumnDfntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableColumnDfntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableColumnDfntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableColumnDfnt(s)
	}
}

func (s *TableColumnDfntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableColumnDfnt(s)
	}
}

func (p *ClickHouseParser) TableColumnDfnt() (localctx ITableColumnDfntContext) {
	localctx = NewTableColumnDfntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ClickHouseParserRULE_tableColumnDfnt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(903)
			p.NestedIdentifier()
		}
		{
			p.SetState(904)
			p.ColumnTypeExpr()
		}
		p.SetState(906)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserALIAS || _la == ClickHouseParserDEFAULT || _la == ClickHouseParserMATERIALIZED {
			{
				p.SetState(905)
				p.TableColumnPropertyExpr()
			}

		}
		p.SetState(910)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCOMMENT {
			{
				p.SetState(908)
				p.Match(ClickHouseParserCOMMENT)
			}
			{
				p.SetState(909)
				p.Match(ClickHouseParserSTRING_LITERAL)
			}

		}
		p.SetState(913)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCODEC {
			{
				p.SetState(912)
				p.CodecExpr()
			}

		}
		p.SetState(917)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserTTL {
			{
				p.SetState(915)
				p.Match(ClickHouseParserTTL)
			}
			{
				p.SetState(916)
				p.columnExpr(0)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(919)
			p.NestedIdentifier()
		}
		p.SetState(921)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(920)
				p.ColumnTypeExpr()
			}

		}
		{
			p.SetState(923)
			p.TableColumnPropertyExpr()
		}
		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCOMMENT {
			{
				p.SetState(924)
				p.Match(ClickHouseParserCOMMENT)
			}
			{
				p.SetState(925)
				p.Match(ClickHouseParserSTRING_LITERAL)
			}

		}
		p.SetState(929)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCODEC {
			{
				p.SetState(928)
				p.CodecExpr()
			}

		}
		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserTTL {
			{
				p.SetState(931)
				p.Match(ClickHouseParserTTL)
			}
			{
				p.SetState(932)
				p.columnExpr(0)
			}

		}

	}

	return localctx
}

// ITableColumnPropertyExprContext is an interface to support dynamic dispatch.
type ITableColumnPropertyExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableColumnPropertyExprContext differentiates from other interfaces.
	IsTableColumnPropertyExprContext()
}

type TableColumnPropertyExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableColumnPropertyExprContext() *TableColumnPropertyExprContext {
	var p = new(TableColumnPropertyExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableColumnPropertyExpr
	return p
}

func (*TableColumnPropertyExprContext) IsTableColumnPropertyExprContext() {}

func NewTableColumnPropertyExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableColumnPropertyExprContext {
	var p = new(TableColumnPropertyExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableColumnPropertyExpr

	return p
}

func (s *TableColumnPropertyExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableColumnPropertyExprContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *TableColumnPropertyExprContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEFAULT, 0)
}

func (s *TableColumnPropertyExprContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZED, 0)
}

func (s *TableColumnPropertyExprContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALIAS, 0)
}

func (s *TableColumnPropertyExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableColumnPropertyExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableColumnPropertyExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableColumnPropertyExpr(s)
	}
}

func (s *TableColumnPropertyExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableColumnPropertyExpr(s)
	}
}

func (p *ClickHouseParser) TableColumnPropertyExpr() (localctx ITableColumnPropertyExprContext) {
	localctx = NewTableColumnPropertyExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ClickHouseParserRULE_tableColumnPropertyExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserALIAS || _la == ClickHouseParserDEFAULT || _la == ClickHouseParserMATERIALIZED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(938)
		p.columnExpr(0)
	}

	return localctx
}

// ITableIndexDfntContext is an interface to support dynamic dispatch.
type ITableIndexDfntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableIndexDfntContext differentiates from other interfaces.
	IsTableIndexDfntContext()
}

type TableIndexDfntContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableIndexDfntContext() *TableIndexDfntContext {
	var p = new(TableIndexDfntContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableIndexDfnt
	return p
}

func (*TableIndexDfntContext) IsTableIndexDfntContext() {}

func NewTableIndexDfntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableIndexDfntContext {
	var p = new(TableIndexDfntContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableIndexDfnt

	return p
}

func (s *TableIndexDfntContext) GetParser() antlr.Parser { return s.parser }

func (s *TableIndexDfntContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *TableIndexDfntContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *TableIndexDfntContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTYPE, 0)
}

func (s *TableIndexDfntContext) ColumnTypeExpr() IColumnTypeExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnTypeExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *TableIndexDfntContext) GRANULARITY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGRANULARITY, 0)
}

func (s *TableIndexDfntContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *TableIndexDfntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableIndexDfntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableIndexDfntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableIndexDfnt(s)
	}
}

func (s *TableIndexDfntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableIndexDfnt(s)
	}
}

func (p *ClickHouseParser) TableIndexDfnt() (localctx ITableIndexDfntContext) {
	localctx = NewTableIndexDfntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ClickHouseParserRULE_tableIndexDfnt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(940)
		p.NestedIdentifier()
	}
	{
		p.SetState(941)
		p.columnExpr(0)
	}
	{
		p.SetState(942)
		p.Match(ClickHouseParserTYPE)
	}
	{
		p.SetState(943)
		p.ColumnTypeExpr()
	}
	{
		p.SetState(944)
		p.Match(ClickHouseParserGRANULARITY)
	}
	{
		p.SetState(945)
		p.Match(ClickHouseParserDECIMAL_LITERAL)
	}

	return localctx
}

// ITableProjectionDfntContext is an interface to support dynamic dispatch.
type ITableProjectionDfntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableProjectionDfntContext differentiates from other interfaces.
	IsTableProjectionDfntContext()
}

type TableProjectionDfntContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableProjectionDfntContext() *TableProjectionDfntContext {
	var p = new(TableProjectionDfntContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableProjectionDfnt
	return p
}

func (*TableProjectionDfntContext) IsTableProjectionDfntContext() {}

func NewTableProjectionDfntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableProjectionDfntContext {
	var p = new(TableProjectionDfntContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableProjectionDfnt

	return p
}

func (s *TableProjectionDfntContext) GetParser() antlr.Parser { return s.parser }

func (s *TableProjectionDfntContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *TableProjectionDfntContext) ProjectionSelectStmt() IProjectionSelectStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProjectionSelectStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProjectionSelectStmtContext)
}

func (s *TableProjectionDfntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableProjectionDfntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableProjectionDfntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableProjectionDfnt(s)
	}
}

func (s *TableProjectionDfntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableProjectionDfnt(s)
	}
}

func (p *ClickHouseParser) TableProjectionDfnt() (localctx ITableProjectionDfntContext) {
	localctx = NewTableProjectionDfntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ClickHouseParserRULE_tableProjectionDfnt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(947)
		p.NestedIdentifier()
	}
	{
		p.SetState(948)
		p.ProjectionSelectStmt()
	}

	return localctx
}

// ICodecExprContext is an interface to support dynamic dispatch.
type ICodecExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCodecExprContext differentiates from other interfaces.
	IsCodecExprContext()
}

type CodecExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodecExprContext() *CodecExprContext {
	var p = new(CodecExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_codecExpr
	return p
}

func (*CodecExprContext) IsCodecExprContext() {}

func NewCodecExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodecExprContext {
	var p = new(CodecExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_codecExpr

	return p
}

func (s *CodecExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CodecExprContext) CODEC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCODEC, 0)
}

func (s *CodecExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *CodecExprContext) AllCodecArgExpr() []ICodecArgExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICodecArgExprContext)(nil)).Elem())
	var tst = make([]ICodecArgExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICodecArgExprContext)
		}
	}

	return tst
}

func (s *CodecExprContext) CodecArgExpr(i int) ICodecArgExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodecArgExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICodecArgExprContext)
}

func (s *CodecExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *CodecExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *CodecExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *CodecExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodecExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodecExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCodecExpr(s)
	}
}

func (s *CodecExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCodecExpr(s)
	}
}

func (p *ClickHouseParser) CodecExpr() (localctx ICodecExprContext) {
	localctx = NewCodecExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ClickHouseParserRULE_codecExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.Match(ClickHouseParserCODEC)
	}
	{
		p.SetState(951)
		p.Match(ClickHouseParserLPAREN)
	}
	{
		p.SetState(952)
		p.CodecArgExpr()
	}
	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(953)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(954)
			p.CodecArgExpr()
		}

		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(960)
		p.Match(ClickHouseParserRPAREN)
	}

	return localctx
}

// ICodecArgExprContext is an interface to support dynamic dispatch.
type ICodecArgExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCodecArgExprContext differentiates from other interfaces.
	IsCodecArgExprContext()
}

type CodecArgExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodecArgExprContext() *CodecArgExprContext {
	var p = new(CodecArgExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_codecArgExpr
	return p
}

func (*CodecArgExprContext) IsCodecArgExprContext() {}

func NewCodecArgExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodecArgExprContext {
	var p = new(CodecArgExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_codecArgExpr

	return p
}

func (s *CodecArgExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CodecArgExprContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CodecArgExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *CodecArgExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *CodecArgExprContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *CodecArgExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodecArgExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodecArgExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCodecArgExpr(s)
	}
}

func (s *CodecArgExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCodecArgExpr(s)
	}
}

func (p *ClickHouseParser) CodecArgExpr() (localctx ICodecArgExprContext) {
	localctx = NewCodecArgExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ClickHouseParserRULE_codecArgExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(962)
		p.Identifier()
	}
	p.SetState(968)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserLPAREN {
		{
			p.SetState(963)
			p.Match(ClickHouseParserLPAREN)
		}
		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDAY-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserHOUR-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINF-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMINUTE-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMONTH-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNAN_SQL-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULL_SQL-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96))|(1<<(ClickHouseParserQUARTER-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSECOND-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWEEK-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserYEAR-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160))|(1<<(ClickHouseParserIDENTIFIER-160))|(1<<(ClickHouseParserFLOATING_LITERAL-160))|(1<<(ClickHouseParserOCTAL_LITERAL-160))|(1<<(ClickHouseParserDECIMAL_LITERAL-160))|(1<<(ClickHouseParserHEXADECIMAL_LITERAL-160))|(1<<(ClickHouseParserSTRING_LITERAL-160))|(1<<(ClickHouseParserASTERISK-160)))) != 0) || (((_la-197)&-(0x1f+1)) == 0 && ((1<<uint((_la-197)))&((1<<(ClickHouseParserDASH-197))|(1<<(ClickHouseParserDOT-197))|(1<<(ClickHouseParserLBRACKET-197))|(1<<(ClickHouseParserLPAREN-197))|(1<<(ClickHouseParserPLUS-197)))) != 0) {
			{
				p.SetState(964)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(967)
			p.Match(ClickHouseParserRPAREN)
		}

	}

	return localctx
}

// ITtlExprContext is an interface to support dynamic dispatch.
type ITtlExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTtlExprContext differentiates from other interfaces.
	IsTtlExprContext()
}

type TtlExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtlExprContext() *TtlExprContext {
	var p = new(TtlExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_ttlExpr
	return p
}

func (*TtlExprContext) IsTtlExprContext() {}

func NewTtlExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtlExprContext {
	var p = new(TtlExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_ttlExpr

	return p
}

func (s *TtlExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TtlExprContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *TtlExprContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDELETE, 0)
}

func (s *TtlExprContext) TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, 0)
}

func (s *TtlExprContext) DISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISK, 0)
}

func (s *TtlExprContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *TtlExprContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVOLUME, 0)
}

func (s *TtlExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtlExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtlExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTtlExpr(s)
	}
}

func (s *TtlExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTtlExpr(s)
	}
}

func (p *ClickHouseParser) TtlExpr() (localctx ITtlExprContext) {
	localctx = NewTtlExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ClickHouseParserRULE_ttlExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(970)
		p.columnExpr(0)
	}
	p.SetState(978)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(971)
			p.Match(ClickHouseParserDELETE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(972)
			p.Match(ClickHouseParserTO)
		}
		{
			p.SetState(973)
			p.Match(ClickHouseParserDISK)
		}
		{
			p.SetState(974)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(975)
			p.Match(ClickHouseParserTO)
		}
		{
			p.SetState(976)
			p.Match(ClickHouseParserVOLUME)
		}
		{
			p.SetState(977)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	}

	return localctx
}

// IDescribeStmtContext is an interface to support dynamic dispatch.
type IDescribeStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDescribeStmtContext differentiates from other interfaces.
	IsDescribeStmtContext()
}

type DescribeStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeStmtContext() *DescribeStmtContext {
	var p = new(DescribeStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_describeStmt
	return p
}

func (*DescribeStmtContext) IsDescribeStmtContext() {}

func NewDescribeStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeStmtContext {
	var p = new(DescribeStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_describeStmt

	return p
}

func (s *DescribeStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeStmtContext) TableExpr() ITableExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableExprContext)
}

func (s *DescribeStmtContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESCRIBE, 0)
}

func (s *DescribeStmtContext) DESC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESC, 0)
}

func (s *DescribeStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *DescribeStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescribeStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDescribeStmt(s)
	}
}

func (s *DescribeStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDescribeStmt(s)
	}
}

func (p *ClickHouseParser) DescribeStmt() (localctx IDescribeStmtContext) {
	localctx = NewDescribeStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ClickHouseParserRULE_describeStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(980)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserDESC || _la == ClickHouseParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(982)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(981)
			p.Match(ClickHouseParserTABLE)
		}

	}
	{
		p.SetState(984)
		p.tableExpr(0)
	}

	return localctx
}

// IDropStmtContext is an interface to support dynamic dispatch.
type IDropStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropStmtContext differentiates from other interfaces.
	IsDropStmtContext()
}

type DropStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropStmtContext() *DropStmtContext {
	var p = new(DropStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dropStmt
	return p
}

func (*DropStmtContext) IsDropStmtContext() {}

func NewDropStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStmtContext {
	var p = new(DropStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dropStmt

	return p
}

func (s *DropStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStmtContext) CopyFrom(ctx *DropStmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *DropStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropDatabaseStmtContext struct {
	*DropStmtContext
}

func NewDropDatabaseStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropDatabaseStmtContext {
	var p = new(DropDatabaseStmtContext)

	p.DropStmtContext = NewEmptyDropStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DropStmtContext))

	return p
}

func (s *DropDatabaseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASE, 0)
}

func (s *DropDatabaseStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *DropDatabaseStmtContext) DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDETACH, 0)
}

func (s *DropDatabaseStmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *DropDatabaseStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *DropDatabaseStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *DropDatabaseStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *DropDatabaseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDropDatabaseStmt(s)
	}
}

func (s *DropDatabaseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDropDatabaseStmt(s)
	}
}

type DropTableStmtContext struct {
	*DropStmtContext
}

func NewDropTableStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableStmtContext {
	var p = new(DropTableStmtContext)

	p.DropStmtContext = NewEmptyDropStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DropStmtContext))

	return p
}

func (s *DropTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *DropTableStmtContext) DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDETACH, 0)
}

func (s *DropTableStmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *DropTableStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *DropTableStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *DropTableStmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *DropTableStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *DropTableStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *DropTableStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *DropTableStmtContext) NO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNO, 0)
}

func (s *DropTableStmtContext) DELAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDELAY, 0)
}

func (s *DropTableStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *DropTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDropTableStmt(s)
	}
}

func (s *DropTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDropTableStmt(s)
	}
}

func (p *ClickHouseParser) DropStmt() (localctx IDropStmtContext) {
	localctx = NewDropStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ClickHouseParserRULE_dropStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1017)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDropDatabaseStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(986)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserDETACH || _la == ClickHouseParserDROP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(987)
			p.Match(ClickHouseParserDATABASE)
		}
		p.SetState(990)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(988)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(989)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(992)
			p.DatabaseIdentifier()
		}
		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(993)
				p.ClusterClause()
			}

		}

	case 2:
		localctx = NewDropTableStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(996)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserDETACH || _la == ClickHouseParserDROP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1003)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserDICTIONARY:
			{
				p.SetState(997)
				p.Match(ClickHouseParserDICTIONARY)
			}

		case ClickHouseParserTABLE, ClickHouseParserTEMPORARY:
			p.SetState(999)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserTEMPORARY {
				{
					p.SetState(998)
					p.Match(ClickHouseParserTEMPORARY)
				}

			}
			{
				p.SetState(1001)
				p.Match(ClickHouseParserTABLE)
			}

		case ClickHouseParserVIEW:
			{
				p.SetState(1002)
				p.Match(ClickHouseParserVIEW)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(1007)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1005)
				p.Match(ClickHouseParserIF)
			}
			{
				p.SetState(1006)
				p.Match(ClickHouseParserEXISTS)
			}

		}
		{
			p.SetState(1009)
			p.TableIdentifier()
		}
		p.SetState(1011)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(1010)
				p.ClusterClause()
			}

		}
		p.SetState(1015)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserNO {
			{
				p.SetState(1013)
				p.Match(ClickHouseParserNO)
			}
			{
				p.SetState(1014)
				p.Match(ClickHouseParserDELAY)
			}

		}

	}

	return localctx
}

// IExistsStmtContext is an interface to support dynamic dispatch.
type IExistsStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExistsStmtContext differentiates from other interfaces.
	IsExistsStmtContext()
}

type ExistsStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExistsStmtContext() *ExistsStmtContext {
	var p = new(ExistsStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_existsStmt
	return p
}

func (*ExistsStmtContext) IsExistsStmtContext() {}

func NewExistsStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExistsStmtContext {
	var p = new(ExistsStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_existsStmt

	return p
}

func (s *ExistsStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExistsStmtContext) CopyFrom(ctx *ExistsStmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExistsStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExistsTableStmtContext struct {
	*ExistsStmtContext
}

func NewExistsTableStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsTableStmtContext {
	var p = new(ExistsTableStmtContext)

	p.ExistsStmtContext = NewEmptyExistsStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExistsStmtContext))

	return p
}

func (s *ExistsTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsTableStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *ExistsTableStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ExistsTableStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *ExistsTableStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *ExistsTableStmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *ExistsTableStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *ExistsTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExistsTableStmt(s)
	}
}

func (s *ExistsTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExistsTableStmt(s)
	}
}

type ExistsDatabaseStmtContext struct {
	*ExistsStmtContext
}

func NewExistsDatabaseStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsDatabaseStmtContext {
	var p = new(ExistsDatabaseStmtContext)

	p.ExistsStmtContext = NewEmptyExistsStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExistsStmtContext))

	return p
}

func (s *ExistsDatabaseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsDatabaseStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *ExistsDatabaseStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASE, 0)
}

func (s *ExistsDatabaseStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *ExistsDatabaseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExistsDatabaseStmt(s)
	}
}

func (s *ExistsDatabaseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExistsDatabaseStmt(s)
	}
}

func (p *ClickHouseParser) ExistsStmt() (localctx IExistsStmtContext) {
	localctx = NewExistsStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ClickHouseParserRULE_existsStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1032)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExistsDatabaseStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1019)
			p.Match(ClickHouseParserEXISTS)
		}
		{
			p.SetState(1020)
			p.Match(ClickHouseParserDATABASE)
		}
		{
			p.SetState(1021)
			p.DatabaseIdentifier()
		}

	case 2:
		localctx = NewExistsTableStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1022)
			p.Match(ClickHouseParserEXISTS)
		}
		p.SetState(1029)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1023)
				p.Match(ClickHouseParserDICTIONARY)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 2 {
			p.SetState(1025)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserTEMPORARY {
				{
					p.SetState(1024)
					p.Match(ClickHouseParserTEMPORARY)
				}

			}
			{
				p.SetState(1027)
				p.Match(ClickHouseParserTABLE)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(1028)
				p.Match(ClickHouseParserVIEW)
			}

		}
		{
			p.SetState(1031)
			p.TableIdentifier()
		}

	}

	return localctx
}

// IExplainStmtContext is an interface to support dynamic dispatch.
type IExplainStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplainStmtContext differentiates from other interfaces.
	IsExplainStmtContext()
}

type ExplainStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainStmtContext() *ExplainStmtContext {
	var p = new(ExplainStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_explainStmt
	return p
}

func (*ExplainStmtContext) IsExplainStmtContext() {}

func NewExplainStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainStmtContext {
	var p = new(ExplainStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_explainStmt

	return p
}

func (s *ExplainStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainStmtContext) CopyFrom(ctx *ExplainStmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExplainStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainSyntaxStmtContext struct {
	*ExplainStmtContext
}

func NewExplainSyntaxStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainSyntaxStmtContext {
	var p = new(ExplainSyntaxStmtContext)

	p.ExplainStmtContext = NewEmptyExplainStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExplainStmtContext))

	return p
}

func (s *ExplainSyntaxStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainSyntaxStmtContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXPLAIN, 0)
}

func (s *ExplainSyntaxStmtContext) SYNTAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNTAX, 0)
}

func (s *ExplainSyntaxStmtContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExplainSyntaxStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExplainSyntaxStmt(s)
	}
}

func (s *ExplainSyntaxStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExplainSyntaxStmt(s)
	}
}

type ExplainASTStmtContext struct {
	*ExplainStmtContext
}

func NewExplainASTStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainASTStmtContext {
	var p = new(ExplainASTStmtContext)

	p.ExplainStmtContext = NewEmptyExplainStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExplainStmtContext))

	return p
}

func (s *ExplainASTStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainASTStmtContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXPLAIN, 0)
}

func (s *ExplainASTStmtContext) AST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAST, 0)
}

func (s *ExplainASTStmtContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExplainASTStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExplainASTStmt(s)
	}
}

func (s *ExplainASTStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExplainASTStmt(s)
	}
}

func (p *ClickHouseParser) ExplainStmt() (localctx IExplainStmtContext) {
	localctx = NewExplainStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ClickHouseParserRULE_explainStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1040)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExplainASTStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1034)
			p.Match(ClickHouseParserEXPLAIN)
		}
		{
			p.SetState(1035)
			p.Match(ClickHouseParserAST)
		}
		{
			p.SetState(1036)
			p.Query()
		}

	case 2:
		localctx = NewExplainSyntaxStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1037)
			p.Match(ClickHouseParserEXPLAIN)
		}
		{
			p.SetState(1038)
			p.Match(ClickHouseParserSYNTAX)
		}
		{
			p.SetState(1039)
			p.Query()
		}

	}

	return localctx
}

// IInsertStmtContext is an interface to support dynamic dispatch.
type IInsertStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInsertStmtContext differentiates from other interfaces.
	IsInsertStmtContext()
}

type InsertStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStmtContext() *InsertStmtContext {
	var p = new(InsertStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_insertStmt
	return p
}

func (*InsertStmtContext) IsInsertStmtContext() {}

func NewInsertStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStmtContext {
	var p = new(InsertStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_insertStmt

	return p
}

func (s *InsertStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStmtContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINSERT, 0)
}

func (s *InsertStmtContext) INTO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTO, 0)
}

func (s *InsertStmtContext) DataClause() IDataClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataClauseContext)
}

func (s *InsertStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *InsertStmtContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFUNCTION, 0)
}

func (s *InsertStmtContext) TableFunctionExpr() ITableFunctionExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableFunctionExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableFunctionExprContext)
}

func (s *InsertStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *InsertStmtContext) ColumnsClause() IColumnsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnsClauseContext)
}

func (s *InsertStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterInsertStmt(s)
	}
}

func (s *InsertStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitInsertStmt(s)
	}
}

func (p *ClickHouseParser) InsertStmt() (localctx IInsertStmtContext) {
	localctx = NewInsertStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ClickHouseParserRULE_insertStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1042)
		p.Match(ClickHouseParserINSERT)
	}
	{
		p.SetState(1043)
		p.Match(ClickHouseParserINTO)
	}
	p.SetState(1045)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1044)
			p.Match(ClickHouseParserTABLE)
		}

	}
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1047)
			p.TableIdentifier()
		}

	case 2:
		{
			p.SetState(1048)
			p.Match(ClickHouseParserFUNCTION)
		}
		{
			p.SetState(1049)
			p.TableFunctionExpr()
		}

	}
	p.SetState(1053)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1052)
			p.ColumnsClause()
		}

	}
	{
		p.SetState(1055)
		p.DataClause()
	}

	return localctx
}

// IColumnsClauseContext is an interface to support dynamic dispatch.
type IColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnsClauseContext differentiates from other interfaces.
	IsColumnsClauseContext()
}

type ColumnsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnsClauseContext() *ColumnsClauseContext {
	var p = new(ColumnsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnsClause
	return p
}

func (*ColumnsClauseContext) IsColumnsClauseContext() {}

func NewColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnsClauseContext {
	var p = new(ColumnsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnsClause

	return p
}

func (s *ColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnsClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnsClauseContext) AllNestedIdentifier() []INestedIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem())
	var tst = make([]INestedIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INestedIdentifierContext)
		}
	}

	return tst
}

func (s *ColumnsClauseContext) NestedIdentifier(i int) INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *ColumnsClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnsClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnsClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnsClause(s)
	}
}

func (s *ColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnsClause(s)
	}
}

func (p *ClickHouseParser) ColumnsClause() (localctx IColumnsClauseContext) {
	localctx = NewColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ClickHouseParserRULE_columnsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1057)
		p.Match(ClickHouseParserLPAREN)
	}
	{
		p.SetState(1058)
		p.NestedIdentifier()
	}
	p.SetState(1063)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(1059)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(1060)
			p.NestedIdentifier()
		}

		p.SetState(1065)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1066)
		p.Match(ClickHouseParserRPAREN)
	}

	return localctx
}

// IDataClauseContext is an interface to support dynamic dispatch.
type IDataClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataClauseContext differentiates from other interfaces.
	IsDataClauseContext()
}

type DataClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataClauseContext() *DataClauseContext {
	var p = new(DataClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dataClause
	return p
}

func (*DataClauseContext) IsDataClauseContext() {}

func NewDataClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataClauseContext {
	var p = new(DataClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dataClause

	return p
}

func (s *DataClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataClauseContext) CopyFrom(ctx *DataClauseContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *DataClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DataClauseValuesContext struct {
	*DataClauseContext
}

func NewDataClauseValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DataClauseValuesContext {
	var p = new(DataClauseValuesContext)

	p.DataClauseContext = NewEmptyDataClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataClauseContext))

	return p
}

func (s *DataClauseValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataClauseValuesContext) VALUES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVALUES, 0)
}

func (s *DataClauseValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDataClauseValues(s)
	}
}

func (s *DataClauseValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDataClauseValues(s)
	}
}

type DataClauseFormatContext struct {
	*DataClauseContext
}

func NewDataClauseFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DataClauseFormatContext {
	var p = new(DataClauseFormatContext)

	p.DataClauseContext = NewEmptyDataClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataClauseContext))

	return p
}

func (s *DataClauseFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataClauseFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFORMAT, 0)
}

func (s *DataClauseFormatContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataClauseFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDataClauseFormat(s)
	}
}

func (s *DataClauseFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDataClauseFormat(s)
	}
}

type DataClauseSelectContext struct {
	*DataClauseContext
}

func NewDataClauseSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DataClauseSelectContext {
	var p = new(DataClauseSelectContext)

	p.DataClauseContext = NewEmptyDataClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataClauseContext))

	return p
}

func (s *DataClauseSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataClauseSelectContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectUnionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *DataClauseSelectContext) EOF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEOF, 0)
}

func (s *DataClauseSelectContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSEMICOLON, 0)
}

func (s *DataClauseSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDataClauseSelect(s)
	}
}

func (s *DataClauseSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDataClauseSelect(s)
	}
}

func (p *ClickHouseParser) DataClause() (localctx IDataClauseContext) {
	localctx = NewDataClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ClickHouseParserRULE_dataClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1077)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserFORMAT:
		localctx = NewDataClauseFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1068)
			p.Match(ClickHouseParserFORMAT)
		}
		{
			p.SetState(1069)
			p.Identifier()
		}

	case ClickHouseParserVALUES:
		localctx = NewDataClauseValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1070)
			p.Match(ClickHouseParserVALUES)
		}

	case ClickHouseParserSELECT, ClickHouseParserWITH, ClickHouseParserLPAREN:
		localctx = NewDataClauseSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1071)
			p.SelectUnionStmt()
		}
		p.SetState(1073)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserSEMICOLON {
			{
				p.SetState(1072)
				p.Match(ClickHouseParserSEMICOLON)
			}

		}
		{
			p.SetState(1075)
			p.Match(ClickHouseParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKillStmtContext is an interface to support dynamic dispatch.
type IKillStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKillStmtContext differentiates from other interfaces.
	IsKillStmtContext()
}

type KillStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKillStmtContext() *KillStmtContext {
	var p = new(KillStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_killStmt
	return p
}

func (*KillStmtContext) IsKillStmtContext() {}

func NewKillStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillStmtContext {
	var p = new(KillStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_killStmt

	return p
}

func (s *KillStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *KillStmtContext) CopyFrom(ctx *KillStmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *KillStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KillMutationStmtContext struct {
	*KillStmtContext
}

func NewKillMutationStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillMutationStmtContext {
	var p = new(KillMutationStmtContext)

	p.KillStmtContext = NewEmptyKillStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KillStmtContext))

	return p
}

func (s *KillMutationStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillMutationStmtContext) KILL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKILL, 0)
}

func (s *KillMutationStmtContext) MUTATION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMUTATION, 0)
}

func (s *KillMutationStmtContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *KillMutationStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *KillMutationStmtContext) SYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNC, 0)
}

func (s *KillMutationStmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASYNC, 0)
}

func (s *KillMutationStmtContext) TEST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEST, 0)
}

func (s *KillMutationStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterKillMutationStmt(s)
	}
}

func (s *KillMutationStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitKillMutationStmt(s)
	}
}

func (p *ClickHouseParser) KillStmt() (localctx IKillStmtContext) {
	localctx = NewKillStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ClickHouseParserRULE_killStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewKillMutationStmtContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1079)
		p.Match(ClickHouseParserKILL)
	}
	{
		p.SetState(1080)
		p.Match(ClickHouseParserMUTATION)
	}
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(1081)
			p.ClusterClause()
		}

	}
	{
		p.SetState(1084)
		p.WhereClause()
	}
	p.SetState(1086)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserASYNC || _la == ClickHouseParserSYNC || _la == ClickHouseParserTEST {
		{
			p.SetState(1085)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserASYNC || _la == ClickHouseParserSYNC || _la == ClickHouseParserTEST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IOptimizeStmtContext is an interface to support dynamic dispatch.
type IOptimizeStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptimizeStmtContext differentiates from other interfaces.
	IsOptimizeStmtContext()
}

type OptimizeStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimizeStmtContext() *OptimizeStmtContext {
	var p = new(OptimizeStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_optimizeStmt
	return p
}

func (*OptimizeStmtContext) IsOptimizeStmtContext() {}

func NewOptimizeStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeStmtContext {
	var p = new(OptimizeStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_optimizeStmt

	return p
}

func (s *OptimizeStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeStmtContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOPTIMIZE, 0)
}

func (s *OptimizeStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *OptimizeStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *OptimizeStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *OptimizeStmtContext) PartitionClause() IPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *OptimizeStmtContext) FINAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFINAL, 0)
}

func (s *OptimizeStmtContext) DEDUPLICATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEDUPLICATE, 0)
}

func (s *OptimizeStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterOptimizeStmt(s)
	}
}

func (s *OptimizeStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitOptimizeStmt(s)
	}
}

func (p *ClickHouseParser) OptimizeStmt() (localctx IOptimizeStmtContext) {
	localctx = NewOptimizeStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ClickHouseParserRULE_optimizeStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1088)
		p.Match(ClickHouseParserOPTIMIZE)
	}
	{
		p.SetState(1089)
		p.Match(ClickHouseParserTABLE)
	}
	{
		p.SetState(1090)
		p.TableIdentifier()
	}
	p.SetState(1092)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(1091)
			p.ClusterClause()
		}

	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserPARTITION {
		{
			p.SetState(1094)
			p.PartitionClause()
		}

	}
	p.SetState(1098)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserFINAL {
		{
			p.SetState(1097)
			p.Match(ClickHouseParserFINAL)
		}

	}
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserDEDUPLICATE {
		{
			p.SetState(1100)
			p.Match(ClickHouseParserDEDUPLICATE)
		}

	}

	return localctx
}

// IRenameStmtContext is an interface to support dynamic dispatch.
type IRenameStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRenameStmtContext differentiates from other interfaces.
	IsRenameStmtContext()
}

type RenameStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameStmtContext() *RenameStmtContext {
	var p = new(RenameStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_renameStmt
	return p
}

func (*RenameStmtContext) IsRenameStmtContext() {}

func NewRenameStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameStmtContext {
	var p = new(RenameStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_renameStmt

	return p
}

func (s *RenameStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameStmtContext) RENAME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRENAME, 0)
}

func (s *RenameStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *RenameStmtContext) AllTableIdentifier() []ITableIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem())
	var tst = make([]ITableIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableIdentifierContext)
		}
	}

	return tst
}

func (s *RenameStmtContext) TableIdentifier(i int) ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *RenameStmtContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserTO)
}

func (s *RenameStmtContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, i)
}

func (s *RenameStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *RenameStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *RenameStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *RenameStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterRenameStmt(s)
	}
}

func (s *RenameStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitRenameStmt(s)
	}
}

func (p *ClickHouseParser) RenameStmt() (localctx IRenameStmtContext) {
	localctx = NewRenameStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ClickHouseParserRULE_renameStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1103)
		p.Match(ClickHouseParserRENAME)
	}
	{
		p.SetState(1104)
		p.Match(ClickHouseParserTABLE)
	}
	{
		p.SetState(1105)
		p.TableIdentifier()
	}
	{
		p.SetState(1106)
		p.Match(ClickHouseParserTO)
	}
	{
		p.SetState(1107)
		p.TableIdentifier()
	}
	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(1108)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(1109)
			p.TableIdentifier()
		}
		{
			p.SetState(1110)
			p.Match(ClickHouseParserTO)
		}
		{
			p.SetState(1111)
			p.TableIdentifier()
		}

		p.SetState(1117)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1119)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(1118)
			p.ClusterClause()
		}

	}

	return localctx
}

// IProjectionSelectStmtContext is an interface to support dynamic dispatch.
type IProjectionSelectStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProjectionSelectStmtContext differentiates from other interfaces.
	IsProjectionSelectStmtContext()
}

type ProjectionSelectStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionSelectStmtContext() *ProjectionSelectStmtContext {
	var p = new(ProjectionSelectStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_projectionSelectStmt
	return p
}

func (*ProjectionSelectStmtContext) IsProjectionSelectStmtContext() {}

func NewProjectionSelectStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionSelectStmtContext {
	var p = new(ProjectionSelectStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_projectionSelectStmt

	return p
}

func (s *ProjectionSelectStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionSelectStmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ProjectionSelectStmtContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSELECT, 0)
}

func (s *ProjectionSelectStmtContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ProjectionSelectStmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ProjectionSelectStmtContext) WithClause() IWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *ProjectionSelectStmtContext) GroupByClause() IGroupByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *ProjectionSelectStmtContext) ProjectionOrderByClause() IProjectionOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProjectionOrderByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProjectionOrderByClauseContext)
}

func (s *ProjectionSelectStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionSelectStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionSelectStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterProjectionSelectStmt(s)
	}
}

func (s *ProjectionSelectStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitProjectionSelectStmt(s)
	}
}

func (p *ClickHouseParser) ProjectionSelectStmt() (localctx IProjectionSelectStmtContext) {
	localctx = NewProjectionSelectStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ClickHouseParserRULE_projectionSelectStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		p.Match(ClickHouseParserLPAREN)
	}
	p.SetState(1123)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserWITH {
		{
			p.SetState(1122)
			p.WithClause()
		}

	}
	{
		p.SetState(1125)
		p.Match(ClickHouseParserSELECT)
	}
	{
		p.SetState(1126)
		p.ColumnExprList()
	}
	p.SetState(1128)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserGROUP {
		{
			p.SetState(1127)
			p.GroupByClause()
		}

	}
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserORDER {
		{
			p.SetState(1130)
			p.ProjectionOrderByClause()
		}

	}
	{
		p.SetState(1133)
		p.Match(ClickHouseParserRPAREN)
	}

	return localctx
}

// ISelectUnionStmtContext is an interface to support dynamic dispatch.
type ISelectUnionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectUnionStmtContext differentiates from other interfaces.
	IsSelectUnionStmtContext()
}

type SelectUnionStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectUnionStmtContext() *SelectUnionStmtContext {
	var p = new(SelectUnionStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_selectUnionStmt
	return p
}

func (*SelectUnionStmtContext) IsSelectUnionStmtContext() {}

func NewSelectUnionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectUnionStmtContext {
	var p = new(SelectUnionStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_selectUnionStmt

	return p
}

func (s *SelectUnionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectUnionStmtContext) AllSelectStmtWithParens() []ISelectStmtWithParensContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectStmtWithParensContext)(nil)).Elem())
	var tst = make([]ISelectStmtWithParensContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectStmtWithParensContext)
		}
	}

	return tst
}

func (s *SelectUnionStmtContext) SelectStmtWithParens(i int) ISelectStmtWithParensContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStmtWithParensContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectStmtWithParensContext)
}

func (s *SelectUnionStmtContext) AllUNION() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserUNION)
}

func (s *SelectUnionStmtContext) UNION(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUNION, i)
}

func (s *SelectUnionStmtContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserALL)
}

func (s *SelectUnionStmtContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALL, i)
}

func (s *SelectUnionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectUnionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectUnionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelectUnionStmt(s)
	}
}

func (s *SelectUnionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelectUnionStmt(s)
	}
}

func (p *ClickHouseParser) SelectUnionStmt() (localctx ISelectUnionStmtContext) {
	localctx = NewSelectUnionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ClickHouseParserRULE_selectUnionStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1135)
		p.SelectStmtWithParens()
	}
	p.SetState(1141)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserUNION {
		{
			p.SetState(1136)
			p.Match(ClickHouseParserUNION)
		}
		{
			p.SetState(1137)
			p.Match(ClickHouseParserALL)
		}
		{
			p.SetState(1138)
			p.SelectStmtWithParens()
		}

		p.SetState(1143)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectStmtWithParensContext is an interface to support dynamic dispatch.
type ISelectStmtWithParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectStmtWithParensContext differentiates from other interfaces.
	IsSelectStmtWithParensContext()
}

type SelectStmtWithParensContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStmtWithParensContext() *SelectStmtWithParensContext {
	var p = new(SelectStmtWithParensContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_selectStmtWithParens
	return p
}

func (*SelectStmtWithParensContext) IsSelectStmtWithParensContext() {}

func NewSelectStmtWithParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStmtWithParensContext {
	var p = new(SelectStmtWithParensContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_selectStmtWithParens

	return p
}

func (s *SelectStmtWithParensContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStmtWithParensContext) SelectStmt() ISelectStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectStmtContext)
}

func (s *SelectStmtWithParensContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *SelectStmtWithParensContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectUnionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *SelectStmtWithParensContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *SelectStmtWithParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStmtWithParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStmtWithParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelectStmtWithParens(s)
	}
}

func (s *SelectStmtWithParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelectStmtWithParens(s)
	}
}

func (p *ClickHouseParser) SelectStmtWithParens() (localctx ISelectStmtWithParensContext) {
	localctx = NewSelectStmtWithParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ClickHouseParserRULE_selectStmtWithParens)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1149)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserSELECT, ClickHouseParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1144)
			p.SelectStmt()
		}

	case ClickHouseParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1145)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1146)
			p.SelectUnionStmt()
		}
		{
			p.SetState(1147)
			p.Match(ClickHouseParserRPAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISelectStmtContext is an interface to support dynamic dispatch.
type ISelectStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectStmtContext differentiates from other interfaces.
	IsSelectStmtContext()
}

type SelectStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStmtContext() *SelectStmtContext {
	var p = new(SelectStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_selectStmt
	return p
}

func (*SelectStmtContext) IsSelectStmtContext() {}

func NewSelectStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStmtContext {
	var p = new(SelectStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_selectStmt

	return p
}

func (s *SelectStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStmtContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSELECT, 0)
}

func (s *SelectStmtContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *SelectStmtContext) WithClause() IWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *SelectStmtContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTINCT, 0)
}

func (s *SelectStmtContext) TopClause() ITopClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopClauseContext)
}

func (s *SelectStmtContext) FromClause() IFromClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFromClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *SelectStmtContext) ArrayJoinClause() IArrayJoinClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayJoinClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayJoinClauseContext)
}

func (s *SelectStmtContext) PrewhereClause() IPrewhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrewhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrewhereClauseContext)
}

func (s *SelectStmtContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *SelectStmtContext) GroupByClause() IGroupByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *SelectStmtContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserWITH)
}

func (s *SelectStmtContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, i)
}

func (s *SelectStmtContext) TOTALS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTOTALS, 0)
}

func (s *SelectStmtContext) HavingClause() IHavingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHavingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *SelectStmtContext) OrderByClause() IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SelectStmtContext) LimitByClause() ILimitByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitByClauseContext)
}

func (s *SelectStmtContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SelectStmtContext) SettingsClause() ISettingsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISettingsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISettingsClauseContext)
}

func (s *SelectStmtContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCUBE, 0)
}

func (s *SelectStmtContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROLLUP, 0)
}

func (s *SelectStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelectStmt(s)
	}
}

func (s *SelectStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelectStmt(s)
	}
}

func (p *ClickHouseParser) SelectStmt() (localctx ISelectStmtContext) {
	localctx = NewSelectStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ClickHouseParserRULE_selectStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1152)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserWITH {
		{
			p.SetState(1151)
			p.WithClause()
		}

	}
	{
		p.SetState(1154)
		p.Match(ClickHouseParserSELECT)
	}
	p.SetState(1156)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1155)
			p.Match(ClickHouseParserDISTINCT)
		}

	}
	p.SetState(1159)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1158)
			p.TopClause()
		}

	}
	{
		p.SetState(1161)
		p.ColumnExprList()
	}
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserFROM {
		{
			p.SetState(1162)
			p.FromClause()
		}

	}
	p.SetState(1166)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserARRAY || _la == ClickHouseParserINNER || _la == ClickHouseParserLEFT {
		{
			p.SetState(1165)
			p.ArrayJoinClause()
		}

	}
	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserPREWHERE {
		{
			p.SetState(1168)
			p.PrewhereClause()
		}

	}
	p.SetState(1172)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserWHERE {
		{
			p.SetState(1171)
			p.WhereClause()
		}

	}
	p.SetState(1175)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserGROUP {
		{
			p.SetState(1174)
			p.GroupByClause()
		}

	}
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1177)
			p.Match(ClickHouseParserWITH)
		}
		{
			p.SetState(1178)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserCUBE || _la == ClickHouseParserROLLUP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserWITH {
		{
			p.SetState(1181)
			p.Match(ClickHouseParserWITH)
		}
		{
			p.SetState(1182)
			p.Match(ClickHouseParserTOTALS)
		}

	}
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserHAVING {
		{
			p.SetState(1185)
			p.HavingClause()
		}

	}
	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserORDER {
		{
			p.SetState(1188)
			p.OrderByClause()
		}

	}
	p.SetState(1192)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1191)
			p.LimitByClause()
		}

	}
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserLIMIT {
		{
			p.SetState(1194)
			p.LimitClause()
		}

	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserSETTINGS {
		{
			p.SetState(1197)
			p.SettingsClause()
		}

	}

	return localctx
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_withClause
	return p
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *WithClauseContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (p *ClickHouseParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ClickHouseParserRULE_withClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1200)
		p.Match(ClickHouseParserWITH)
	}
	{
		p.SetState(1201)
		p.ColumnExprList()
	}

	return localctx
}

// ITopClauseContext is an interface to support dynamic dispatch.
type ITopClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopClauseContext differentiates from other interfaces.
	IsTopClauseContext()
}

type TopClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopClauseContext() *TopClauseContext {
	var p = new(TopClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_topClause
	return p
}

func (*TopClauseContext) IsTopClauseContext() {}

func NewTopClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopClauseContext {
	var p = new(TopClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_topClause

	return p
}

func (s *TopClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TopClauseContext) TOP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTOP, 0)
}

func (s *TopClauseContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *TopClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *TopClauseContext) TIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIES, 0)
}

func (s *TopClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTopClause(s)
	}
}

func (s *TopClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTopClause(s)
	}
}

func (p *ClickHouseParser) TopClause() (localctx ITopClauseContext) {
	localctx = NewTopClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ClickHouseParserRULE_topClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1203)
		p.Match(ClickHouseParserTOP)
	}
	{
		p.SetState(1204)
		p.Match(ClickHouseParserDECIMAL_LITERAL)
	}
	p.SetState(1207)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1205)
			p.Match(ClickHouseParserWITH)
		}
		{
			p.SetState(1206)
			p.Match(ClickHouseParserTIES)
		}

	}

	return localctx
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_fromClause
	return p
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *FromClauseContext) JoinExpr() IJoinExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinExprContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (p *ClickHouseParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ClickHouseParserRULE_fromClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1209)
		p.Match(ClickHouseParserFROM)
	}
	{
		p.SetState(1210)
		p.joinExpr(0)
	}

	return localctx
}

// IArrayJoinClauseContext is an interface to support dynamic dispatch.
type IArrayJoinClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayJoinClauseContext differentiates from other interfaces.
	IsArrayJoinClauseContext()
}

type ArrayJoinClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayJoinClauseContext() *ArrayJoinClauseContext {
	var p = new(ArrayJoinClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_arrayJoinClause
	return p
}

func (*ArrayJoinClauseContext) IsArrayJoinClauseContext() {}

func NewArrayJoinClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayJoinClauseContext {
	var p = new(ArrayJoinClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_arrayJoinClause

	return p
}

func (s *ArrayJoinClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayJoinClauseContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserARRAY, 0)
}

func (s *ArrayJoinClauseContext) JOIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJOIN, 0)
}

func (s *ArrayJoinClauseContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ArrayJoinClauseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLEFT, 0)
}

func (s *ArrayJoinClauseContext) INNER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINNER, 0)
}

func (s *ArrayJoinClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayJoinClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayJoinClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterArrayJoinClause(s)
	}
}

func (s *ArrayJoinClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitArrayJoinClause(s)
	}
}

func (p *ClickHouseParser) ArrayJoinClause() (localctx IArrayJoinClauseContext) {
	localctx = NewArrayJoinClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ClickHouseParserRULE_arrayJoinClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1213)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserINNER || _la == ClickHouseParserLEFT {
		{
			p.SetState(1212)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserINNER || _la == ClickHouseParserLEFT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1215)
		p.Match(ClickHouseParserARRAY)
	}
	{
		p.SetState(1216)
		p.Match(ClickHouseParserJOIN)
	}
	{
		p.SetState(1217)
		p.ColumnExprList()
	}

	return localctx
}

// IPrewhereClauseContext is an interface to support dynamic dispatch.
type IPrewhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrewhereClauseContext differentiates from other interfaces.
	IsPrewhereClauseContext()
}

type PrewhereClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrewhereClauseContext() *PrewhereClauseContext {
	var p = new(PrewhereClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_prewhereClause
	return p
}

func (*PrewhereClauseContext) IsPrewhereClauseContext() {}

func NewPrewhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrewhereClauseContext {
	var p = new(PrewhereClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_prewhereClause

	return p
}

func (s *PrewhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrewhereClauseContext) PREWHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPREWHERE, 0)
}

func (s *PrewhereClauseContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *PrewhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrewhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrewhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterPrewhereClause(s)
	}
}

func (s *PrewhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitPrewhereClause(s)
	}
}

func (p *ClickHouseParser) PrewhereClause() (localctx IPrewhereClauseContext) {
	localctx = NewPrewhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ClickHouseParserRULE_prewhereClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1219)
		p.Match(ClickHouseParserPREWHERE)
	}
	{
		p.SetState(1220)
		p.columnExpr(0)
	}

	return localctx
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_whereClause
	return p
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHERE, 0)
}

func (s *WhereClauseContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (p *ClickHouseParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ClickHouseParserRULE_whereClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1222)
		p.Match(ClickHouseParserWHERE)
	}
	{
		p.SetState(1223)
		p.columnExpr(0)
	}

	return localctx
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_groupByClause
	return p
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *GroupByClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *GroupByClauseContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *GroupByClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *GroupByClauseContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCUBE, 0)
}

func (s *GroupByClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROLLUP, 0)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (p *ClickHouseParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ClickHouseParserRULE_groupByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1225)
		p.Match(ClickHouseParserGROUP)
	}
	{
		p.SetState(1226)
		p.Match(ClickHouseParserBY)
	}
	p.SetState(1233)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1227)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserCUBE || _la == ClickHouseParserROLLUP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1228)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1229)
			p.ColumnExprList()
		}
		{
			p.SetState(1230)
			p.Match(ClickHouseParserRPAREN)
		}

	case 2:
		{
			p.SetState(1232)
			p.ColumnExprList()
		}

	}

	return localctx
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_havingClause
	return p
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHAVING, 0)
}

func (s *HavingClauseContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (p *ClickHouseParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ClickHouseParserRULE_havingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1235)
		p.Match(ClickHouseParserHAVING)
	}
	{
		p.SetState(1236)
		p.columnExpr(0)
	}

	return localctx
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_orderByClause
	return p
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *OrderByClauseContext) OrderExprList() IOrderExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderExprListContext)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (p *ClickHouseParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ClickHouseParserRULE_orderByClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1238)
		p.Match(ClickHouseParserORDER)
	}
	{
		p.SetState(1239)
		p.Match(ClickHouseParserBY)
	}
	{
		p.SetState(1240)
		p.OrderExprList()
	}

	return localctx
}

// IProjectionOrderByClauseContext is an interface to support dynamic dispatch.
type IProjectionOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProjectionOrderByClauseContext differentiates from other interfaces.
	IsProjectionOrderByClauseContext()
}

type ProjectionOrderByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionOrderByClauseContext() *ProjectionOrderByClauseContext {
	var p = new(ProjectionOrderByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_projectionOrderByClause
	return p
}

func (*ProjectionOrderByClauseContext) IsProjectionOrderByClauseContext() {}

func NewProjectionOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionOrderByClauseContext {
	var p = new(ProjectionOrderByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_projectionOrderByClause

	return p
}

func (s *ProjectionOrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionOrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserORDER, 0)
}

func (s *ProjectionOrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *ProjectionOrderByClauseContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ProjectionOrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionOrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionOrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterProjectionOrderByClause(s)
	}
}

func (s *ProjectionOrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitProjectionOrderByClause(s)
	}
}

func (p *ClickHouseParser) ProjectionOrderByClause() (localctx IProjectionOrderByClauseContext) {
	localctx = NewProjectionOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ClickHouseParserRULE_projectionOrderByClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1242)
		p.Match(ClickHouseParserORDER)
	}
	{
		p.SetState(1243)
		p.Match(ClickHouseParserBY)
	}
	{
		p.SetState(1244)
		p.ColumnExprList()
	}

	return localctx
}

// ILimitByClauseContext is an interface to support dynamic dispatch.
type ILimitByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitByClauseContext differentiates from other interfaces.
	IsLimitByClauseContext()
}

type LimitByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitByClauseContext() *LimitByClauseContext {
	var p = new(LimitByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_limitByClause
	return p
}

func (*LimitByClauseContext) IsLimitByClauseContext() {}

func NewLimitByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitByClauseContext {
	var p = new(LimitByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_limitByClause

	return p
}

func (s *LimitByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitByClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *LimitByClauseContext) LimitExpr() ILimitExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitExprContext)
}

func (s *LimitByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *LimitByClauseContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *LimitByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLimitByClause(s)
	}
}

func (s *LimitByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLimitByClause(s)
	}
}

func (p *ClickHouseParser) LimitByClause() (localctx ILimitByClauseContext) {
	localctx = NewLimitByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ClickHouseParserRULE_limitByClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1246)
		p.Match(ClickHouseParserLIMIT)
	}
	{
		p.SetState(1247)
		p.LimitExpr()
	}
	{
		p.SetState(1248)
		p.Match(ClickHouseParserBY)
	}
	{
		p.SetState(1249)
		p.ColumnExprList()
	}

	return localctx
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_limitClause
	return p
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *LimitClauseContext) LimitExpr() ILimitExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitExprContext)
}

func (s *LimitClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *LimitClauseContext) TIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIES, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *ClickHouseParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ClickHouseParserRULE_limitClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1251)
		p.Match(ClickHouseParserLIMIT)
	}
	{
		p.SetState(1252)
		p.LimitExpr()
	}
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserWITH {
		{
			p.SetState(1253)
			p.Match(ClickHouseParserWITH)
		}
		{
			p.SetState(1254)
			p.Match(ClickHouseParserTIES)
		}

	}

	return localctx
}

// ISettingsClauseContext is an interface to support dynamic dispatch.
type ISettingsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSettingsClauseContext differentiates from other interfaces.
	IsSettingsClauseContext()
}

type SettingsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySettingsClauseContext() *SettingsClauseContext {
	var p = new(SettingsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_settingsClause
	return p
}

func (*SettingsClauseContext) IsSettingsClauseContext() {}

func NewSettingsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SettingsClauseContext {
	var p = new(SettingsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_settingsClause

	return p
}

func (s *SettingsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SettingsClauseContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETTINGS, 0)
}

func (s *SettingsClauseContext) SettingExprList() ISettingExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISettingExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISettingExprListContext)
}

func (s *SettingsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SettingsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SettingsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSettingsClause(s)
	}
}

func (s *SettingsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSettingsClause(s)
	}
}

func (p *ClickHouseParser) SettingsClause() (localctx ISettingsClauseContext) {
	localctx = NewSettingsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ClickHouseParserRULE_settingsClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1257)
		p.Match(ClickHouseParserSETTINGS)
	}
	{
		p.SetState(1258)
		p.SettingExprList()
	}

	return localctx
}

// IJoinExprContext is an interface to support dynamic dispatch.
type IJoinExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinExprContext differentiates from other interfaces.
	IsJoinExprContext()
}

type JoinExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinExprContext() *JoinExprContext {
	var p = new(JoinExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinExpr
	return p
}

func (*JoinExprContext) IsJoinExprContext() {}

func NewJoinExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinExprContext {
	var p = new(JoinExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_joinExpr

	return p
}

func (s *JoinExprContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinExprContext) CopyFrom(ctx *JoinExprContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *JoinExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type JoinExprOpContext struct {
	*JoinExprContext
}

func NewJoinExprOpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinExprOpContext {
	var p = new(JoinExprOpContext)

	p.JoinExprContext = NewEmptyJoinExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinExprContext))

	return p
}

func (s *JoinExprOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprOpContext) AllJoinExpr() []IJoinExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinExprContext)(nil)).Elem())
	var tst = make([]IJoinExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoinExprContext)
		}
	}

	return tst
}

func (s *JoinExprOpContext) JoinExpr(i int) IJoinExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoinExprContext)
}

func (s *JoinExprOpContext) JOIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJOIN, 0)
}

func (s *JoinExprOpContext) JoinConstraintClause() IJoinConstraintClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinConstraintClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinConstraintClauseContext)
}

func (s *JoinExprOpContext) JoinOp() IJoinOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinOpContext)
}

func (s *JoinExprOpContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGLOBAL, 0)
}

func (s *JoinExprOpContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLOCAL, 0)
}

func (s *JoinExprOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinExprOp(s)
	}
}

func (s *JoinExprOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinExprOp(s)
	}
}

type JoinExprTableContext struct {
	*JoinExprContext
}

func NewJoinExprTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinExprTableContext {
	var p = new(JoinExprTableContext)

	p.JoinExprContext = NewEmptyJoinExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinExprContext))

	return p
}

func (s *JoinExprTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprTableContext) TableExpr() ITableExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableExprContext)
}

func (s *JoinExprTableContext) FINAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFINAL, 0)
}

func (s *JoinExprTableContext) SampleClause() ISampleClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampleClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampleClauseContext)
}

func (s *JoinExprTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinExprTable(s)
	}
}

func (s *JoinExprTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinExprTable(s)
	}
}

type JoinExprParensContext struct {
	*JoinExprContext
}

func NewJoinExprParensContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinExprParensContext {
	var p = new(JoinExprParensContext)

	p.JoinExprContext = NewEmptyJoinExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinExprContext))

	return p
}

func (s *JoinExprParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprParensContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *JoinExprParensContext) JoinExpr() IJoinExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinExprContext)
}

func (s *JoinExprParensContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *JoinExprParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinExprParens(s)
	}
}

func (s *JoinExprParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinExprParens(s)
	}
}

type JoinExprCrossOpContext struct {
	*JoinExprContext
}

func NewJoinExprCrossOpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinExprCrossOpContext {
	var p = new(JoinExprCrossOpContext)

	p.JoinExprContext = NewEmptyJoinExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinExprContext))

	return p
}

func (s *JoinExprCrossOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprCrossOpContext) AllJoinExpr() []IJoinExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinExprContext)(nil)).Elem())
	var tst = make([]IJoinExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoinExprContext)
		}
	}

	return tst
}

func (s *JoinExprCrossOpContext) JoinExpr(i int) IJoinExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoinExprContext)
}

func (s *JoinExprCrossOpContext) JoinOpCross() IJoinOpCrossContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinOpCrossContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinOpCrossContext)
}

func (s *JoinExprCrossOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinExprCrossOp(s)
	}
}

func (s *JoinExprCrossOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinExprCrossOp(s)
	}
}

func (p *ClickHouseParser) JoinExpr() (localctx IJoinExprContext) {
	return p.joinExpr(0)
}

func (p *ClickHouseParser) joinExpr(_p int) (localctx IJoinExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewJoinExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IJoinExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 134
	p.EnterRecursionRule(localctx, 134, ClickHouseParserRULE_joinExpr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1272)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext()) {
	case 1:
		localctx = NewJoinExprTableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1261)
			p.tableExpr(0)
		}
		p.SetState(1263)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1262)
				p.Match(ClickHouseParserFINAL)
			}

		}
		p.SetState(1266)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1265)
				p.SampleClause()
			}

		}

	case 2:
		localctx = NewJoinExprParensContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1268)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1269)
			p.joinExpr(0)
		}
		{
			p.SetState(1270)
			p.Match(ClickHouseParserRPAREN)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1289)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext()) {
			case 1:
				localctx = NewJoinExprCrossOpContext(p, NewJoinExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_joinExpr)
				p.SetState(1274)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1275)
					p.JoinOpCross()
				}
				{
					p.SetState(1276)
					p.joinExpr(4)
				}

			case 2:
				localctx = NewJoinExprOpContext(p, NewJoinExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_joinExpr)
				p.SetState(1278)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				p.SetState(1280)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ClickHouseParserGLOBAL || _la == ClickHouseParserLOCAL {
					{
						p.SetState(1279)
						_la = p.GetTokenStream().LA(1)

						if !(_la == ClickHouseParserGLOBAL || _la == ClickHouseParserLOCAL) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}
				p.SetState(1283)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserALL)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserASOF))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(ClickHouseParserFULL-66))|(1<<(ClickHouseParserINNER-66))|(1<<(ClickHouseParserLEFT-66)))) != 0) || _la == ClickHouseParserRIGHT || _la == ClickHouseParserSEMI {
					{
						p.SetState(1282)
						p.JoinOp()
					}

				}
				{
					p.SetState(1285)
					p.Match(ClickHouseParserJOIN)
				}
				{
					p.SetState(1286)
					p.joinExpr(0)
				}
				{
					p.SetState(1287)
					p.JoinConstraintClause()
				}

			}

		}
		p.SetState(1293)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())
	}

	return localctx
}

// IJoinOpContext is an interface to support dynamic dispatch.
type IJoinOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinOpContext differentiates from other interfaces.
	IsJoinOpContext()
}

type JoinOpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinOpContext() *JoinOpContext {
	var p = new(JoinOpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinOp
	return p
}

func (*JoinOpContext) IsJoinOpContext() {}

func NewJoinOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinOpContext {
	var p = new(JoinOpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_joinOp

	return p
}

func (s *JoinOpContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinOpContext) CopyFrom(ctx *JoinOpContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *JoinOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type JoinOpFullContext struct {
	*JoinOpContext
}

func NewJoinOpFullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinOpFullContext {
	var p = new(JoinOpFullContext)

	p.JoinOpContext = NewEmptyJoinOpContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinOpContext))

	return p
}

func (s *JoinOpFullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpFullContext) FULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFULL, 0)
}

func (s *JoinOpFullContext) OUTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOUTER, 0)
}

func (s *JoinOpFullContext) ALL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALL, 0)
}

func (s *JoinOpFullContext) ANY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANY, 0)
}

func (s *JoinOpFullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinOpFull(s)
	}
}

func (s *JoinOpFullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinOpFull(s)
	}
}

type JoinOpInnerContext struct {
	*JoinOpContext
}

func NewJoinOpInnerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinOpInnerContext {
	var p = new(JoinOpInnerContext)

	p.JoinOpContext = NewEmptyJoinOpContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinOpContext))

	return p
}

func (s *JoinOpInnerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpInnerContext) INNER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINNER, 0)
}

func (s *JoinOpInnerContext) ALL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALL, 0)
}

func (s *JoinOpInnerContext) ANY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANY, 0)
}

func (s *JoinOpInnerContext) ASOF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASOF, 0)
}

func (s *JoinOpInnerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinOpInner(s)
	}
}

func (s *JoinOpInnerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinOpInner(s)
	}
}

type JoinOpLeftRightContext struct {
	*JoinOpContext
}

func NewJoinOpLeftRightContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinOpLeftRightContext {
	var p = new(JoinOpLeftRightContext)

	p.JoinOpContext = NewEmptyJoinOpContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinOpContext))

	return p
}

func (s *JoinOpLeftRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpLeftRightContext) LEFT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLEFT, 0)
}

func (s *JoinOpLeftRightContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRIGHT, 0)
}

func (s *JoinOpLeftRightContext) OUTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOUTER, 0)
}

func (s *JoinOpLeftRightContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSEMI, 0)
}

func (s *JoinOpLeftRightContext) ALL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALL, 0)
}

func (s *JoinOpLeftRightContext) ANTI() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANTI, 0)
}

func (s *JoinOpLeftRightContext) ANY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANY, 0)
}

func (s *JoinOpLeftRightContext) ASOF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASOF, 0)
}

func (s *JoinOpLeftRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinOpLeftRight(s)
	}
}

func (s *JoinOpLeftRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinOpLeftRight(s)
	}
}

func (p *ClickHouseParser) JoinOp() (localctx IJoinOpContext) {
	localctx = NewJoinOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ClickHouseParserRULE_joinOp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1337)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		localctx = NewJoinOpInnerContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1295)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserALL)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserASOF))) != 0 {
				{
					p.SetState(1294)
					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserALL)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserASOF))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(1297)
				p.Match(ClickHouseParserINNER)
			}

		case 2:
			{
				p.SetState(1298)
				p.Match(ClickHouseParserINNER)
			}
			p.SetState(1300)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserALL)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserASOF))) != 0 {
				{
					p.SetState(1299)
					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserALL)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserASOF))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		case 3:
			{
				p.SetState(1302)
				_la = p.GetTokenStream().LA(1)

				if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserALL)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserASOF))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 2:
		localctx = NewJoinOpLeftRightContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1319)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1306)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserALL)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserASOF))) != 0) || _la == ClickHouseParserSEMI {
				{
					p.SetState(1305)
					_la = p.GetTokenStream().LA(1)

					if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserALL)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserASOF))) != 0) || _la == ClickHouseParserSEMI) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(1308)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserLEFT || _la == ClickHouseParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(1310)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserOUTER {
				{
					p.SetState(1309)
					p.Match(ClickHouseParserOUTER)
				}

			}

		case 2:
			{
				p.SetState(1312)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserLEFT || _la == ClickHouseParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(1314)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserOUTER {
				{
					p.SetState(1313)
					p.Match(ClickHouseParserOUTER)
				}

			}
			p.SetState(1317)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserALL)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserASOF))) != 0) || _la == ClickHouseParserSEMI {
				{
					p.SetState(1316)
					_la = p.GetTokenStream().LA(1)

					if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserALL)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserASOF))) != 0) || _la == ClickHouseParserSEMI) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		}

	case 3:
		localctx = NewJoinOpFullContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1335)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1322)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserALL || _la == ClickHouseParserANY {
				{
					p.SetState(1321)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ClickHouseParserALL || _la == ClickHouseParserANY) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(1324)
				p.Match(ClickHouseParserFULL)
			}
			p.SetState(1326)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserOUTER {
				{
					p.SetState(1325)
					p.Match(ClickHouseParserOUTER)
				}

			}

		case 2:
			{
				p.SetState(1328)
				p.Match(ClickHouseParserFULL)
			}
			p.SetState(1330)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserOUTER {
				{
					p.SetState(1329)
					p.Match(ClickHouseParserOUTER)
				}

			}
			p.SetState(1333)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserALL || _la == ClickHouseParserANY {
				{
					p.SetState(1332)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ClickHouseParserALL || _la == ClickHouseParserANY) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		}

	}

	return localctx
}

// IJoinOpCrossContext is an interface to support dynamic dispatch.
type IJoinOpCrossContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinOpCrossContext differentiates from other interfaces.
	IsJoinOpCrossContext()
}

type JoinOpCrossContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinOpCrossContext() *JoinOpCrossContext {
	var p = new(JoinOpCrossContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinOpCross
	return p
}

func (*JoinOpCrossContext) IsJoinOpCrossContext() {}

func NewJoinOpCrossContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinOpCrossContext {
	var p = new(JoinOpCrossContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_joinOpCross

	return p
}

func (s *JoinOpCrossContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinOpCrossContext) CROSS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCROSS, 0)
}

func (s *JoinOpCrossContext) JOIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJOIN, 0)
}

func (s *JoinOpCrossContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGLOBAL, 0)
}

func (s *JoinOpCrossContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLOCAL, 0)
}

func (s *JoinOpCrossContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, 0)
}

func (s *JoinOpCrossContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpCrossContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinOpCrossContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinOpCross(s)
	}
}

func (s *JoinOpCrossContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinOpCross(s)
	}
}

func (p *ClickHouseParser) JoinOpCross() (localctx IJoinOpCrossContext) {
	localctx = NewJoinOpCrossContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ClickHouseParserRULE_joinOpCross)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1345)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserCROSS, ClickHouseParserGLOBAL, ClickHouseParserLOCAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1340)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserGLOBAL || _la == ClickHouseParserLOCAL {
			{
				p.SetState(1339)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserGLOBAL || _la == ClickHouseParserLOCAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1342)
			p.Match(ClickHouseParserCROSS)
		}
		{
			p.SetState(1343)
			p.Match(ClickHouseParserJOIN)
		}

	case ClickHouseParserCOMMA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1344)
			p.Match(ClickHouseParserCOMMA)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinConstraintClauseContext is an interface to support dynamic dispatch.
type IJoinConstraintClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinConstraintClauseContext differentiates from other interfaces.
	IsJoinConstraintClauseContext()
}

type JoinConstraintClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinConstraintClauseContext() *JoinConstraintClauseContext {
	var p = new(JoinConstraintClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinConstraintClause
	return p
}

func (*JoinConstraintClauseContext) IsJoinConstraintClauseContext() {}

func NewJoinConstraintClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinConstraintClauseContext {
	var p = new(JoinConstraintClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_joinConstraintClause

	return p
}

func (s *JoinConstraintClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinConstraintClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserON, 0)
}

func (s *JoinConstraintClauseContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *JoinConstraintClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSING, 0)
}

func (s *JoinConstraintClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *JoinConstraintClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *JoinConstraintClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinConstraintClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinConstraintClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinConstraintClause(s)
	}
}

func (s *JoinConstraintClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinConstraintClause(s)
	}
}

func (p *ClickHouseParser) JoinConstraintClause() (localctx IJoinConstraintClauseContext) {
	localctx = NewJoinConstraintClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ClickHouseParserRULE_joinConstraintClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1356)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1347)
			p.Match(ClickHouseParserON)
		}
		{
			p.SetState(1348)
			p.ColumnExprList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1349)
			p.Match(ClickHouseParserUSING)
		}
		{
			p.SetState(1350)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1351)
			p.ColumnExprList()
		}
		{
			p.SetState(1352)
			p.Match(ClickHouseParserRPAREN)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1354)
			p.Match(ClickHouseParserUSING)
		}
		{
			p.SetState(1355)
			p.ColumnExprList()
		}

	}

	return localctx
}

// ISampleClauseContext is an interface to support dynamic dispatch.
type ISampleClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSampleClauseContext differentiates from other interfaces.
	IsSampleClauseContext()
}

type SampleClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleClauseContext() *SampleClauseContext {
	var p = new(SampleClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_sampleClause
	return p
}

func (*SampleClauseContext) IsSampleClauseContext() {}

func NewSampleClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleClauseContext {
	var p = new(SampleClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_sampleClause

	return p
}

func (s *SampleClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSAMPLE, 0)
}

func (s *SampleClauseContext) AllRatioExpr() []IRatioExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRatioExprContext)(nil)).Elem())
	var tst = make([]IRatioExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRatioExprContext)
		}
	}

	return tst
}

func (s *SampleClauseContext) RatioExpr(i int) IRatioExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRatioExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRatioExprContext)
}

func (s *SampleClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOFFSET, 0)
}

func (s *SampleClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSampleClause(s)
	}
}

func (s *SampleClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSampleClause(s)
	}
}

func (p *ClickHouseParser) SampleClause() (localctx ISampleClauseContext) {
	localctx = NewSampleClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ClickHouseParserRULE_sampleClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1358)
		p.Match(ClickHouseParserSAMPLE)
	}
	{
		p.SetState(1359)
		p.RatioExpr()
	}
	p.SetState(1362)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1360)
			p.Match(ClickHouseParserOFFSET)
		}
		{
			p.SetState(1361)
			p.RatioExpr()
		}

	}

	return localctx
}

// ILimitExprContext is an interface to support dynamic dispatch.
type ILimitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitExprContext differentiates from other interfaces.
	IsLimitExprContext()
}

type LimitExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitExprContext() *LimitExprContext {
	var p = new(LimitExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_limitExpr
	return p
}

func (*LimitExprContext) IsLimitExprContext() {}

func NewLimitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitExprContext {
	var p = new(LimitExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_limitExpr

	return p
}

func (s *LimitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitExprContext) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *LimitExprContext) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *LimitExprContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, 0)
}

func (s *LimitExprContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOFFSET, 0)
}

func (s *LimitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLimitExpr(s)
	}
}

func (s *LimitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLimitExpr(s)
	}
}

func (p *ClickHouseParser) LimitExpr() (localctx ILimitExprContext) {
	localctx = NewLimitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ClickHouseParserRULE_limitExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1364)
		p.columnExpr(0)
	}
	p.SetState(1367)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserOFFSET || _la == ClickHouseParserCOMMA {
		{
			p.SetState(1365)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserOFFSET || _la == ClickHouseParserCOMMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1366)
			p.columnExpr(0)
		}

	}

	return localctx
}

// IOrderExprListContext is an interface to support dynamic dispatch.
type IOrderExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderExprListContext differentiates from other interfaces.
	IsOrderExprListContext()
}

type OrderExprListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderExprListContext() *OrderExprListContext {
	var p = new(OrderExprListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_orderExprList
	return p
}

func (*OrderExprListContext) IsOrderExprListContext() {}

func NewOrderExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderExprListContext {
	var p = new(OrderExprListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_orderExprList

	return p
}

func (s *OrderExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderExprListContext) AllOrderExpr() []IOrderExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderExprContext)(nil)).Elem())
	var tst = make([]IOrderExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderExprContext)
		}
	}

	return tst
}

func (s *OrderExprListContext) OrderExpr(i int) IOrderExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderExprContext)
}

func (s *OrderExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *OrderExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *OrderExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterOrderExprList(s)
	}
}

func (s *OrderExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitOrderExprList(s)
	}
}

func (p *ClickHouseParser) OrderExprList() (localctx IOrderExprListContext) {
	localctx = NewOrderExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ClickHouseParserRULE_orderExprList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1369)
		p.OrderExpr()
	}
	p.SetState(1374)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1370)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(1371)
				p.OrderExpr()
			}

		}
		p.SetState(1376)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext())
	}

	return localctx
}

// IOrderExprContext is an interface to support dynamic dispatch.
type IOrderExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderExprContext differentiates from other interfaces.
	IsOrderExprContext()
}

type OrderExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderExprContext() *OrderExprContext {
	var p = new(OrderExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_orderExpr
	return p
}

func (*OrderExprContext) IsOrderExprContext() {}

func NewOrderExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderExprContext {
	var p = new(OrderExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_orderExpr

	return p
}

func (s *OrderExprContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderExprContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *OrderExprContext) NULLS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNULLS, 0)
}

func (s *OrderExprContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLLATE, 0)
}

func (s *OrderExprContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *OrderExprContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASCENDING, 0)
}

func (s *OrderExprContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESCENDING, 0)
}

func (s *OrderExprContext) DESC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESC, 0)
}

func (s *OrderExprContext) FIRST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFIRST, 0)
}

func (s *OrderExprContext) LAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLAST, 0)
}

func (s *OrderExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterOrderExpr(s)
	}
}

func (s *OrderExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitOrderExpr(s)
	}
}

func (p *ClickHouseParser) OrderExpr() (localctx IOrderExprContext) {
	localctx = NewOrderExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ClickHouseParserRULE_orderExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1377)
		p.columnExpr(0)
	}
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1378)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-11)&-(0x1f+1)) == 0 && ((1<<uint((_la-11)))&((1<<(ClickHouseParserASCENDING-11))|(1<<(ClickHouseParserDESC-11))|(1<<(ClickHouseParserDESCENDING-11)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1383)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1381)
			p.Match(ClickHouseParserNULLS)
		}
		{
			p.SetState(1382)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserFIRST || _la == ClickHouseParserLAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1387)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1385)
			p.Match(ClickHouseParserCOLLATE)
		}
		{
			p.SetState(1386)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	}

	return localctx
}

// IRatioExprContext is an interface to support dynamic dispatch.
type IRatioExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRatioExprContext differentiates from other interfaces.
	IsRatioExprContext()
}

type RatioExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRatioExprContext() *RatioExprContext {
	var p = new(RatioExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_ratioExpr
	return p
}

func (*RatioExprContext) IsRatioExprContext() {}

func NewRatioExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RatioExprContext {
	var p = new(RatioExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_ratioExpr

	return p
}

func (s *RatioExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RatioExprContext) AllNumberLiteral() []INumberLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumberLiteralContext)(nil)).Elem())
	var tst = make([]INumberLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumberLiteralContext)
		}
	}

	return tst
}

func (s *RatioExprContext) NumberLiteral(i int) INumberLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *RatioExprContext) SLASH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSLASH, 0)
}

func (s *RatioExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RatioExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RatioExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterRatioExpr(s)
	}
}

func (s *RatioExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitRatioExpr(s)
	}
}

func (p *ClickHouseParser) RatioExpr() (localctx IRatioExprContext) {
	localctx = NewRatioExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ClickHouseParserRULE_ratioExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1389)
		p.NumberLiteral()
	}
	p.SetState(1392)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1390)
			p.Match(ClickHouseParserSLASH)
		}
		{
			p.SetState(1391)
			p.NumberLiteral()
		}

	}

	return localctx
}

// ISettingExprListContext is an interface to support dynamic dispatch.
type ISettingExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSettingExprListContext differentiates from other interfaces.
	IsSettingExprListContext()
}

type SettingExprListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySettingExprListContext() *SettingExprListContext {
	var p = new(SettingExprListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_settingExprList
	return p
}

func (*SettingExprListContext) IsSettingExprListContext() {}

func NewSettingExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SettingExprListContext {
	var p = new(SettingExprListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_settingExprList

	return p
}

func (s *SettingExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *SettingExprListContext) AllSettingExpr() []ISettingExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISettingExprContext)(nil)).Elem())
	var tst = make([]ISettingExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISettingExprContext)
		}
	}

	return tst
}

func (s *SettingExprListContext) SettingExpr(i int) ISettingExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISettingExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISettingExprContext)
}

func (s *SettingExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *SettingExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *SettingExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SettingExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SettingExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSettingExprList(s)
	}
}

func (s *SettingExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSettingExprList(s)
	}
}

func (p *ClickHouseParser) SettingExprList() (localctx ISettingExprListContext) {
	localctx = NewSettingExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ClickHouseParserRULE_settingExprList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1394)
		p.SettingExpr()
	}
	p.SetState(1399)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 189, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1395)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(1396)
				p.SettingExpr()
			}

		}
		p.SetState(1401)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 189, p.GetParserRuleContext())
	}

	return localctx
}

// ISettingExprContext is an interface to support dynamic dispatch.
type ISettingExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSettingExprContext differentiates from other interfaces.
	IsSettingExprContext()
}

type SettingExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySettingExprContext() *SettingExprContext {
	var p = new(SettingExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_settingExpr
	return p
}

func (*SettingExprContext) IsSettingExprContext() {}

func NewSettingExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SettingExprContext {
	var p = new(SettingExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_settingExpr

	return p
}

func (s *SettingExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SettingExprContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SettingExprContext) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_SINGLE, 0)
}

func (s *SettingExprContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SettingExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SettingExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SettingExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSettingExpr(s)
	}
}

func (s *SettingExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSettingExpr(s)
	}
}

func (p *ClickHouseParser) SettingExpr() (localctx ISettingExprContext) {
	localctx = NewSettingExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ClickHouseParserRULE_settingExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1402)
		p.Identifier()
	}
	{
		p.SetState(1403)
		p.Match(ClickHouseParserEQ_SINGLE)
	}
	{
		p.SetState(1404)
		p.Literal()
	}

	return localctx
}

// ISetStmtContext is an interface to support dynamic dispatch.
type ISetStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetStmtContext differentiates from other interfaces.
	IsSetStmtContext()
}

type SetStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStmtContext() *SetStmtContext {
	var p = new(SetStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_setStmt
	return p
}

func (*SetStmtContext) IsSetStmtContext() {}

func NewSetStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStmtContext {
	var p = new(SetStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_setStmt

	return p
}

func (s *SetStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStmtContext) SET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSET, 0)
}

func (s *SetStmtContext) SettingExprList() ISettingExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISettingExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISettingExprListContext)
}

func (s *SetStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSetStmt(s)
	}
}

func (s *SetStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSetStmt(s)
	}
}

func (p *ClickHouseParser) SetStmt() (localctx ISetStmtContext) {
	localctx = NewSetStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ClickHouseParserRULE_setStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1406)
		p.Match(ClickHouseParserSET)
	}
	{
		p.SetState(1407)
		p.SettingExprList()
	}

	return localctx
}

// IShowStmtContext is an interface to support dynamic dispatch.
type IShowStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShowStmtContext differentiates from other interfaces.
	IsShowStmtContext()
}

type ShowStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStmtContext() *ShowStmtContext {
	var p = new(ShowStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_showStmt
	return p
}

func (*ShowStmtContext) IsShowStmtContext() {}

func NewShowStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStmtContext {
	var p = new(ShowStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_showStmt

	return p
}

func (s *ShowStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStmtContext) CopyFrom(ctx *ShowStmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ShowStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowCreateDatabaseStmtContext struct {
	*ShowStmtContext
}

func NewShowCreateDatabaseStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateDatabaseStmtContext {
	var p = new(ShowCreateDatabaseStmtContext)

	p.ShowStmtContext = NewEmptyShowStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreateDatabaseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDatabaseStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreateDatabaseStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreateDatabaseStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASE, 0)
}

func (s *ShowCreateDatabaseStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *ShowCreateDatabaseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreateDatabaseStmt(s)
	}
}

func (s *ShowCreateDatabaseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreateDatabaseStmt(s)
	}
}

type ShowDatabasesStmtContext struct {
	*ShowStmtContext
}

func NewShowDatabasesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDatabasesStmtContext {
	var p = new(ShowDatabasesStmtContext)

	p.ShowStmtContext = NewEmptyShowStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowDatabasesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabasesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowDatabasesStmtContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASES, 0)
}

func (s *ShowDatabasesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowDatabasesStmt(s)
	}
}

func (s *ShowDatabasesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowDatabasesStmt(s)
	}
}

type ShowCreateTableStmtContext struct {
	*ShowStmtContext
}

func NewShowCreateTableStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateTableStmtContext {
	var p = new(ShowCreateTableStmtContext)

	p.ShowStmtContext = NewEmptyShowStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreateTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreateTableStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreateTableStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ShowCreateTableStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *ShowCreateTableStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *ShowCreateTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreateTableStmt(s)
	}
}

func (s *ShowCreateTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreateTableStmt(s)
	}
}

type ShowTablesStmtContext struct {
	*ShowStmtContext
}

func NewShowTablesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesStmtContext {
	var p = new(ShowTablesStmtContext)

	p.ShowStmtContext = NewEmptyShowStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowTablesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowTablesStmtContext) TABLES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLES, 0)
}

func (s *ShowTablesStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *ShowTablesStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *ShowTablesStmtContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *ShowTablesStmtContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *ShowTablesStmtContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowTablesStmtContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowTablesStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *ShowTablesStmtContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *ShowTablesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowTablesStmt(s)
	}
}

func (s *ShowTablesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowTablesStmt(s)
	}
}

type ShowDictionariesStmtContext struct {
	*ShowStmtContext
}

func NewShowDictionariesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDictionariesStmtContext {
	var p = new(ShowDictionariesStmtContext)

	p.ShowStmtContext = NewEmptyShowStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowDictionariesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDictionariesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowDictionariesStmtContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARIES, 0)
}

func (s *ShowDictionariesStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *ShowDictionariesStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *ShowDictionariesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowDictionariesStmt(s)
	}
}

func (s *ShowDictionariesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowDictionariesStmt(s)
	}
}

type ShowCreateDictionaryStmtContext struct {
	*ShowStmtContext
}

func NewShowCreateDictionaryStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateDictionaryStmtContext {
	var p = new(ShowCreateDictionaryStmtContext)

	p.ShowStmtContext = NewEmptyShowStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreateDictionaryStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDictionaryStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreateDictionaryStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreateDictionaryStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *ShowCreateDictionaryStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ShowCreateDictionaryStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreateDictionaryStmt(s)
	}
}

func (s *ShowCreateDictionaryStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreateDictionaryStmt(s)
	}
}

func (p *ClickHouseParser) ShowStmt() (localctx IShowStmtContext) {
	localctx = NewShowStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ClickHouseParserRULE_showStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1451)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowCreateDatabaseStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1409)
			p.Match(ClickHouseParserSHOW)
		}
		{
			p.SetState(1410)
			p.Match(ClickHouseParserCREATE)
		}
		{
			p.SetState(1411)
			p.Match(ClickHouseParserDATABASE)
		}
		{
			p.SetState(1412)
			p.DatabaseIdentifier()
		}

	case 2:
		localctx = NewShowCreateDictionaryStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1413)
			p.Match(ClickHouseParserSHOW)
		}
		{
			p.SetState(1414)
			p.Match(ClickHouseParserCREATE)
		}
		{
			p.SetState(1415)
			p.Match(ClickHouseParserDICTIONARY)
		}
		{
			p.SetState(1416)
			p.TableIdentifier()
		}

	case 3:
		localctx = NewShowCreateTableStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1417)
			p.Match(ClickHouseParserSHOW)
		}
		{
			p.SetState(1418)
			p.Match(ClickHouseParserCREATE)
		}
		p.SetState(1420)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1419)
				p.Match(ClickHouseParserTEMPORARY)
			}

		}
		p.SetState(1423)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1422)
				p.Match(ClickHouseParserTABLE)
			}

		}
		{
			p.SetState(1425)
			p.TableIdentifier()
		}

	case 4:
		localctx = NewShowDatabasesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1426)
			p.Match(ClickHouseParserSHOW)
		}
		{
			p.SetState(1427)
			p.Match(ClickHouseParserDATABASES)
		}

	case 5:
		localctx = NewShowDictionariesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1428)
			p.Match(ClickHouseParserSHOW)
		}
		{
			p.SetState(1429)
			p.Match(ClickHouseParserDICTIONARIES)
		}
		p.SetState(1432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFROM {
			{
				p.SetState(1430)
				p.Match(ClickHouseParserFROM)
			}
			{
				p.SetState(1431)
				p.DatabaseIdentifier()
			}

		}

	case 6:
		localctx = NewShowTablesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1434)
			p.Match(ClickHouseParserSHOW)
		}
		p.SetState(1436)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserTEMPORARY {
			{
				p.SetState(1435)
				p.Match(ClickHouseParserTEMPORARY)
			}

		}
		{
			p.SetState(1438)
			p.Match(ClickHouseParserTABLES)
		}
		p.SetState(1441)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFROM || _la == ClickHouseParserIN {
			{
				p.SetState(1439)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserFROM || _la == ClickHouseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1440)
				p.DatabaseIdentifier()
			}

		}
		p.SetState(1446)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserLIKE:
			{
				p.SetState(1443)
				p.Match(ClickHouseParserLIKE)
			}
			{
				p.SetState(1444)
				p.Match(ClickHouseParserSTRING_LITERAL)
			}

		case ClickHouseParserWHERE:
			{
				p.SetState(1445)
				p.WhereClause()
			}

		case ClickHouseParserEOF, ClickHouseParserFORMAT, ClickHouseParserINTO, ClickHouseParserLIMIT, ClickHouseParserSEMICOLON:

		default:
		}
		p.SetState(1449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserLIMIT {
			{
				p.SetState(1448)
				p.LimitClause()
			}

		}

	}

	return localctx
}

// ISystemStmtContext is an interface to support dynamic dispatch.
type ISystemStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystemStmtContext differentiates from other interfaces.
	IsSystemStmtContext()
}

type SystemStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemStmtContext() *SystemStmtContext {
	var p = new(SystemStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_systemStmt
	return p
}

func (*SystemStmtContext) IsSystemStmtContext() {}

func NewSystemStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemStmtContext {
	var p = new(SystemStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_systemStmt

	return p
}

func (s *SystemStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemStmtContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYSTEM, 0)
}

func (s *SystemStmtContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFLUSH, 0)
}

func (s *SystemStmtContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTRIBUTED, 0)
}

func (s *SystemStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *SystemStmtContext) LOGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLOGS, 0)
}

func (s *SystemStmtContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRELOAD, 0)
}

func (s *SystemStmtContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARIES, 0)
}

func (s *SystemStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *SystemStmtContext) START() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTART, 0)
}

func (s *SystemStmtContext) STOP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTOP, 0)
}

func (s *SystemStmtContext) SENDS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSENDS, 0)
}

func (s *SystemStmtContext) FETCHES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFETCHES, 0)
}

func (s *SystemStmtContext) MERGES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMERGES, 0)
}

func (s *SystemStmtContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *SystemStmtContext) REPLICATED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLICATED, 0)
}

func (s *SystemStmtContext) SYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNC, 0)
}

func (s *SystemStmtContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLICA, 0)
}

func (s *SystemStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSystemStmt(s)
	}
}

func (s *SystemStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSystemStmt(s)
	}
}

func (p *ClickHouseParser) SystemStmt() (localctx ISystemStmtContext) {
	localctx = NewSystemStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ClickHouseParserRULE_systemStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1453)
			p.Match(ClickHouseParserSYSTEM)
		}
		{
			p.SetState(1454)
			p.Match(ClickHouseParserFLUSH)
		}
		{
			p.SetState(1455)
			p.Match(ClickHouseParserDISTRIBUTED)
		}
		{
			p.SetState(1456)
			p.TableIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1457)
			p.Match(ClickHouseParserSYSTEM)
		}
		{
			p.SetState(1458)
			p.Match(ClickHouseParserFLUSH)
		}
		{
			p.SetState(1459)
			p.Match(ClickHouseParserLOGS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1460)
			p.Match(ClickHouseParserSYSTEM)
		}
		{
			p.SetState(1461)
			p.Match(ClickHouseParserRELOAD)
		}
		{
			p.SetState(1462)
			p.Match(ClickHouseParserDICTIONARIES)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1463)
			p.Match(ClickHouseParserSYSTEM)
		}
		{
			p.SetState(1464)
			p.Match(ClickHouseParserRELOAD)
		}
		{
			p.SetState(1465)
			p.Match(ClickHouseParserDICTIONARY)
		}
		{
			p.SetState(1466)
			p.TableIdentifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1467)
			p.Match(ClickHouseParserSYSTEM)
		}
		{
			p.SetState(1468)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserSTART || _la == ClickHouseParserSTOP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1476)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserDISTRIBUTED:
			{
				p.SetState(1469)
				p.Match(ClickHouseParserDISTRIBUTED)
			}
			{
				p.SetState(1470)
				p.Match(ClickHouseParserSENDS)
			}

		case ClickHouseParserFETCHES:
			{
				p.SetState(1471)
				p.Match(ClickHouseParserFETCHES)
			}

		case ClickHouseParserMERGES, ClickHouseParserTTL:
			p.SetState(1473)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserTTL {
				{
					p.SetState(1472)
					p.Match(ClickHouseParserTTL)
				}

			}
			{
				p.SetState(1475)
				p.Match(ClickHouseParserMERGES)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1478)
			p.TableIdentifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1479)
			p.Match(ClickHouseParserSYSTEM)
		}
		{
			p.SetState(1480)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserSTART || _la == ClickHouseParserSTOP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1481)
			p.Match(ClickHouseParserREPLICATED)
		}
		{
			p.SetState(1482)
			p.Match(ClickHouseParserSENDS)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1483)
			p.Match(ClickHouseParserSYSTEM)
		}
		{
			p.SetState(1484)
			p.Match(ClickHouseParserSYNC)
		}
		{
			p.SetState(1485)
			p.Match(ClickHouseParserREPLICA)
		}
		{
			p.SetState(1486)
			p.TableIdentifier()
		}

	}

	return localctx
}

// ITruncateStmtContext is an interface to support dynamic dispatch.
type ITruncateStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTruncateStmtContext differentiates from other interfaces.
	IsTruncateStmtContext()
}

type TruncateStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateStmtContext() *TruncateStmtContext {
	var p = new(TruncateStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_truncateStmt
	return p
}

func (*TruncateStmtContext) IsTruncateStmtContext() {}

func NewTruncateStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateStmtContext {
	var p = new(TruncateStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_truncateStmt

	return p
}

func (s *TruncateStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateStmtContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRUNCATE, 0)
}

func (s *TruncateStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *TruncateStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *TruncateStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *TruncateStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *TruncateStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *TruncateStmtContext) ClusterClause() IClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *TruncateStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTruncateStmt(s)
	}
}

func (s *TruncateStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTruncateStmt(s)
	}
}

func (p *ClickHouseParser) TruncateStmt() (localctx ITruncateStmtContext) {
	localctx = NewTruncateStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ClickHouseParserRULE_truncateStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1489)
		p.Match(ClickHouseParserTRUNCATE)
	}
	p.SetState(1491)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1490)
			p.Match(ClickHouseParserTEMPORARY)
		}

	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1493)
			p.Match(ClickHouseParserTABLE)
		}

	}
	p.SetState(1498)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1496)
			p.Match(ClickHouseParserIF)
		}
		{
			p.SetState(1497)
			p.Match(ClickHouseParserEXISTS)
		}

	}
	{
		p.SetState(1500)
		p.TableIdentifier()
	}
	p.SetState(1502)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(1501)
			p.ClusterClause()
		}

	}

	return localctx
}

// IUseStmtContext is an interface to support dynamic dispatch.
type IUseStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseStmtContext differentiates from other interfaces.
	IsUseStmtContext()
}

type UseStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseStmtContext() *UseStmtContext {
	var p = new(UseStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_useStmt
	return p
}

func (*UseStmtContext) IsUseStmtContext() {}

func NewUseStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseStmtContext {
	var p = new(UseStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_useStmt

	return p
}

func (s *UseStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *UseStmtContext) USE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSE, 0)
}

func (s *UseStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *UseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterUseStmt(s)
	}
}

func (s *UseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitUseStmt(s)
	}
}

func (p *ClickHouseParser) UseStmt() (localctx IUseStmtContext) {
	localctx = NewUseStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ClickHouseParserRULE_useStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1504)
		p.Match(ClickHouseParserUSE)
	}
	{
		p.SetState(1505)
		p.DatabaseIdentifier()
	}

	return localctx
}

// IWatchStmtContext is an interface to support dynamic dispatch.
type IWatchStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWatchStmtContext differentiates from other interfaces.
	IsWatchStmtContext()
}

type WatchStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWatchStmtContext() *WatchStmtContext {
	var p = new(WatchStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_watchStmt
	return p
}

func (*WatchStmtContext) IsWatchStmtContext() {}

func NewWatchStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WatchStmtContext {
	var p = new(WatchStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_watchStmt

	return p
}

func (s *WatchStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WatchStmtContext) WATCH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWATCH, 0)
}

func (s *WatchStmtContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *WatchStmtContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEVENTS, 0)
}

func (s *WatchStmtContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *WatchStmtContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *WatchStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WatchStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WatchStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWatchStmt(s)
	}
}

func (s *WatchStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWatchStmt(s)
	}
}

func (p *ClickHouseParser) WatchStmt() (localctx IWatchStmtContext) {
	localctx = NewWatchStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ClickHouseParserRULE_watchStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1507)
		p.Match(ClickHouseParserWATCH)
	}
	{
		p.SetState(1508)
		p.TableIdentifier()
	}
	p.SetState(1510)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserEVENTS {
		{
			p.SetState(1509)
			p.Match(ClickHouseParserEVENTS)
		}

	}
	p.SetState(1514)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserLIMIT {
		{
			p.SetState(1512)
			p.Match(ClickHouseParserLIMIT)
		}
		{
			p.SetState(1513)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
		}

	}

	return localctx
}

// IColumnTypeExprContext is an interface to support dynamic dispatch.
type IColumnTypeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnTypeExprContext differentiates from other interfaces.
	IsColumnTypeExprContext()
}

type ColumnTypeExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnTypeExprContext() *ColumnTypeExprContext {
	var p = new(ColumnTypeExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnTypeExpr
	return p
}

func (*ColumnTypeExprContext) IsColumnTypeExprContext() {}

func NewColumnTypeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnTypeExprContext {
	var p = new(ColumnTypeExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnTypeExpr

	return p
}

func (s *ColumnTypeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnTypeExprContext) CopyFrom(ctx *ColumnTypeExprContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ColumnTypeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnTypeExprNestedContext struct {
	*ColumnTypeExprContext
}

func NewColumnTypeExprNestedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprNestedContext {
	var p = new(ColumnTypeExprNestedContext)

	p.ColumnTypeExprContext = NewEmptyColumnTypeExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprNestedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprNestedContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ColumnTypeExprNestedContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprNestedContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnTypeExprNestedContext) AllColumnTypeExpr() []IColumnTypeExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnTypeExprContext)(nil)).Elem())
	var tst = make([]IColumnTypeExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnTypeExprContext)
		}
	}

	return tst
}

func (s *ColumnTypeExprNestedContext) ColumnTypeExpr(i int) IColumnTypeExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnTypeExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *ColumnTypeExprNestedContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnTypeExprNestedContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnTypeExprNestedContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnTypeExprNestedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnTypeExprNested(s)
	}
}

func (s *ColumnTypeExprNestedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnTypeExprNested(s)
	}
}

type ColumnTypeExprParamContext struct {
	*ColumnTypeExprContext
}

func NewColumnTypeExprParamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprParamContext {
	var p = new(ColumnTypeExprParamContext)

	p.ColumnTypeExprContext = NewEmptyColumnTypeExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprParamContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprParamContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnTypeExprParamContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnTypeExprParamContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnTypeExprParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnTypeExprParam(s)
	}
}

func (s *ColumnTypeExprParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnTypeExprParam(s)
	}
}

type ColumnTypeExprSimpleContext struct {
	*ColumnTypeExprContext
}

func NewColumnTypeExprSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprSimpleContext {
	var p = new(ColumnTypeExprSimpleContext)

	p.ColumnTypeExprContext = NewEmptyColumnTypeExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprSimpleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnTypeExprSimple(s)
	}
}

func (s *ColumnTypeExprSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnTypeExprSimple(s)
	}
}

type ColumnTypeExprComplexContext struct {
	*ColumnTypeExprContext
}

func NewColumnTypeExprComplexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprComplexContext {
	var p = new(ColumnTypeExprComplexContext)

	p.ColumnTypeExprContext = NewEmptyColumnTypeExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprComplexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprComplexContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprComplexContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnTypeExprComplexContext) AllColumnTypeExpr() []IColumnTypeExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnTypeExprContext)(nil)).Elem())
	var tst = make([]IColumnTypeExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnTypeExprContext)
		}
	}

	return tst
}

func (s *ColumnTypeExprComplexContext) ColumnTypeExpr(i int) IColumnTypeExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnTypeExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *ColumnTypeExprComplexContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnTypeExprComplexContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnTypeExprComplexContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnTypeExprComplexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnTypeExprComplex(s)
	}
}

func (s *ColumnTypeExprComplexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnTypeExprComplex(s)
	}
}

type ColumnTypeExprEnumContext struct {
	*ColumnTypeExprContext
}

func NewColumnTypeExprEnumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprEnumContext {
	var p = new(ColumnTypeExprEnumContext)

	p.ColumnTypeExprContext = NewEmptyColumnTypeExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprEnumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprEnumContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprEnumContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnTypeExprEnumContext) AllEnumValue() []IEnumValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumValueContext)(nil)).Elem())
	var tst = make([]IEnumValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumValueContext)
		}
	}

	return tst
}

func (s *ColumnTypeExprEnumContext) EnumValue(i int) IEnumValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumValueContext)
}

func (s *ColumnTypeExprEnumContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnTypeExprEnumContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnTypeExprEnumContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnTypeExprEnumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnTypeExprEnum(s)
	}
}

func (s *ColumnTypeExprEnumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnTypeExprEnum(s)
	}
}

func (p *ClickHouseParser) ColumnTypeExpr() (localctx IColumnTypeExprContext) {
	localctx = NewColumnTypeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ClickHouseParserRULE_columnTypeExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1563)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 211, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnTypeExprSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1516)
			p.Identifier()
		}

	case 2:
		localctx = NewColumnTypeExprNestedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1517)
			p.Identifier()
		}
		{
			p.SetState(1518)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1519)
			p.Identifier()
		}
		{
			p.SetState(1520)
			p.ColumnTypeExpr()
		}
		p.SetState(1527)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1521)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(1522)
				p.Identifier()
			}
			{
				p.SetState(1523)
				p.ColumnTypeExpr()
			}

			p.SetState(1529)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1530)
			p.Match(ClickHouseParserRPAREN)
		}

	case 3:
		localctx = NewColumnTypeExprEnumContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1532)
			p.Identifier()
		}
		{
			p.SetState(1533)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1534)
			p.EnumValue()
		}
		p.SetState(1539)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1535)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(1536)
				p.EnumValue()
			}

			p.SetState(1541)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1542)
			p.Match(ClickHouseParserRPAREN)
		}

	case 4:
		localctx = NewColumnTypeExprComplexContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1544)
			p.Identifier()
		}
		{
			p.SetState(1545)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1546)
			p.ColumnTypeExpr()
		}
		p.SetState(1551)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1547)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(1548)
				p.ColumnTypeExpr()
			}

			p.SetState(1553)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1554)
			p.Match(ClickHouseParserRPAREN)
		}

	case 5:
		localctx = NewColumnTypeExprParamContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1556)
			p.Identifier()
		}
		{
			p.SetState(1557)
			p.Match(ClickHouseParserLPAREN)
		}
		p.SetState(1559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDAY-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserHOUR-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINF-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMINUTE-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMONTH-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNAN_SQL-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULL_SQL-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96))|(1<<(ClickHouseParserQUARTER-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSECOND-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWEEK-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserYEAR-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160))|(1<<(ClickHouseParserIDENTIFIER-160))|(1<<(ClickHouseParserFLOATING_LITERAL-160))|(1<<(ClickHouseParserOCTAL_LITERAL-160))|(1<<(ClickHouseParserDECIMAL_LITERAL-160))|(1<<(ClickHouseParserHEXADECIMAL_LITERAL-160))|(1<<(ClickHouseParserSTRING_LITERAL-160))|(1<<(ClickHouseParserASTERISK-160)))) != 0) || (((_la-197)&-(0x1f+1)) == 0 && ((1<<uint((_la-197)))&((1<<(ClickHouseParserDASH-197))|(1<<(ClickHouseParserDOT-197))|(1<<(ClickHouseParserLBRACKET-197))|(1<<(ClickHouseParserLPAREN-197))|(1<<(ClickHouseParserPLUS-197)))) != 0) {
			{
				p.SetState(1558)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(1561)
			p.Match(ClickHouseParserRPAREN)
		}

	}

	return localctx
}

// IColumnExprListContext is an interface to support dynamic dispatch.
type IColumnExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnExprListContext differentiates from other interfaces.
	IsColumnExprListContext()
}

type ColumnExprListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnExprListContext() *ColumnExprListContext {
	var p = new(ColumnExprListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnExprList
	return p
}

func (*ColumnExprListContext) IsColumnExprListContext() {}

func NewColumnExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnExprListContext {
	var p = new(ColumnExprListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnExprList

	return p
}

func (s *ColumnExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnExprListContext) AllColumnsExpr() []IColumnsExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnsExprContext)(nil)).Elem())
	var tst = make([]IColumnsExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnsExprContext)
		}
	}

	return tst
}

func (s *ColumnExprListContext) ColumnsExpr(i int) IColumnsExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnsExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnsExprContext)
}

func (s *ColumnExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprList(s)
	}
}

func (s *ColumnExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprList(s)
	}
}

func (p *ClickHouseParser) ColumnExprList() (localctx IColumnExprListContext) {
	localctx = NewColumnExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ClickHouseParserRULE_columnExprList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1565)
		p.ColumnsExpr()
	}
	p.SetState(1570)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1566)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(1567)
				p.ColumnsExpr()
			}

		}
		p.SetState(1572)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext())
	}

	return localctx
}

// IColumnsExprContext is an interface to support dynamic dispatch.
type IColumnsExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnsExprContext differentiates from other interfaces.
	IsColumnsExprContext()
}

type ColumnsExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnsExprContext() *ColumnsExprContext {
	var p = new(ColumnsExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnsExpr
	return p
}

func (*ColumnsExprContext) IsColumnsExprContext() {}

func NewColumnsExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnsExprContext {
	var p = new(ColumnsExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnsExpr

	return p
}

func (s *ColumnsExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnsExprContext) CopyFrom(ctx *ColumnsExprContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ColumnsExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnsExprColumnContext struct {
	*ColumnsExprContext
}

func NewColumnsExprColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnsExprColumnContext {
	var p = new(ColumnsExprColumnContext)

	p.ColumnsExprContext = NewEmptyColumnsExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnsExprContext))

	return p
}

func (s *ColumnsExprColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprColumnContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnsExprColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnsExprColumn(s)
	}
}

func (s *ColumnsExprColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnsExprColumn(s)
	}
}

type ColumnsExprAsteriskContext struct {
	*ColumnsExprContext
}

func NewColumnsExprAsteriskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnsExprAsteriskContext {
	var p = new(ColumnsExprAsteriskContext)

	p.ColumnsExprContext = NewEmptyColumnsExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnsExprContext))

	return p
}

func (s *ColumnsExprAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASTERISK, 0)
}

func (s *ColumnsExprAsteriskContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ColumnsExprAsteriskContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *ColumnsExprAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnsExprAsterisk(s)
	}
}

func (s *ColumnsExprAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnsExprAsterisk(s)
	}
}

type ColumnsExprSubqueryContext struct {
	*ColumnsExprContext
}

func NewColumnsExprSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnsExprSubqueryContext {
	var p = new(ColumnsExprSubqueryContext)

	p.ColumnsExprContext = NewEmptyColumnsExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnsExprContext))

	return p
}

func (s *ColumnsExprSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprSubqueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnsExprSubqueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectUnionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *ColumnsExprSubqueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnsExprSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnsExprSubquery(s)
	}
}

func (s *ColumnsExprSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnsExprSubquery(s)
	}
}

func (p *ClickHouseParser) ColumnsExpr() (localctx IColumnsExprContext) {
	localctx = NewColumnsExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ClickHouseParserRULE_columnsExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1584)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnsExprAsteriskContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDAY-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserHOUR-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMINUTE-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMONTH-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96))|(1<<(ClickHouseParserQUARTER-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSECOND-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWEEK-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserYEAR-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160))|(1<<(ClickHouseParserIDENTIFIER-160)))) != 0) {
			{
				p.SetState(1573)
				p.TableIdentifier()
			}
			{
				p.SetState(1574)
				p.Match(ClickHouseParserDOT)
			}

		}
		{
			p.SetState(1578)
			p.Match(ClickHouseParserASTERISK)
		}

	case 2:
		localctx = NewColumnsExprSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1579)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1580)
			p.SelectUnionStmt()
		}
		{
			p.SetState(1581)
			p.Match(ClickHouseParserRPAREN)
		}

	case 3:
		localctx = NewColumnsExprColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1583)
			p.columnExpr(0)
		}

	}

	return localctx
}

// IColumnExprContext is an interface to support dynamic dispatch.
type IColumnExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnExprContext differentiates from other interfaces.
	IsColumnExprContext()
}

type ColumnExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnExprContext() *ColumnExprContext {
	var p = new(ColumnExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnExpr
	return p
}

func (*ColumnExprContext) IsColumnExprContext() {}

func NewColumnExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnExprContext {
	var p = new(ColumnExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnExpr

	return p
}

func (s *ColumnExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnExprContext) CopyFrom(ctx *ColumnExprContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ColumnExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnExprTernaryOpContext struct {
	*ColumnExprContext
}

func NewColumnExprTernaryOpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTernaryOpContext {
	var p = new(ColumnExprTernaryOpContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTernaryOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTernaryOpContext) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *ColumnExprTernaryOpContext) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprTernaryOpContext) QUERY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUERY, 0)
}

func (s *ColumnExprTernaryOpContext) COLON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLON, 0)
}

func (s *ColumnExprTernaryOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprTernaryOp(s)
	}
}

func (s *ColumnExprTernaryOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprTernaryOp(s)
	}
}

type ColumnExprAliasContext struct {
	*ColumnExprContext
}

func NewColumnExprAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprAliasContext {
	var p = new(ColumnExprAliasContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprAliasContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprAliasContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *ColumnExprAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *ColumnExprAliasContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExprAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprAlias(s)
	}
}

func (s *ColumnExprAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprAlias(s)
	}
}

type ColumnExprExtractContext struct {
	*ColumnExprContext
}

func NewColumnExprExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprExtractContext {
	var p = new(ColumnExprExtractContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXTRACT, 0)
}

func (s *ColumnExprExtractContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprExtractContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *ColumnExprExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *ColumnExprExtractContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprExtractContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprExtract(s)
	}
}

func (s *ColumnExprExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprExtract(s)
	}
}

type ColumnExprNegateContext struct {
	*ColumnExprContext
}

func NewColumnExprNegateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprNegateContext {
	var p = new(ColumnExprNegateContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprNegateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprNegateContext) DASH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDASH, 0)
}

func (s *ColumnExprNegateContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprNegateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprNegate(s)
	}
}

func (s *ColumnExprNegateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprNegate(s)
	}
}

type ColumnExprSubqueryContext struct {
	*ColumnExprContext
}

func NewColumnExprSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprSubqueryContext {
	var p = new(ColumnExprSubqueryContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprSubqueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprSubqueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectUnionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *ColumnExprSubqueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprSubquery(s)
	}
}

func (s *ColumnExprSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprSubquery(s)
	}
}

type ColumnExprLiteralContext struct {
	*ColumnExprContext
}

func NewColumnExprLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprLiteralContext {
	var p = new(ColumnExprLiteralContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprLiteralContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ColumnExprLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprLiteral(s)
	}
}

func (s *ColumnExprLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprLiteral(s)
	}
}

type ColumnExprArrayContext struct {
	*ColumnExprContext
}

func NewColumnExprArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprArrayContext {
	var p = new(ColumnExprArrayContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprArrayContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLBRACKET, 0)
}

func (s *ColumnExprArrayContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRBRACKET, 0)
}

func (s *ColumnExprArrayContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprArray(s)
	}
}

func (s *ColumnExprArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprArray(s)
	}
}

type ColumnExprSubstringContext struct {
	*ColumnExprContext
}

func NewColumnExprSubstringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprSubstringContext {
	var p = new(ColumnExprSubstringContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprSubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprSubstringContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSUBSTRING, 0)
}

func (s *ColumnExprSubstringContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprSubstringContext) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *ColumnExprSubstringContext) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprSubstringContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *ColumnExprSubstringContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprSubstringContext) FOR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFOR, 0)
}

func (s *ColumnExprSubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprSubstring(s)
	}
}

func (s *ColumnExprSubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprSubstring(s)
	}
}

type ColumnExprCastContext struct {
	*ColumnExprContext
}

func NewColumnExprCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprCastContext {
	var p = new(ColumnExprCastContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprCastContext) CAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCAST, 0)
}

func (s *ColumnExprCastContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprCastContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprCastContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *ColumnExprCastContext) ColumnTypeExpr() IColumnTypeExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnTypeExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *ColumnExprCastContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprCast(s)
	}
}

func (s *ColumnExprCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprCast(s)
	}
}

type ColumnExprOrContext struct {
	*ColumnExprContext
}

func NewColumnExprOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprOrContext {
	var p = new(ColumnExprOrContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprOrContext) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *ColumnExprOrContext) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprOrContext) OR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOR, 0)
}

func (s *ColumnExprOrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprOr(s)
	}
}

func (s *ColumnExprOrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprOr(s)
	}
}

type ColumnExprPrecedence1Context struct {
	*ColumnExprContext
}

func NewColumnExprPrecedence1Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprPrecedence1Context {
	var p = new(ColumnExprPrecedence1Context)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprPrecedence1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprPrecedence1Context) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *ColumnExprPrecedence1Context) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprPrecedence1Context) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASTERISK, 0)
}

func (s *ColumnExprPrecedence1Context) SLASH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSLASH, 0)
}

func (s *ColumnExprPrecedence1Context) PERCENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPERCENT, 0)
}

func (s *ColumnExprPrecedence1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprPrecedence1(s)
	}
}

func (s *ColumnExprPrecedence1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprPrecedence1(s)
	}
}

type ColumnExprPrecedence2Context struct {
	*ColumnExprContext
}

func NewColumnExprPrecedence2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprPrecedence2Context {
	var p = new(ColumnExprPrecedence2Context)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprPrecedence2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprPrecedence2Context) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *ColumnExprPrecedence2Context) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprPrecedence2Context) PLUS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPLUS, 0)
}

func (s *ColumnExprPrecedence2Context) DASH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDASH, 0)
}

func (s *ColumnExprPrecedence2Context) CONCAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCONCAT, 0)
}

func (s *ColumnExprPrecedence2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprPrecedence2(s)
	}
}

func (s *ColumnExprPrecedence2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprPrecedence2(s)
	}
}

type ColumnExprPrecedence3Context struct {
	*ColumnExprContext
}

func NewColumnExprPrecedence3Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprPrecedence3Context {
	var p = new(ColumnExprPrecedence3Context)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprPrecedence3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprPrecedence3Context) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *ColumnExprPrecedence3Context) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprPrecedence3Context) EQ_DOUBLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_DOUBLE, 0)
}

func (s *ColumnExprPrecedence3Context) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_SINGLE, 0)
}

func (s *ColumnExprPrecedence3Context) NOT_EQ() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT_EQ, 0)
}

func (s *ColumnExprPrecedence3Context) LE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLE, 0)
}

func (s *ColumnExprPrecedence3Context) GE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGE, 0)
}

func (s *ColumnExprPrecedence3Context) LT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLT, 0)
}

func (s *ColumnExprPrecedence3Context) GT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGT, 0)
}

func (s *ColumnExprPrecedence3Context) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *ColumnExprPrecedence3Context) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *ColumnExprPrecedence3Context) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *ColumnExprPrecedence3Context) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGLOBAL, 0)
}

func (s *ColumnExprPrecedence3Context) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ColumnExprPrecedence3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprPrecedence3(s)
	}
}

func (s *ColumnExprPrecedence3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprPrecedence3(s)
	}
}

type ColumnExprIntervalContext struct {
	*ColumnExprContext
}

func NewColumnExprIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprIntervalContext {
	var p = new(ColumnExprIntervalContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprIntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTERVAL, 0)
}

func (s *ColumnExprIntervalContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprIntervalContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *ColumnExprIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprInterval(s)
	}
}

func (s *ColumnExprIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprInterval(s)
	}
}

type ColumnExprIsNullContext struct {
	*ColumnExprContext
}

func NewColumnExprIsNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprIsNullContext {
	var p = new(ColumnExprIsNullContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprIsNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprIsNullContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprIsNullContext) IS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIS, 0)
}

func (s *ColumnExprIsNullContext) NULL_SQL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNULL_SQL, 0)
}

func (s *ColumnExprIsNullContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ColumnExprIsNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprIsNull(s)
	}
}

func (s *ColumnExprIsNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprIsNull(s)
	}
}

type ColumnExprTrimContext struct {
	*ColumnExprContext
}

func NewColumnExprTrimContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTrimContext {
	var p = new(ColumnExprTrimContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTrimContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTrimContext) TRIM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRIM, 0)
}

func (s *ColumnExprTrimContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprTrimContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *ColumnExprTrimContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *ColumnExprTrimContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprTrimContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprTrimContext) BOTH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBOTH, 0)
}

func (s *ColumnExprTrimContext) LEADING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLEADING, 0)
}

func (s *ColumnExprTrimContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRAILING, 0)
}

func (s *ColumnExprTrimContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprTrim(s)
	}
}

func (s *ColumnExprTrimContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprTrim(s)
	}
}

type ColumnExprTupleContext struct {
	*ColumnExprContext
}

func NewColumnExprTupleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTupleContext {
	var p = new(ColumnExprTupleContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTupleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprTupleContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprTupleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprTuple(s)
	}
}

func (s *ColumnExprTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprTuple(s)
	}
}

type ColumnExprArrayAccessContext struct {
	*ColumnExprContext
}

func NewColumnExprArrayAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprArrayAccessContext {
	var p = new(ColumnExprArrayAccessContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprArrayAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprArrayAccessContext) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *ColumnExprArrayAccessContext) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprArrayAccessContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLBRACKET, 0)
}

func (s *ColumnExprArrayAccessContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRBRACKET, 0)
}

func (s *ColumnExprArrayAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprArrayAccess(s)
	}
}

func (s *ColumnExprArrayAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprArrayAccess(s)
	}
}

type ColumnExprBetweenContext struct {
	*ColumnExprContext
}

func NewColumnExprBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprBetweenContext {
	var p = new(ColumnExprBetweenContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprBetweenContext) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *ColumnExprBetweenContext) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprBetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBETWEEN, 0)
}

func (s *ColumnExprBetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAND, 0)
}

func (s *ColumnExprBetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ColumnExprBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprBetween(s)
	}
}

func (s *ColumnExprBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprBetween(s)
	}
}

type ColumnExprParensContext struct {
	*ColumnExprContext
}

func NewColumnExprParensContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprParensContext {
	var p = new(ColumnExprParensContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprParensContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprParensContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprParensContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprParens(s)
	}
}

func (s *ColumnExprParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprParens(s)
	}
}

type ColumnExprTimestampContext struct {
	*ColumnExprContext
}

func NewColumnExprTimestampContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTimestampContext {
	var p = new(ColumnExprTimestampContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTimestampContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIMESTAMP, 0)
}

func (s *ColumnExprTimestampContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *ColumnExprTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprTimestamp(s)
	}
}

func (s *ColumnExprTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprTimestamp(s)
	}
}

type ColumnExprAndContext struct {
	*ColumnExprContext
}

func NewColumnExprAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprAndContext {
	var p = new(ColumnExprAndContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprAndContext) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *ColumnExprAndContext) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprAndContext) AND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAND, 0)
}

func (s *ColumnExprAndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprAnd(s)
	}
}

func (s *ColumnExprAndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprAnd(s)
	}
}

type ColumnExprTupleAccessContext struct {
	*ColumnExprContext
}

func NewColumnExprTupleAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTupleAccessContext {
	var p = new(ColumnExprTupleAccessContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTupleAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTupleAccessContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprTupleAccessContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *ColumnExprTupleAccessContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *ColumnExprTupleAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprTupleAccess(s)
	}
}

func (s *ColumnExprTupleAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprTupleAccess(s)
	}
}

type ColumnExprCaseContext struct {
	*ColumnExprContext
}

func NewColumnExprCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprCaseContext {
	var p = new(ColumnExprCaseContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCASE, 0)
}

func (s *ColumnExprCaseContext) END() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEND, 0)
}

func (s *ColumnExprCaseContext) AllColumnExpr() []IColumnExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnExprContext)(nil)).Elem())
	var tst = make([]IColumnExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnExprContext)
		}
	}

	return tst
}

func (s *ColumnExprCaseContext) ColumnExpr(i int) IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprCaseContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserWHEN)
}

func (s *ColumnExprCaseContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHEN, i)
}

func (s *ColumnExprCaseContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserTHEN)
}

func (s *ColumnExprCaseContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTHEN, i)
}

func (s *ColumnExprCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserELSE, 0)
}

func (s *ColumnExprCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprCase(s)
	}
}

func (s *ColumnExprCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprCase(s)
	}
}

type ColumnExprDateContext struct {
	*ColumnExprContext
}

func NewColumnExprDateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprDateContext {
	var p = new(ColumnExprDateContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprDateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprDateContext) DATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATE, 0)
}

func (s *ColumnExprDateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *ColumnExprDateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprDate(s)
	}
}

func (s *ColumnExprDateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprDate(s)
	}
}

type ColumnExprNotContext struct {
	*ColumnExprContext
}

func NewColumnExprNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprNotContext {
	var p = new(ColumnExprNotContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ColumnExprNotContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprNot(s)
	}
}

func (s *ColumnExprNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprNot(s)
	}
}

type ColumnExprIdentifierContext struct {
	*ColumnExprContext
}

func NewColumnExprIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprIdentifierContext {
	var p = new(ColumnExprIdentifierContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprIdentifierContext) ColumnIdentifier() IColumnIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnIdentifierContext)
}

func (s *ColumnExprIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprIdentifier(s)
	}
}

func (s *ColumnExprIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprIdentifier(s)
	}
}

type ColumnExprFunctionContext struct {
	*ColumnExprContext
}

func NewColumnExprFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprFunctionContext {
	var p = new(ColumnExprFunctionContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprFunctionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExprFunctionContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserLPAREN)
}

func (s *ColumnExprFunctionContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, i)
}

func (s *ColumnExprFunctionContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserRPAREN)
}

func (s *ColumnExprFunctionContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, i)
}

func (s *ColumnExprFunctionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTINCT, 0)
}

func (s *ColumnExprFunctionContext) ColumnArgList() IColumnArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnArgListContext)
}

func (s *ColumnExprFunctionContext) ColumnExprList() IColumnExprListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprFunction(s)
	}
}

func (s *ColumnExprFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprFunction(s)
	}
}

type ColumnExprAsteriskContext struct {
	*ColumnExprContext
}

func NewColumnExprAsteriskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprAsteriskContext {
	var p = new(ColumnExprAsteriskContext)

	p.ColumnExprContext = NewEmptyColumnExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASTERISK, 0)
}

func (s *ColumnExprAsteriskContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ColumnExprAsteriskContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *ColumnExprAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprAsterisk(s)
	}
}

func (s *ColumnExprAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprAsterisk(s)
	}
}

func (p *ClickHouseParser) ColumnExpr() (localctx IColumnExprContext) {
	return p.columnExpr(0)
}

func (p *ClickHouseParser) columnExpr(_p int) (localctx IColumnExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewColumnExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IColumnExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 174
	p.EnterRecursionRule(localctx, 174, ClickHouseParserRULE_columnExpr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1693)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 225, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnExprCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1587)
			p.Match(ClickHouseParserCASE)
		}
		p.SetState(1589)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1588)
				p.columnExpr(0)
			}

		}
		p.SetState(1596)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ClickHouseParserWHEN {
			{
				p.SetState(1591)
				p.Match(ClickHouseParserWHEN)
			}
			{
				p.SetState(1592)
				p.columnExpr(0)
			}
			{
				p.SetState(1593)
				p.Match(ClickHouseParserTHEN)
			}
			{
				p.SetState(1594)
				p.columnExpr(0)
			}

			p.SetState(1598)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1602)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserELSE {
			{
				p.SetState(1600)
				p.Match(ClickHouseParserELSE)
			}
			{
				p.SetState(1601)
				p.columnExpr(0)
			}

		}
		{
			p.SetState(1604)
			p.Match(ClickHouseParserEND)
		}

	case 2:
		localctx = NewColumnExprCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1606)
			p.Match(ClickHouseParserCAST)
		}
		{
			p.SetState(1607)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1608)
			p.columnExpr(0)
		}
		{
			p.SetState(1609)
			p.Match(ClickHouseParserAS)
		}
		{
			p.SetState(1610)
			p.ColumnTypeExpr()
		}
		{
			p.SetState(1611)
			p.Match(ClickHouseParserRPAREN)
		}

	case 3:
		localctx = NewColumnExprDateContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1613)
			p.Match(ClickHouseParserDATE)
		}
		{
			p.SetState(1614)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	case 4:
		localctx = NewColumnExprExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1615)
			p.Match(ClickHouseParserEXTRACT)
		}
		{
			p.SetState(1616)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1617)
			p.Interval()
		}
		{
			p.SetState(1618)
			p.Match(ClickHouseParserFROM)
		}
		{
			p.SetState(1619)
			p.columnExpr(0)
		}
		{
			p.SetState(1620)
			p.Match(ClickHouseParserRPAREN)
		}

	case 5:
		localctx = NewColumnExprIntervalContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1622)
			p.Match(ClickHouseParserINTERVAL)
		}
		{
			p.SetState(1623)
			p.columnExpr(0)
		}
		{
			p.SetState(1624)
			p.Interval()
		}

	case 6:
		localctx = NewColumnExprSubstringContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1626)
			p.Match(ClickHouseParserSUBSTRING)
		}
		{
			p.SetState(1627)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1628)
			p.columnExpr(0)
		}
		{
			p.SetState(1629)
			p.Match(ClickHouseParserFROM)
		}
		{
			p.SetState(1630)
			p.columnExpr(0)
		}
		p.SetState(1633)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFOR {
			{
				p.SetState(1631)
				p.Match(ClickHouseParserFOR)
			}
			{
				p.SetState(1632)
				p.columnExpr(0)
			}

		}
		{
			p.SetState(1635)
			p.Match(ClickHouseParserRPAREN)
		}

	case 7:
		localctx = NewColumnExprTimestampContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1637)
			p.Match(ClickHouseParserTIMESTAMP)
		}
		{
			p.SetState(1638)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	case 8:
		localctx = NewColumnExprTrimContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1639)
			p.Match(ClickHouseParserTRIM)
		}
		{
			p.SetState(1640)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1641)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserBOTH || _la == ClickHouseParserLEADING || _la == ClickHouseParserTRAILING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1642)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}
		{
			p.SetState(1643)
			p.Match(ClickHouseParserFROM)
		}
		{
			p.SetState(1644)
			p.columnExpr(0)
		}
		{
			p.SetState(1645)
			p.Match(ClickHouseParserRPAREN)
		}

	case 9:
		localctx = NewColumnExprFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1647)
			p.Identifier()
		}
		p.SetState(1653)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 220, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1648)
				p.Match(ClickHouseParserLPAREN)
			}
			p.SetState(1650)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDAY-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserHOUR-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINF-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMINUTE-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMONTH-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNAN_SQL-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULL_SQL-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96))|(1<<(ClickHouseParserQUARTER-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSECOND-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWEEK-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserYEAR-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160))|(1<<(ClickHouseParserIDENTIFIER-160))|(1<<(ClickHouseParserFLOATING_LITERAL-160))|(1<<(ClickHouseParserOCTAL_LITERAL-160))|(1<<(ClickHouseParserDECIMAL_LITERAL-160))|(1<<(ClickHouseParserHEXADECIMAL_LITERAL-160))|(1<<(ClickHouseParserSTRING_LITERAL-160))|(1<<(ClickHouseParserASTERISK-160)))) != 0) || (((_la-197)&-(0x1f+1)) == 0 && ((1<<uint((_la-197)))&((1<<(ClickHouseParserDASH-197))|(1<<(ClickHouseParserDOT-197))|(1<<(ClickHouseParserLBRACKET-197))|(1<<(ClickHouseParserLPAREN-197))|(1<<(ClickHouseParserPLUS-197)))) != 0) {
				{
					p.SetState(1649)
					p.ColumnExprList()
				}

			}
			{
				p.SetState(1652)
				p.Match(ClickHouseParserRPAREN)
			}

		}
		{
			p.SetState(1655)
			p.Match(ClickHouseParserLPAREN)
		}
		p.SetState(1657)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 221, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1656)
				p.Match(ClickHouseParserDISTINCT)
			}

		}
		p.SetState(1660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDAY-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserHOUR-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINF-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMINUTE-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMONTH-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNAN_SQL-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULL_SQL-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96))|(1<<(ClickHouseParserQUARTER-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSECOND-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWEEK-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserYEAR-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160))|(1<<(ClickHouseParserIDENTIFIER-160))|(1<<(ClickHouseParserFLOATING_LITERAL-160))|(1<<(ClickHouseParserOCTAL_LITERAL-160))|(1<<(ClickHouseParserDECIMAL_LITERAL-160))|(1<<(ClickHouseParserHEXADECIMAL_LITERAL-160))|(1<<(ClickHouseParserSTRING_LITERAL-160))|(1<<(ClickHouseParserASTERISK-160)))) != 0) || (((_la-197)&-(0x1f+1)) == 0 && ((1<<uint((_la-197)))&((1<<(ClickHouseParserDASH-197))|(1<<(ClickHouseParserDOT-197))|(1<<(ClickHouseParserLBRACKET-197))|(1<<(ClickHouseParserLPAREN-197))|(1<<(ClickHouseParserPLUS-197)))) != 0) {
			{
				p.SetState(1659)
				p.ColumnArgList()
			}

		}
		{
			p.SetState(1662)
			p.Match(ClickHouseParserRPAREN)
		}

	case 10:
		localctx = NewColumnExprLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1664)
			p.Literal()
		}

	case 11:
		localctx = NewColumnExprNegateContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1665)
			p.Match(ClickHouseParserDASH)
		}
		{
			p.SetState(1666)
			p.columnExpr(17)
		}

	case 12:
		localctx = NewColumnExprNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1667)
			p.Match(ClickHouseParserNOT)
		}
		{
			p.SetState(1668)
			p.columnExpr(12)
		}

	case 13:
		localctx = NewColumnExprAsteriskContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDAY-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserHOUR-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMINUTE-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMONTH-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96))|(1<<(ClickHouseParserQUARTER-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSECOND-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWEEK-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserYEAR-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160))|(1<<(ClickHouseParserIDENTIFIER-160)))) != 0) {
			{
				p.SetState(1669)
				p.TableIdentifier()
			}
			{
				p.SetState(1670)
				p.Match(ClickHouseParserDOT)
			}

		}
		{
			p.SetState(1674)
			p.Match(ClickHouseParserASTERISK)
		}

	case 14:
		localctx = NewColumnExprSubqueryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1675)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1676)
			p.SelectUnionStmt()
		}
		{
			p.SetState(1677)
			p.Match(ClickHouseParserRPAREN)
		}

	case 15:
		localctx = NewColumnExprParensContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1679)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1680)
			p.columnExpr(0)
		}
		{
			p.SetState(1681)
			p.Match(ClickHouseParserRPAREN)
		}

	case 16:
		localctx = NewColumnExprTupleContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1683)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1684)
			p.ColumnExprList()
		}
		{
			p.SetState(1685)
			p.Match(ClickHouseParserRPAREN)
		}

	case 17:
		localctx = NewColumnExprArrayContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1687)
			p.Match(ClickHouseParserLBRACKET)
		}
		p.SetState(1689)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDAY-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserHOUR-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINF-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMINUTE-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMONTH-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNAN_SQL-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULL_SQL-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96))|(1<<(ClickHouseParserQUARTER-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSECOND-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWEEK-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserYEAR-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160))|(1<<(ClickHouseParserIDENTIFIER-160))|(1<<(ClickHouseParserFLOATING_LITERAL-160))|(1<<(ClickHouseParserOCTAL_LITERAL-160))|(1<<(ClickHouseParserDECIMAL_LITERAL-160))|(1<<(ClickHouseParserHEXADECIMAL_LITERAL-160))|(1<<(ClickHouseParserSTRING_LITERAL-160))|(1<<(ClickHouseParserASTERISK-160)))) != 0) || (((_la-197)&-(0x1f+1)) == 0 && ((1<<uint((_la-197)))&((1<<(ClickHouseParserDASH-197))|(1<<(ClickHouseParserDOT-197))|(1<<(ClickHouseParserLBRACKET-197))|(1<<(ClickHouseParserLPAREN-197))|(1<<(ClickHouseParserPLUS-197)))) != 0) {
			{
				p.SetState(1688)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(1691)
			p.Match(ClickHouseParserRBRACKET)
		}

	case 18:
		localctx = NewColumnExprIdentifierContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1692)
			p.ColumnIdentifier()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1766)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 234, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1764)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext()) {
			case 1:
				localctx = NewColumnExprPrecedence1Context(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(1695)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(1696)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-191)&-(0x1f+1)) == 0 && ((1<<uint((_la-191)))&((1<<(ClickHouseParserASTERISK-191))|(1<<(ClickHouseParserPERCENT-191))|(1<<(ClickHouseParserSLASH-191)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1697)
					p.columnExpr(17)
				}

			case 2:
				localctx = NewColumnExprPrecedence2Context(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(1698)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(1699)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(ClickHouseParserCONCAT-196))|(1<<(ClickHouseParserDASH-196))|(1<<(ClickHouseParserPLUS-196)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1700)
					p.columnExpr(16)
				}

			case 3:
				localctx = NewColumnExprPrecedence3Context(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(1701)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				p.SetState(1720)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1702)
						p.Match(ClickHouseParserEQ_DOUBLE)
					}

				case 2:
					{
						p.SetState(1703)
						p.Match(ClickHouseParserEQ_SINGLE)
					}

				case 3:
					{
						p.SetState(1704)
						p.Match(ClickHouseParserNOT_EQ)
					}

				case 4:
					{
						p.SetState(1705)
						p.Match(ClickHouseParserLE)
					}

				case 5:
					{
						p.SetState(1706)
						p.Match(ClickHouseParserGE)
					}

				case 6:
					{
						p.SetState(1707)
						p.Match(ClickHouseParserLT)
					}

				case 7:
					{
						p.SetState(1708)
						p.Match(ClickHouseParserGT)
					}

				case 8:
					p.SetState(1710)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == ClickHouseParserGLOBAL {
						{
							p.SetState(1709)
							p.Match(ClickHouseParserGLOBAL)
						}

					}
					p.SetState(1713)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == ClickHouseParserNOT {
						{
							p.SetState(1712)
							p.Match(ClickHouseParserNOT)
						}

					}
					{
						p.SetState(1715)
						p.Match(ClickHouseParserIN)
					}

				case 9:
					p.SetState(1717)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == ClickHouseParserNOT {
						{
							p.SetState(1716)
							p.Match(ClickHouseParserNOT)
						}

					}
					{
						p.SetState(1719)
						_la = p.GetTokenStream().LA(1)

						if !(_la == ClickHouseParserILIKE || _la == ClickHouseParserLIKE) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}
				{
					p.SetState(1722)
					p.columnExpr(15)
				}

			case 4:
				localctx = NewColumnExprAndContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(1723)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(1724)
					p.Match(ClickHouseParserAND)
				}
				{
					p.SetState(1725)
					p.columnExpr(12)
				}

			case 5:
				localctx = NewColumnExprOrContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(1726)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1727)
					p.Match(ClickHouseParserOR)
				}
				{
					p.SetState(1728)
					p.columnExpr(11)
				}

			case 6:
				localctx = NewColumnExprBetweenContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(1729)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				p.SetState(1731)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ClickHouseParserNOT {
					{
						p.SetState(1730)
						p.Match(ClickHouseParserNOT)
					}

				}
				{
					p.SetState(1733)
					p.Match(ClickHouseParserBETWEEN)
				}
				{
					p.SetState(1734)
					p.columnExpr(0)
				}
				{
					p.SetState(1735)
					p.Match(ClickHouseParserAND)
				}
				{
					p.SetState(1736)
					p.columnExpr(10)
				}

			case 7:
				localctx = NewColumnExprTernaryOpContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(1738)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1739)
					p.Match(ClickHouseParserQUERY)
				}
				{
					p.SetState(1740)
					p.columnExpr(0)
				}
				{
					p.SetState(1741)
					p.Match(ClickHouseParserCOLON)
				}
				{
					p.SetState(1742)
					p.columnExpr(8)
				}

			case 8:
				localctx = NewColumnExprArrayAccessContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(1744)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				{
					p.SetState(1745)
					p.Match(ClickHouseParserLBRACKET)
				}
				{
					p.SetState(1746)
					p.columnExpr(0)
				}
				{
					p.SetState(1747)
					p.Match(ClickHouseParserRBRACKET)
				}

			case 9:
				localctx = NewColumnExprTupleAccessContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(1749)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(1750)
					p.Match(ClickHouseParserDOT)
				}
				{
					p.SetState(1751)
					p.Match(ClickHouseParserDECIMAL_LITERAL)
				}

			case 10:
				localctx = NewColumnExprIsNullContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(1752)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(1753)
					p.Match(ClickHouseParserIS)
				}
				p.SetState(1755)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ClickHouseParserNOT {
					{
						p.SetState(1754)
						p.Match(ClickHouseParserNOT)
					}

				}
				{
					p.SetState(1757)
					p.Match(ClickHouseParserNULL_SQL)
				}

			case 11:
				localctx = NewColumnExprAliasContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(1758)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				p.SetState(1762)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case ClickHouseParserDATE, ClickHouseParserFIRST, ClickHouseParserID, ClickHouseParserKEY, ClickHouseParserIDENTIFIER:
					{
						p.SetState(1759)
						p.Alias()
					}

				case ClickHouseParserAS:
					{
						p.SetState(1760)
						p.Match(ClickHouseParserAS)
					}
					{
						p.SetState(1761)
						p.Identifier()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			}

		}
		p.SetState(1768)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 234, p.GetParserRuleContext())
	}

	return localctx
}

// IColumnArgListContext is an interface to support dynamic dispatch.
type IColumnArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnArgListContext differentiates from other interfaces.
	IsColumnArgListContext()
}

type ColumnArgListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnArgListContext() *ColumnArgListContext {
	var p = new(ColumnArgListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnArgList
	return p
}

func (*ColumnArgListContext) IsColumnArgListContext() {}

func NewColumnArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnArgListContext {
	var p = new(ColumnArgListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnArgList

	return p
}

func (s *ColumnArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnArgListContext) AllColumnArgExpr() []IColumnArgExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnArgExprContext)(nil)).Elem())
	var tst = make([]IColumnArgExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnArgExprContext)
		}
	}

	return tst
}

func (s *ColumnArgListContext) ColumnArgExpr(i int) IColumnArgExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnArgExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnArgExprContext)
}

func (s *ColumnArgListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnArgListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnArgList(s)
	}
}

func (s *ColumnArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnArgList(s)
	}
}

func (p *ClickHouseParser) ColumnArgList() (localctx IColumnArgListContext) {
	localctx = NewColumnArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ClickHouseParserRULE_columnArgList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1769)
		p.ColumnArgExpr()
	}
	p.SetState(1774)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(1770)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(1771)
			p.ColumnArgExpr()
		}

		p.SetState(1776)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IColumnArgExprContext is an interface to support dynamic dispatch.
type IColumnArgExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnArgExprContext differentiates from other interfaces.
	IsColumnArgExprContext()
}

type ColumnArgExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnArgExprContext() *ColumnArgExprContext {
	var p = new(ColumnArgExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnArgExpr
	return p
}

func (*ColumnArgExprContext) IsColumnArgExprContext() {}

func NewColumnArgExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnArgExprContext {
	var p = new(ColumnArgExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnArgExpr

	return p
}

func (s *ColumnArgExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnArgExprContext) ColumnLambdaExpr() IColumnLambdaExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnLambdaExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnLambdaExprContext)
}

func (s *ColumnArgExprContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnArgExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnArgExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnArgExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnArgExpr(s)
	}
}

func (s *ColumnArgExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnArgExpr(s)
	}
}

func (p *ClickHouseParser) ColumnArgExpr() (localctx IColumnArgExprContext) {
	localctx = NewColumnArgExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ClickHouseParserRULE_columnArgExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1779)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1777)
			p.ColumnLambdaExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1778)
			p.columnExpr(0)
		}

	}

	return localctx
}

// IColumnLambdaExprContext is an interface to support dynamic dispatch.
type IColumnLambdaExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnLambdaExprContext differentiates from other interfaces.
	IsColumnLambdaExprContext()
}

type ColumnLambdaExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnLambdaExprContext() *ColumnLambdaExprContext {
	var p = new(ColumnLambdaExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnLambdaExpr
	return p
}

func (*ColumnLambdaExprContext) IsColumnLambdaExprContext() {}

func NewColumnLambdaExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnLambdaExprContext {
	var p = new(ColumnLambdaExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnLambdaExpr

	return p
}

func (s *ColumnLambdaExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnLambdaExprContext) ARROW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserARROW, 0)
}

func (s *ColumnLambdaExprContext) ColumnExpr() IColumnExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnLambdaExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnLambdaExprContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ColumnLambdaExprContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnLambdaExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnLambdaExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnLambdaExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnLambdaExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnLambdaExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnLambdaExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnLambdaExpr(s)
	}
}

func (s *ColumnLambdaExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnLambdaExpr(s)
	}
}

func (p *ClickHouseParser) ColumnLambdaExpr() (localctx IColumnLambdaExprContext) {
	localctx = NewColumnLambdaExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ClickHouseParserRULE_columnLambdaExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1800)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserLPAREN:
		{
			p.SetState(1781)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1782)
			p.Identifier()
		}
		p.SetState(1787)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1783)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(1784)
				p.Identifier()
			}

			p.SetState(1789)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1790)
			p.Match(ClickHouseParserRPAREN)
		}

	case ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALL, ClickHouseParserALTER, ClickHouseParserAND, ClickHouseParserANTI, ClickHouseParserANY, ClickHouseParserARRAY, ClickHouseParserAS, ClickHouseParserASCENDING, ClickHouseParserASOF, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBETWEEN, ClickHouseParserBOTH, ClickHouseParserBY, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCODEC, ClickHouseParserCOLLATE, ClickHouseParserCOLUMN, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCROSS, ClickHouseParserCUBE, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDAY, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDELETE, ClickHouseParserDESC, ClickHouseParserDESCENDING, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTINCT, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserELSE, ClickHouseParserEND, ClickHouseParserENGINE, ClickHouseParserEVENTS, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFINAL, ClickHouseParserFIRST, ClickHouseParserFLUSH, ClickHouseParserFOR, ClickHouseParserFORMAT, ClickHouseParserFREEZE, ClickHouseParserFROM, ClickHouseParserFULL, ClickHouseParserFUNCTION, ClickHouseParserGLOBAL, ClickHouseParserGRANULARITY, ClickHouseParserGROUP, ClickHouseParserHAVING, ClickHouseParserHIERARCHICAL, ClickHouseParserHOUR, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserILIKE, ClickHouseParserIN, ClickHouseParserINDEX, ClickHouseParserINJECTIVE, ClickHouseParserINNER, ClickHouseParserINSERT, ClickHouseParserINTERVAL, ClickHouseParserINTO, ClickHouseParserIS, ClickHouseParserIS_OBJECT_ID, ClickHouseParserJOIN, ClickHouseParserKEY, ClickHouseParserKILL, ClickHouseParserLAST, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLEFT, ClickHouseParserLIFETIME, ClickHouseParserLIKE, ClickHouseParserLIMIT, ClickHouseParserLIVE, ClickHouseParserLOCAL, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMIN, ClickHouseParserMINUTE, ClickHouseParserMODIFY, ClickHouseParserMONTH, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNO, ClickHouseParserNOT, ClickHouseParserNULLS, ClickHouseParserOFFSET, ClickHouseParserON, ClickHouseParserOPTIMIZE, ClickHouseParserOR, ClickHouseParserORDER, ClickHouseParserOUTER, ClickHouseParserOUTFILE, ClickHouseParserPARTITION, ClickHouseParserPOPULATE, ClickHouseParserPREWHERE, ClickHouseParserPRIMARY, ClickHouseParserQUARTER, ClickHouseParserRANGE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserRIGHT, ClickHouseParserROLLUP, ClickHouseParserSAMPLE, ClickHouseParserSECOND, ClickHouseParserSELECT, ClickHouseParserSEMI, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSETTINGS, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTHEN, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTO, ClickHouseParserTOP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNION, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUSING, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserWEEK, ClickHouseParserWHEN, ClickHouseParserWHERE, ClickHouseParserWITH, ClickHouseParserYEAR, ClickHouseParserJSON_FALSE, ClickHouseParserJSON_TRUE, ClickHouseParserIDENTIFIER:
		{
			p.SetState(1792)
			p.Identifier()
		}
		p.SetState(1797)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1793)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(1794)
				p.Identifier()
			}

			p.SetState(1799)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1802)
		p.Match(ClickHouseParserARROW)
	}
	{
		p.SetState(1803)
		p.columnExpr(0)
	}

	return localctx
}

// IColumnIdentifierContext is an interface to support dynamic dispatch.
type IColumnIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnIdentifierContext differentiates from other interfaces.
	IsColumnIdentifierContext()
}

type ColumnIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnIdentifierContext() *ColumnIdentifierContext {
	var p = new(ColumnIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnIdentifier
	return p
}

func (*ColumnIdentifierContext) IsColumnIdentifierContext() {}

func NewColumnIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnIdentifierContext {
	var p = new(ColumnIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnIdentifier

	return p
}

func (s *ColumnIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnIdentifierContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *ColumnIdentifierContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ColumnIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *ColumnIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnIdentifier(s)
	}
}

func (s *ColumnIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnIdentifier(s)
	}
}

func (p *ClickHouseParser) ColumnIdentifier() (localctx IColumnIdentifierContext) {
	localctx = NewColumnIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ClickHouseParserRULE_columnIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1808)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 240, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1805)
			p.TableIdentifier()
		}
		{
			p.SetState(1806)
			p.Match(ClickHouseParserDOT)
		}

	}
	{
		p.SetState(1810)
		p.NestedIdentifier()
	}

	return localctx
}

// INestedIdentifierContext is an interface to support dynamic dispatch.
type INestedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNestedIdentifierContext differentiates from other interfaces.
	IsNestedIdentifierContext()
}

type NestedIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedIdentifierContext() *NestedIdentifierContext {
	var p = new(NestedIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_nestedIdentifier
	return p
}

func (*NestedIdentifierContext) IsNestedIdentifierContext() {}

func NewNestedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedIdentifierContext {
	var p = new(NestedIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_nestedIdentifier

	return p
}

func (s *NestedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedIdentifierContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *NestedIdentifierContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NestedIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *NestedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterNestedIdentifier(s)
	}
}

func (s *NestedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitNestedIdentifier(s)
	}
}

func (p *ClickHouseParser) NestedIdentifier() (localctx INestedIdentifierContext) {
	localctx = NewNestedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ClickHouseParserRULE_nestedIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1812)
		p.Identifier()
	}
	p.SetState(1815)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 241, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1813)
			p.Match(ClickHouseParserDOT)
		}
		{
			p.SetState(1814)
			p.Identifier()
		}

	}

	return localctx
}

// ITableExprContext is an interface to support dynamic dispatch.
type ITableExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableExprContext differentiates from other interfaces.
	IsTableExprContext()
}

type TableExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableExprContext() *TableExprContext {
	var p = new(TableExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableExpr
	return p
}

func (*TableExprContext) IsTableExprContext() {}

func NewTableExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableExprContext {
	var p = new(TableExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableExpr

	return p
}

func (s *TableExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableExprContext) CopyFrom(ctx *TableExprContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableExprIdentifierContext struct {
	*TableExprContext
}

func NewTableExprIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprIdentifierContext {
	var p = new(TableExprIdentifierContext)

	p.TableExprContext = NewEmptyTableExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableExprContext))

	return p
}

func (s *TableExprIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprIdentifierContext) TableIdentifier() ITableIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *TableExprIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableExprIdentifier(s)
	}
}

func (s *TableExprIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableExprIdentifier(s)
	}
}

type TableExprSubqueryContext struct {
	*TableExprContext
}

func NewTableExprSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprSubqueryContext {
	var p = new(TableExprSubqueryContext)

	p.TableExprContext = NewEmptyTableExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableExprContext))

	return p
}

func (s *TableExprSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprSubqueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *TableExprSubqueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectUnionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *TableExprSubqueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *TableExprSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableExprSubquery(s)
	}
}

func (s *TableExprSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableExprSubquery(s)
	}
}

type TableExprAliasContext struct {
	*TableExprContext
}

func NewTableExprAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprAliasContext {
	var p = new(TableExprAliasContext)

	p.TableExprContext = NewEmptyTableExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableExprContext))

	return p
}

func (s *TableExprAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprAliasContext) TableExpr() ITableExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableExprContext)
}

func (s *TableExprAliasContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *TableExprAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *TableExprAliasContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableExprAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableExprAlias(s)
	}
}

func (s *TableExprAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableExprAlias(s)
	}
}

type TableExprFunctionContext struct {
	*TableExprContext
}

func NewTableExprFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprFunctionContext {
	var p = new(TableExprFunctionContext)

	p.TableExprContext = NewEmptyTableExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableExprContext))

	return p
}

func (s *TableExprFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprFunctionContext) TableFunctionExpr() ITableFunctionExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableFunctionExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableFunctionExprContext)
}

func (s *TableExprFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableExprFunction(s)
	}
}

func (s *TableExprFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableExprFunction(s)
	}
}

func (p *ClickHouseParser) TableExpr() (localctx ITableExprContext) {
	return p.tableExpr(0)
}

func (p *ClickHouseParser) tableExpr(_p int) (localctx ITableExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTableExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITableExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 186
	p.EnterRecursionRule(localctx, 186, ClickHouseParserRULE_tableExpr, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1824)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableExprIdentifierContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1818)
			p.TableIdentifier()
		}

	case 2:
		localctx = NewTableExprFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1819)
			p.TableFunctionExpr()
		}

	case 3:
		localctx = NewTableExprSubqueryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1820)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1821)
			p.SelectUnionStmt()
		}
		{
			p.SetState(1822)
			p.Match(ClickHouseParserRPAREN)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1834)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTableExprAliasContext(p, NewTableExprContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_tableExpr)
			p.SetState(1826)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			p.SetState(1830)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ClickHouseParserDATE, ClickHouseParserFIRST, ClickHouseParserID, ClickHouseParserKEY, ClickHouseParserIDENTIFIER:
				{
					p.SetState(1827)
					p.Alias()
				}

			case ClickHouseParserAS:
				{
					p.SetState(1828)
					p.Match(ClickHouseParserAS)
				}
				{
					p.SetState(1829)
					p.Identifier()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(1836)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext())
	}

	return localctx
}

// ITableFunctionExprContext is an interface to support dynamic dispatch.
type ITableFunctionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableFunctionExprContext differentiates from other interfaces.
	IsTableFunctionExprContext()
}

type TableFunctionExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFunctionExprContext() *TableFunctionExprContext {
	var p = new(TableFunctionExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableFunctionExpr
	return p
}

func (*TableFunctionExprContext) IsTableFunctionExprContext() {}

func NewTableFunctionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFunctionExprContext {
	var p = new(TableFunctionExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableFunctionExpr

	return p
}

func (s *TableFunctionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFunctionExprContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableFunctionExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *TableFunctionExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *TableFunctionExprContext) TableArgList() ITableArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableArgListContext)
}

func (s *TableFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableFunctionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableFunctionExpr(s)
	}
}

func (s *TableFunctionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableFunctionExpr(s)
	}
}

func (p *ClickHouseParser) TableFunctionExpr() (localctx ITableFunctionExprContext) {
	localctx = NewTableFunctionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ClickHouseParserRULE_tableFunctionExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1837)
		p.Identifier()
	}
	{
		p.SetState(1838)
		p.Match(ClickHouseParserLPAREN)
	}
	p.SetState(1840)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDAY-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserHOUR-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINF-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMINUTE-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMONTH-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNAN_SQL-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULL_SQL-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96))|(1<<(ClickHouseParserQUARTER-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSECOND-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWEEK-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserYEAR-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160))|(1<<(ClickHouseParserIDENTIFIER-160))|(1<<(ClickHouseParserFLOATING_LITERAL-160))|(1<<(ClickHouseParserOCTAL_LITERAL-160))|(1<<(ClickHouseParserDECIMAL_LITERAL-160))|(1<<(ClickHouseParserHEXADECIMAL_LITERAL-160))|(1<<(ClickHouseParserSTRING_LITERAL-160)))) != 0) || (((_la-197)&-(0x1f+1)) == 0 && ((1<<uint((_la-197)))&((1<<(ClickHouseParserDASH-197))|(1<<(ClickHouseParserDOT-197))|(1<<(ClickHouseParserPLUS-197)))) != 0) {
		{
			p.SetState(1839)
			p.TableArgList()
		}

	}
	{
		p.SetState(1842)
		p.Match(ClickHouseParserRPAREN)
	}

	return localctx
}

// ITableIdentifierContext is an interface to support dynamic dispatch.
type ITableIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableIdentifierContext differentiates from other interfaces.
	IsTableIdentifierContext()
}

type TableIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableIdentifierContext() *TableIdentifierContext {
	var p = new(TableIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableIdentifier
	return p
}

func (*TableIdentifierContext) IsTableIdentifierContext() {}

func NewTableIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableIdentifierContext {
	var p = new(TableIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableIdentifier

	return p
}

func (s *TableIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TableIdentifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableIdentifierContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *TableIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *TableIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableIdentifier(s)
	}
}

func (s *TableIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableIdentifier(s)
	}
}

func (p *ClickHouseParser) TableIdentifier() (localctx ITableIdentifierContext) {
	localctx = NewTableIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ClickHouseParserRULE_tableIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1847)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1844)
			p.DatabaseIdentifier()
		}
		{
			p.SetState(1845)
			p.Match(ClickHouseParserDOT)
		}

	}
	{
		p.SetState(1849)
		p.Identifier()
	}

	return localctx
}

// ITableArgListContext is an interface to support dynamic dispatch.
type ITableArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableArgListContext differentiates from other interfaces.
	IsTableArgListContext()
}

type TableArgListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableArgListContext() *TableArgListContext {
	var p = new(TableArgListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableArgList
	return p
}

func (*TableArgListContext) IsTableArgListContext() {}

func NewTableArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableArgListContext {
	var p = new(TableArgListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableArgList

	return p
}

func (s *TableArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableArgListContext) AllTableArgExpr() []ITableArgExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableArgExprContext)(nil)).Elem())
	var tst = make([]ITableArgExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableArgExprContext)
		}
	}

	return tst
}

func (s *TableArgListContext) TableArgExpr(i int) ITableArgExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableArgExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableArgExprContext)
}

func (s *TableArgListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *TableArgListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *TableArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableArgList(s)
	}
}

func (s *TableArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableArgList(s)
	}
}

func (p *ClickHouseParser) TableArgList() (localctx ITableArgListContext) {
	localctx = NewTableArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ClickHouseParserRULE_tableArgList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1851)
		p.TableArgExpr()
	}
	p.SetState(1856)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(1852)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(1853)
			p.TableArgExpr()
		}

		p.SetState(1858)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableArgExprContext is an interface to support dynamic dispatch.
type ITableArgExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableArgExprContext differentiates from other interfaces.
	IsTableArgExprContext()
}

type TableArgExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableArgExprContext() *TableArgExprContext {
	var p = new(TableArgExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableArgExpr
	return p
}

func (*TableArgExprContext) IsTableArgExprContext() {}

func NewTableArgExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableArgExprContext {
	var p = new(TableArgExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableArgExpr

	return p
}

func (s *TableArgExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableArgExprContext) NestedIdentifier() INestedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *TableArgExprContext) TableFunctionExpr() ITableFunctionExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableFunctionExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableFunctionExprContext)
}

func (s *TableArgExprContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *TableArgExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableArgExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableArgExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableArgExpr(s)
	}
}

func (s *TableArgExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableArgExpr(s)
	}
}

func (p *ClickHouseParser) TableArgExpr() (localctx ITableArgExprContext) {
	localctx = NewTableArgExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ClickHouseParserRULE_tableArgExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1862)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 248, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1859)
			p.NestedIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1860)
			p.TableFunctionExpr()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1861)
			p.Literal()
		}

	}

	return localctx
}

// IDatabaseIdentifierContext is an interface to support dynamic dispatch.
type IDatabaseIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatabaseIdentifierContext differentiates from other interfaces.
	IsDatabaseIdentifierContext()
}

type DatabaseIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseIdentifierContext() *DatabaseIdentifierContext {
	var p = new(DatabaseIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_databaseIdentifier
	return p
}

func (*DatabaseIdentifierContext) IsDatabaseIdentifierContext() {}

func NewDatabaseIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseIdentifierContext {
	var p = new(DatabaseIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_databaseIdentifier

	return p
}

func (s *DatabaseIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseIdentifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DatabaseIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDatabaseIdentifier(s)
	}
}

func (s *DatabaseIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDatabaseIdentifier(s)
	}
}

func (p *ClickHouseParser) DatabaseIdentifier() (localctx IDatabaseIdentifierContext) {
	localctx = NewDatabaseIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ClickHouseParserRULE_databaseIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1864)
		p.Identifier()
	}

	return localctx
}

// IFloatingLiteralContext is an interface to support dynamic dispatch.
type IFloatingLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloatingLiteralContext differentiates from other interfaces.
	IsFloatingLiteralContext()
}

type FloatingLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatingLiteralContext() *FloatingLiteralContext {
	var p = new(FloatingLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_floatingLiteral
	return p
}

func (*FloatingLiteralContext) IsFloatingLiteralContext() {}

func NewFloatingLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatingLiteralContext {
	var p = new(FloatingLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_floatingLiteral

	return p
}

func (s *FloatingLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatingLiteralContext) FLOATING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFLOATING_LITERAL, 0)
}

func (s *FloatingLiteralContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *FloatingLiteralContext) AllDECIMAL_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserDECIMAL_LITERAL)
}

func (s *FloatingLiteralContext) DECIMAL_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, i)
}

func (s *FloatingLiteralContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOCTAL_LITERAL, 0)
}

func (s *FloatingLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatingLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatingLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFloatingLiteral(s)
	}
}

func (s *FloatingLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFloatingLiteral(s)
	}
}

func (p *ClickHouseParser) FloatingLiteral() (localctx IFloatingLiteralContext) {
	localctx = NewFloatingLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ClickHouseParserRULE_floatingLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1874)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserFLOATING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1866)
			p.Match(ClickHouseParserFLOATING_LITERAL)
		}

	case ClickHouseParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1867)
			p.Match(ClickHouseParserDOT)
		}
		{
			p.SetState(1868)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserOCTAL_LITERAL || _la == ClickHouseParserDECIMAL_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case ClickHouseParserDECIMAL_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1869)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
		}
		{
			p.SetState(1870)
			p.Match(ClickHouseParserDOT)
		}
		p.SetState(1872)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1871)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserOCTAL_LITERAL || _la == ClickHouseParserDECIMAL_LITERAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_numberLiteral
	return p
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) FloatingLiteral() IFloatingLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloatingLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloatingLiteralContext)
}

func (s *NumberLiteralContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOCTAL_LITERAL, 0)
}

func (s *NumberLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *NumberLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHEXADECIMAL_LITERAL, 0)
}

func (s *NumberLiteralContext) INF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINF, 0)
}

func (s *NumberLiteralContext) NAN_SQL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNAN_SQL, 0)
}

func (s *NumberLiteralContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPLUS, 0)
}

func (s *NumberLiteralContext) DASH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDASH, 0)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (p *ClickHouseParser) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ClickHouseParserRULE_numberLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1877)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserDASH || _la == ClickHouseParserPLUS {
		{
			p.SetState(1876)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserDASH || _la == ClickHouseParserPLUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1885)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 252, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1879)
			p.FloatingLiteral()
		}

	case 2:
		{
			p.SetState(1880)
			p.Match(ClickHouseParserOCTAL_LITERAL)
		}

	case 3:
		{
			p.SetState(1881)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
		}

	case 4:
		{
			p.SetState(1882)
			p.Match(ClickHouseParserHEXADECIMAL_LITERAL)
		}

	case 5:
		{
			p.SetState(1883)
			p.Match(ClickHouseParserINF)
		}

	case 6:
		{
			p.SetState(1884)
			p.Match(ClickHouseParserNAN_SQL)
		}

	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumberLiteral() INumberLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *LiteralContext) NULL_SQL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNULL_SQL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *ClickHouseParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ClickHouseParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1890)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserINF, ClickHouseParserNAN_SQL, ClickHouseParserFLOATING_LITERAL, ClickHouseParserOCTAL_LITERAL, ClickHouseParserDECIMAL_LITERAL, ClickHouseParserHEXADECIMAL_LITERAL, ClickHouseParserDASH, ClickHouseParserDOT, ClickHouseParserPLUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1887)
			p.NumberLiteral()
		}

	case ClickHouseParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1888)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	case ClickHouseParserNULL_SQL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1889)
			p.Match(ClickHouseParserNULL_SQL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_interval
	return p
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) SECOND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSECOND, 0)
}

func (s *IntervalContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMINUTE, 0)
}

func (s *IntervalContext) HOUR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHOUR, 0)
}

func (s *IntervalContext) DAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDAY, 0)
}

func (s *IntervalContext) WEEK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWEEK, 0)
}

func (s *IntervalContext) MONTH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMONTH, 0)
}

func (s *IntervalContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUARTER, 0)
}

func (s *IntervalContext) YEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserYEAR, 0)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *ClickHouseParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ClickHouseParserRULE_interval)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1892)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserDAY || _la == ClickHouseParserHOUR || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(ClickHouseParserMINUTE-105))|(1<<(ClickHouseParserMONTH-105))|(1<<(ClickHouseParserQUARTER-105)))) != 0) || _la == ClickHouseParserSECOND || _la == ClickHouseParserWEEK || _la == ClickHouseParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_keyword
	return p
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAFTER, 0)
}

func (s *KeywordContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALIAS, 0)
}

func (s *KeywordContext) ALL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALL, 0)
}

func (s *KeywordContext) ALTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALTER, 0)
}

func (s *KeywordContext) AND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAND, 0)
}

func (s *KeywordContext) ANTI() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANTI, 0)
}

func (s *KeywordContext) ANY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANY, 0)
}

func (s *KeywordContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserARRAY, 0)
}

func (s *KeywordContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *KeywordContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASCENDING, 0)
}

func (s *KeywordContext) ASOF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASOF, 0)
}

func (s *KeywordContext) AST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAST, 0)
}

func (s *KeywordContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASYNC, 0)
}

func (s *KeywordContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *KeywordContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBETWEEN, 0)
}

func (s *KeywordContext) BOTH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBOTH, 0)
}

func (s *KeywordContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *KeywordContext) CASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCASE, 0)
}

func (s *KeywordContext) CAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCAST, 0)
}

func (s *KeywordContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCHECK, 0)
}

func (s *KeywordContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLEAR, 0)
}

func (s *KeywordContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLUSTER, 0)
}

func (s *KeywordContext) CODEC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCODEC, 0)
}

func (s *KeywordContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLLATE, 0)
}

func (s *KeywordContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *KeywordContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMENT, 0)
}

func (s *KeywordContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCONSTRAINT, 0)
}

func (s *KeywordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *KeywordContext) CROSS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCROSS, 0)
}

func (s *KeywordContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCUBE, 0)
}

func (s *KeywordContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASE, 0)
}

func (s *KeywordContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASES, 0)
}

func (s *KeywordContext) DATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATE, 0)
}

func (s *KeywordContext) DEDUPLICATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEDUPLICATE, 0)
}

func (s *KeywordContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEFAULT, 0)
}

func (s *KeywordContext) DELAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDELAY, 0)
}

func (s *KeywordContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDELETE, 0)
}

func (s *KeywordContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESCRIBE, 0)
}

func (s *KeywordContext) DESC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESC, 0)
}

func (s *KeywordContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESCENDING, 0)
}

func (s *KeywordContext) DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDETACH, 0)
}

func (s *KeywordContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARIES, 0)
}

func (s *KeywordContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *KeywordContext) DISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISK, 0)
}

func (s *KeywordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTINCT, 0)
}

func (s *KeywordContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTRIBUTED, 0)
}

func (s *KeywordContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *KeywordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserELSE, 0)
}

func (s *KeywordContext) END() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEND, 0)
}

func (s *KeywordContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserENGINE, 0)
}

func (s *KeywordContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEVENTS, 0)
}

func (s *KeywordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *KeywordContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXPLAIN, 0)
}

func (s *KeywordContext) EXPRESSION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXPRESSION, 0)
}

func (s *KeywordContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXTRACT, 0)
}

func (s *KeywordContext) FETCHES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFETCHES, 0)
}

func (s *KeywordContext) FINAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFINAL, 0)
}

func (s *KeywordContext) FIRST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFIRST, 0)
}

func (s *KeywordContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFLUSH, 0)
}

func (s *KeywordContext) FOR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFOR, 0)
}

func (s *KeywordContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFORMAT, 0)
}

func (s *KeywordContext) FREEZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFREEZE, 0)
}

func (s *KeywordContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *KeywordContext) FULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFULL, 0)
}

func (s *KeywordContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFUNCTION, 0)
}

func (s *KeywordContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGLOBAL, 0)
}

func (s *KeywordContext) GRANULARITY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGRANULARITY, 0)
}

func (s *KeywordContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGROUP, 0)
}

func (s *KeywordContext) HAVING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHAVING, 0)
}

func (s *KeywordContext) HIERARCHICAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHIERARCHICAL, 0)
}

func (s *KeywordContext) ID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserID, 0)
}

func (s *KeywordContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *KeywordContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *KeywordContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *KeywordContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *KeywordContext) INJECTIVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINJECTIVE, 0)
}

func (s *KeywordContext) INNER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINNER, 0)
}

func (s *KeywordContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINSERT, 0)
}

func (s *KeywordContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTERVAL, 0)
}

func (s *KeywordContext) INTO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTO, 0)
}

func (s *KeywordContext) IS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIS, 0)
}

func (s *KeywordContext) IS_OBJECT_ID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIS_OBJECT_ID, 0)
}

func (s *KeywordContext) JOIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJOIN, 0)
}

func (s *KeywordContext) JSON_FALSE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJSON_FALSE, 0)
}

func (s *KeywordContext) JSON_TRUE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJSON_TRUE, 0)
}

func (s *KeywordContext) KEY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKEY, 0)
}

func (s *KeywordContext) KILL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKILL, 0)
}

func (s *KeywordContext) LAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLAST, 0)
}

func (s *KeywordContext) LAYOUT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLAYOUT, 0)
}

func (s *KeywordContext) LEADING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLEADING, 0)
}

func (s *KeywordContext) LEFT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLEFT, 0)
}

func (s *KeywordContext) LIFETIME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIFETIME, 0)
}

func (s *KeywordContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *KeywordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *KeywordContext) LIVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIVE, 0)
}

func (s *KeywordContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLOCAL, 0)
}

func (s *KeywordContext) LOGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLOGS, 0)
}

func (s *KeywordContext) MATERIALIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZE, 0)
}

func (s *KeywordContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZED, 0)
}

func (s *KeywordContext) MAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMAX, 0)
}

func (s *KeywordContext) MERGES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMERGES, 0)
}

func (s *KeywordContext) MIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMIN, 0)
}

func (s *KeywordContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *KeywordContext) MOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMOVE, 0)
}

func (s *KeywordContext) MUTATION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMUTATION, 0)
}

func (s *KeywordContext) NO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNO, 0)
}

func (s *KeywordContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *KeywordContext) NULLS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNULLS, 0)
}

func (s *KeywordContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOFFSET, 0)
}

func (s *KeywordContext) ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserON, 0)
}

func (s *KeywordContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOPTIMIZE, 0)
}

func (s *KeywordContext) OR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOR, 0)
}

func (s *KeywordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserORDER, 0)
}

func (s *KeywordContext) OUTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOUTER, 0)
}

func (s *KeywordContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOUTFILE, 0)
}

func (s *KeywordContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPARTITION, 0)
}

func (s *KeywordContext) POPULATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPOPULATE, 0)
}

func (s *KeywordContext) PREWHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPREWHERE, 0)
}

func (s *KeywordContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRIMARY, 0)
}

func (s *KeywordContext) RANGE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRANGE, 0)
}

func (s *KeywordContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRELOAD, 0)
}

func (s *KeywordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREMOVE, 0)
}

func (s *KeywordContext) RENAME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRENAME, 0)
}

func (s *KeywordContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLACE, 0)
}

func (s *KeywordContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLICA, 0)
}

func (s *KeywordContext) REPLICATED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLICATED, 0)
}

func (s *KeywordContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRIGHT, 0)
}

func (s *KeywordContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROLLUP, 0)
}

func (s *KeywordContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSAMPLE, 0)
}

func (s *KeywordContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSELECT, 0)
}

func (s *KeywordContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSEMI, 0)
}

func (s *KeywordContext) SENDS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSENDS, 0)
}

func (s *KeywordContext) SET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSET, 0)
}

func (s *KeywordContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETTINGS, 0)
}

func (s *KeywordContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *KeywordContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSOURCE, 0)
}

func (s *KeywordContext) START() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTART, 0)
}

func (s *KeywordContext) STOP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTOP, 0)
}

func (s *KeywordContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSUBSTRING, 0)
}

func (s *KeywordContext) SYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNC, 0)
}

func (s *KeywordContext) SYNTAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNTAX, 0)
}

func (s *KeywordContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYSTEM, 0)
}

func (s *KeywordContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *KeywordContext) TABLES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLES, 0)
}

func (s *KeywordContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *KeywordContext) TEST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEST, 0)
}

func (s *KeywordContext) THEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTHEN, 0)
}

func (s *KeywordContext) TIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIES, 0)
}

func (s *KeywordContext) TIMEOUT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIMEOUT, 0)
}

func (s *KeywordContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIMESTAMP, 0)
}

func (s *KeywordContext) TOTALS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTOTALS, 0)
}

func (s *KeywordContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRAILING, 0)
}

func (s *KeywordContext) TRIM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRIM, 0)
}

func (s *KeywordContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRUNCATE, 0)
}

func (s *KeywordContext) TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, 0)
}

func (s *KeywordContext) TOP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTOP, 0)
}

func (s *KeywordContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *KeywordContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTYPE, 0)
}

func (s *KeywordContext) UNION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUNION, 0)
}

func (s *KeywordContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUPDATE, 0)
}

func (s *KeywordContext) USE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSE, 0)
}

func (s *KeywordContext) USING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSING, 0)
}

func (s *KeywordContext) UUID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUUID, 0)
}

func (s *KeywordContext) VALUES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVALUES, 0)
}

func (s *KeywordContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *KeywordContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVOLUME, 0)
}

func (s *KeywordContext) WATCH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWATCH, 0)
}

func (s *KeywordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHEN, 0)
}

func (s *KeywordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHERE, 0)
}

func (s *KeywordContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (p *ClickHouseParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ClickHouseParserRULE_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1894)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ClickHouseParserAFTER)|(1<<ClickHouseParserALIAS)|(1<<ClickHouseParserALL)|(1<<ClickHouseParserALTER)|(1<<ClickHouseParserAND)|(1<<ClickHouseParserANTI)|(1<<ClickHouseParserANY)|(1<<ClickHouseParserARRAY)|(1<<ClickHouseParserAS)|(1<<ClickHouseParserASCENDING)|(1<<ClickHouseParserASOF)|(1<<ClickHouseParserAST)|(1<<ClickHouseParserASYNC)|(1<<ClickHouseParserATTACH)|(1<<ClickHouseParserBETWEEN)|(1<<ClickHouseParserBOTH)|(1<<ClickHouseParserBY)|(1<<ClickHouseParserCASE)|(1<<ClickHouseParserCAST)|(1<<ClickHouseParserCHECK)|(1<<ClickHouseParserCLEAR)|(1<<ClickHouseParserCLUSTER)|(1<<ClickHouseParserCODEC)|(1<<ClickHouseParserCOLLATE)|(1<<ClickHouseParserCOLUMN)|(1<<ClickHouseParserCOMMENT)|(1<<ClickHouseParserCONSTRAINT)|(1<<ClickHouseParserCREATE)|(1<<ClickHouseParserCROSS)|(1<<ClickHouseParserCUBE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ClickHouseParserDATABASE-32))|(1<<(ClickHouseParserDATABASES-32))|(1<<(ClickHouseParserDATE-32))|(1<<(ClickHouseParserDEDUPLICATE-32))|(1<<(ClickHouseParserDEFAULT-32))|(1<<(ClickHouseParserDELAY-32))|(1<<(ClickHouseParserDELETE-32))|(1<<(ClickHouseParserDESC-32))|(1<<(ClickHouseParserDESCENDING-32))|(1<<(ClickHouseParserDESCRIBE-32))|(1<<(ClickHouseParserDETACH-32))|(1<<(ClickHouseParserDICTIONARIES-32))|(1<<(ClickHouseParserDICTIONARY-32))|(1<<(ClickHouseParserDISK-32))|(1<<(ClickHouseParserDISTINCT-32))|(1<<(ClickHouseParserDISTRIBUTED-32))|(1<<(ClickHouseParserDROP-32))|(1<<(ClickHouseParserELSE-32))|(1<<(ClickHouseParserEND-32))|(1<<(ClickHouseParserENGINE-32))|(1<<(ClickHouseParserEVENTS-32))|(1<<(ClickHouseParserEXISTS-32))|(1<<(ClickHouseParserEXPLAIN-32))|(1<<(ClickHouseParserEXPRESSION-32))|(1<<(ClickHouseParserEXTRACT-32))|(1<<(ClickHouseParserFETCHES-32))|(1<<(ClickHouseParserFINAL-32))|(1<<(ClickHouseParserFIRST-32))|(1<<(ClickHouseParserFLUSH-32))|(1<<(ClickHouseParserFOR-32))|(1<<(ClickHouseParserFORMAT-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ClickHouseParserFREEZE-64))|(1<<(ClickHouseParserFROM-64))|(1<<(ClickHouseParserFULL-64))|(1<<(ClickHouseParserFUNCTION-64))|(1<<(ClickHouseParserGLOBAL-64))|(1<<(ClickHouseParserGRANULARITY-64))|(1<<(ClickHouseParserGROUP-64))|(1<<(ClickHouseParserHAVING-64))|(1<<(ClickHouseParserHIERARCHICAL-64))|(1<<(ClickHouseParserID-64))|(1<<(ClickHouseParserIF-64))|(1<<(ClickHouseParserILIKE-64))|(1<<(ClickHouseParserIN-64))|(1<<(ClickHouseParserINDEX-64))|(1<<(ClickHouseParserINJECTIVE-64))|(1<<(ClickHouseParserINNER-64))|(1<<(ClickHouseParserINSERT-64))|(1<<(ClickHouseParserINTERVAL-64))|(1<<(ClickHouseParserINTO-64))|(1<<(ClickHouseParserIS-64))|(1<<(ClickHouseParserIS_OBJECT_ID-64))|(1<<(ClickHouseParserJOIN-64))|(1<<(ClickHouseParserKEY-64))|(1<<(ClickHouseParserKILL-64))|(1<<(ClickHouseParserLAST-64))|(1<<(ClickHouseParserLAYOUT-64))|(1<<(ClickHouseParserLEADING-64))|(1<<(ClickHouseParserLEFT-64))|(1<<(ClickHouseParserLIFETIME-64))|(1<<(ClickHouseParserLIKE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ClickHouseParserLIMIT-96))|(1<<(ClickHouseParserLIVE-96))|(1<<(ClickHouseParserLOCAL-96))|(1<<(ClickHouseParserLOGS-96))|(1<<(ClickHouseParserMATERIALIZE-96))|(1<<(ClickHouseParserMATERIALIZED-96))|(1<<(ClickHouseParserMAX-96))|(1<<(ClickHouseParserMERGES-96))|(1<<(ClickHouseParserMIN-96))|(1<<(ClickHouseParserMODIFY-96))|(1<<(ClickHouseParserMOVE-96))|(1<<(ClickHouseParserMUTATION-96))|(1<<(ClickHouseParserNO-96))|(1<<(ClickHouseParserNOT-96))|(1<<(ClickHouseParserNULLS-96))|(1<<(ClickHouseParserOFFSET-96))|(1<<(ClickHouseParserON-96))|(1<<(ClickHouseParserOPTIMIZE-96))|(1<<(ClickHouseParserOR-96))|(1<<(ClickHouseParserORDER-96))|(1<<(ClickHouseParserOUTER-96))|(1<<(ClickHouseParserOUTFILE-96))|(1<<(ClickHouseParserPARTITION-96))|(1<<(ClickHouseParserPOPULATE-96))|(1<<(ClickHouseParserPREWHERE-96))|(1<<(ClickHouseParserPRIMARY-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ClickHouseParserRANGE-128))|(1<<(ClickHouseParserRELOAD-128))|(1<<(ClickHouseParserREMOVE-128))|(1<<(ClickHouseParserRENAME-128))|(1<<(ClickHouseParserREPLACE-128))|(1<<(ClickHouseParserREPLICA-128))|(1<<(ClickHouseParserREPLICATED-128))|(1<<(ClickHouseParserRIGHT-128))|(1<<(ClickHouseParserROLLUP-128))|(1<<(ClickHouseParserSAMPLE-128))|(1<<(ClickHouseParserSELECT-128))|(1<<(ClickHouseParserSEMI-128))|(1<<(ClickHouseParserSENDS-128))|(1<<(ClickHouseParserSET-128))|(1<<(ClickHouseParserSETTINGS-128))|(1<<(ClickHouseParserSHOW-128))|(1<<(ClickHouseParserSOURCE-128))|(1<<(ClickHouseParserSTART-128))|(1<<(ClickHouseParserSTOP-128))|(1<<(ClickHouseParserSUBSTRING-128))|(1<<(ClickHouseParserSYNC-128))|(1<<(ClickHouseParserSYNTAX-128))|(1<<(ClickHouseParserSYSTEM-128))|(1<<(ClickHouseParserTABLE-128))|(1<<(ClickHouseParserTABLES-128))|(1<<(ClickHouseParserTEMPORARY-128))|(1<<(ClickHouseParserTEST-128))|(1<<(ClickHouseParserTHEN-128))|(1<<(ClickHouseParserTIES-128))|(1<<(ClickHouseParserTIMEOUT-128))|(1<<(ClickHouseParserTIMESTAMP-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ClickHouseParserTO-160))|(1<<(ClickHouseParserTOP-160))|(1<<(ClickHouseParserTOTALS-160))|(1<<(ClickHouseParserTRAILING-160))|(1<<(ClickHouseParserTRIM-160))|(1<<(ClickHouseParserTRUNCATE-160))|(1<<(ClickHouseParserTTL-160))|(1<<(ClickHouseParserTYPE-160))|(1<<(ClickHouseParserUNION-160))|(1<<(ClickHouseParserUPDATE-160))|(1<<(ClickHouseParserUSE-160))|(1<<(ClickHouseParserUSING-160))|(1<<(ClickHouseParserUUID-160))|(1<<(ClickHouseParserVALUES-160))|(1<<(ClickHouseParserVIEW-160))|(1<<(ClickHouseParserVOLUME-160))|(1<<(ClickHouseParserWATCH-160))|(1<<(ClickHouseParserWHEN-160))|(1<<(ClickHouseParserWHERE-160))|(1<<(ClickHouseParserWITH-160))|(1<<(ClickHouseParserJSON_FALSE-160))|(1<<(ClickHouseParserJSON_TRUE-160)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IKeywordForAliasContext is an interface to support dynamic dispatch.
type IKeywordForAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordForAliasContext differentiates from other interfaces.
	IsKeywordForAliasContext()
}

type KeywordForAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordForAliasContext() *KeywordForAliasContext {
	var p = new(KeywordForAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_keywordForAlias
	return p
}

func (*KeywordForAliasContext) IsKeywordForAliasContext() {}

func NewKeywordForAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordForAliasContext {
	var p = new(KeywordForAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_keywordForAlias

	return p
}

func (s *KeywordForAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordForAliasContext) DATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATE, 0)
}

func (s *KeywordForAliasContext) FIRST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFIRST, 0)
}

func (s *KeywordForAliasContext) ID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserID, 0)
}

func (s *KeywordForAliasContext) KEY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKEY, 0)
}

func (s *KeywordForAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordForAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordForAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterKeywordForAlias(s)
	}
}

func (s *KeywordForAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitKeywordForAlias(s)
	}
}

func (p *ClickHouseParser) KeywordForAlias() (localctx IKeywordForAliasContext) {
	localctx = NewKeywordForAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ClickHouseParserRULE_keywordForAlias)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1896)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserDATE || _la == ClickHouseParserFIRST || _la == ClickHouseParserID || _la == ClickHouseParserKEY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alias
	return p
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIDENTIFIER, 0)
}

func (s *AliasContext) KeywordForAlias() IKeywordForAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordForAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordForAliasContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (p *ClickHouseParser) Alias() (localctx IAliasContext) {
	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ClickHouseParserRULE_alias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1900)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1898)
			p.Match(ClickHouseParserIDENTIFIER)
		}

	case ClickHouseParserDATE, ClickHouseParserFIRST, ClickHouseParserID, ClickHouseParserKEY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1899)
			p.KeywordForAlias()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIDENTIFIER, 0)
}

func (s *IdentifierContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IdentifierContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *ClickHouseParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ClickHouseParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1905)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1902)
			p.Match(ClickHouseParserIDENTIFIER)
		}

	case ClickHouseParserDAY, ClickHouseParserHOUR, ClickHouseParserMINUTE, ClickHouseParserMONTH, ClickHouseParserQUARTER, ClickHouseParserSECOND, ClickHouseParserWEEK, ClickHouseParserYEAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1903)
			p.Interval()
		}

	case ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALL, ClickHouseParserALTER, ClickHouseParserAND, ClickHouseParserANTI, ClickHouseParserANY, ClickHouseParserARRAY, ClickHouseParserAS, ClickHouseParserASCENDING, ClickHouseParserASOF, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBETWEEN, ClickHouseParserBOTH, ClickHouseParserBY, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCODEC, ClickHouseParserCOLLATE, ClickHouseParserCOLUMN, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCROSS, ClickHouseParserCUBE, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDELETE, ClickHouseParserDESC, ClickHouseParserDESCENDING, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTINCT, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserELSE, ClickHouseParserEND, ClickHouseParserENGINE, ClickHouseParserEVENTS, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFINAL, ClickHouseParserFIRST, ClickHouseParserFLUSH, ClickHouseParserFOR, ClickHouseParserFORMAT, ClickHouseParserFREEZE, ClickHouseParserFROM, ClickHouseParserFULL, ClickHouseParserFUNCTION, ClickHouseParserGLOBAL, ClickHouseParserGRANULARITY, ClickHouseParserGROUP, ClickHouseParserHAVING, ClickHouseParserHIERARCHICAL, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserILIKE, ClickHouseParserIN, ClickHouseParserINDEX, ClickHouseParserINJECTIVE, ClickHouseParserINNER, ClickHouseParserINSERT, ClickHouseParserINTERVAL, ClickHouseParserINTO, ClickHouseParserIS, ClickHouseParserIS_OBJECT_ID, ClickHouseParserJOIN, ClickHouseParserKEY, ClickHouseParserKILL, ClickHouseParserLAST, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLEFT, ClickHouseParserLIFETIME, ClickHouseParserLIKE, ClickHouseParserLIMIT, ClickHouseParserLIVE, ClickHouseParserLOCAL, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMIN, ClickHouseParserMODIFY, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNO, ClickHouseParserNOT, ClickHouseParserNULLS, ClickHouseParserOFFSET, ClickHouseParserON, ClickHouseParserOPTIMIZE, ClickHouseParserOR, ClickHouseParserORDER, ClickHouseParserOUTER, ClickHouseParserOUTFILE, ClickHouseParserPARTITION, ClickHouseParserPOPULATE, ClickHouseParserPREWHERE, ClickHouseParserPRIMARY, ClickHouseParserRANGE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserRIGHT, ClickHouseParserROLLUP, ClickHouseParserSAMPLE, ClickHouseParserSELECT, ClickHouseParserSEMI, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSETTINGS, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTHEN, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTO, ClickHouseParserTOP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNION, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUSING, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserWHEN, ClickHouseParserWHERE, ClickHouseParserWITH, ClickHouseParserJSON_FALSE, ClickHouseParserJSON_TRUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1904)
			p.Keyword()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIdentifierOrNullContext is an interface to support dynamic dispatch.
type IIdentifierOrNullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierOrNullContext differentiates from other interfaces.
	IsIdentifierOrNullContext()
}

type IdentifierOrNullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrNullContext() *IdentifierOrNullContext {
	var p = new(IdentifierOrNullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_identifierOrNull
	return p
}

func (*IdentifierOrNullContext) IsIdentifierOrNullContext() {}

func NewIdentifierOrNullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrNullContext {
	var p = new(IdentifierOrNullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_identifierOrNull

	return p
}

func (s *IdentifierOrNullContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrNullContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrNullContext) NULL_SQL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNULL_SQL, 0)
}

func (s *IdentifierOrNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrNullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterIdentifierOrNull(s)
	}
}

func (s *IdentifierOrNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitIdentifierOrNull(s)
	}
}

func (p *ClickHouseParser) IdentifierOrNull() (localctx IIdentifierOrNullContext) {
	localctx = NewIdentifierOrNullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ClickHouseParserRULE_identifierOrNull)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1909)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALL, ClickHouseParserALTER, ClickHouseParserAND, ClickHouseParserANTI, ClickHouseParserANY, ClickHouseParserARRAY, ClickHouseParserAS, ClickHouseParserASCENDING, ClickHouseParserASOF, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBETWEEN, ClickHouseParserBOTH, ClickHouseParserBY, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCODEC, ClickHouseParserCOLLATE, ClickHouseParserCOLUMN, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCROSS, ClickHouseParserCUBE, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDAY, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDELETE, ClickHouseParserDESC, ClickHouseParserDESCENDING, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTINCT, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserELSE, ClickHouseParserEND, ClickHouseParserENGINE, ClickHouseParserEVENTS, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFINAL, ClickHouseParserFIRST, ClickHouseParserFLUSH, ClickHouseParserFOR, ClickHouseParserFORMAT, ClickHouseParserFREEZE, ClickHouseParserFROM, ClickHouseParserFULL, ClickHouseParserFUNCTION, ClickHouseParserGLOBAL, ClickHouseParserGRANULARITY, ClickHouseParserGROUP, ClickHouseParserHAVING, ClickHouseParserHIERARCHICAL, ClickHouseParserHOUR, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserILIKE, ClickHouseParserIN, ClickHouseParserINDEX, ClickHouseParserINJECTIVE, ClickHouseParserINNER, ClickHouseParserINSERT, ClickHouseParserINTERVAL, ClickHouseParserINTO, ClickHouseParserIS, ClickHouseParserIS_OBJECT_ID, ClickHouseParserJOIN, ClickHouseParserKEY, ClickHouseParserKILL, ClickHouseParserLAST, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLEFT, ClickHouseParserLIFETIME, ClickHouseParserLIKE, ClickHouseParserLIMIT, ClickHouseParserLIVE, ClickHouseParserLOCAL, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMIN, ClickHouseParserMINUTE, ClickHouseParserMODIFY, ClickHouseParserMONTH, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNO, ClickHouseParserNOT, ClickHouseParserNULLS, ClickHouseParserOFFSET, ClickHouseParserON, ClickHouseParserOPTIMIZE, ClickHouseParserOR, ClickHouseParserORDER, ClickHouseParserOUTER, ClickHouseParserOUTFILE, ClickHouseParserPARTITION, ClickHouseParserPOPULATE, ClickHouseParserPREWHERE, ClickHouseParserPRIMARY, ClickHouseParserQUARTER, ClickHouseParserRANGE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserRIGHT, ClickHouseParserROLLUP, ClickHouseParserSAMPLE, ClickHouseParserSECOND, ClickHouseParserSELECT, ClickHouseParserSEMI, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSETTINGS, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTHEN, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTO, ClickHouseParserTOP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNION, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUSING, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserWEEK, ClickHouseParserWHEN, ClickHouseParserWHERE, ClickHouseParserWITH, ClickHouseParserYEAR, ClickHouseParserJSON_FALSE, ClickHouseParserJSON_TRUE, ClickHouseParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1907)
			p.Identifier()
		}

	case ClickHouseParserNULL_SQL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1908)
			p.Match(ClickHouseParserNULL_SQL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumValueContext is an interface to support dynamic dispatch.
type IEnumValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumValueContext differentiates from other interfaces.
	IsEnumValueContext()
}

type EnumValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueContext() *EnumValueContext {
	var p = new(EnumValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_enumValue
	return p
}

func (*EnumValueContext) IsEnumValueContext() {}

func NewEnumValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueContext {
	var p = new(EnumValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_enumValue

	return p
}

func (s *EnumValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *EnumValueContext) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_SINGLE, 0)
}

func (s *EnumValueContext) NumberLiteral() INumberLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *EnumValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterEnumValue(s)
	}
}

func (s *EnumValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitEnumValue(s)
	}
}

func (p *ClickHouseParser) EnumValue() (localctx IEnumValueContext) {
	localctx = NewEnumValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ClickHouseParserRULE_enumValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1911)
		p.Match(ClickHouseParserSTRING_LITERAL)
	}
	{
		p.SetState(1912)
		p.Match(ClickHouseParserEQ_SINGLE)
	}
	{
		p.SetState(1913)
		p.NumberLiteral()
	}

	return localctx
}

func (p *ClickHouseParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 12:
		var t *DictionaryAttrDfntContext = nil
		if localctx != nil {
			t = localctx.(*DictionaryAttrDfntContext)
		}
		return p.DictionaryAttrDfnt_Sempred(t, predIndex)

	case 13:
		var t *DictionaryEngineClauseContext = nil
		if localctx != nil {
			t = localctx.(*DictionaryEngineClauseContext)
		}
		return p.DictionaryEngineClause_Sempred(t, predIndex)

	case 26:
		var t *EngineClauseContext = nil
		if localctx != nil {
			t = localctx.(*EngineClauseContext)
		}
		return p.EngineClause_Sempred(t, predIndex)

	case 67:
		var t *JoinExprContext = nil
		if localctx != nil {
			t = localctx.(*JoinExprContext)
		}
		return p.JoinExpr_Sempred(t, predIndex)

	case 87:
		var t *ColumnExprContext = nil
		if localctx != nil {
			t = localctx.(*ColumnExprContext)
		}
		return p.ColumnExpr_Sempred(t, predIndex)

	case 93:
		var t *TableExprContext = nil
		if localctx != nil {
			t = localctx.(*TableExprContext)
		}
		return p.TableExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ClickHouseParser) DictionaryAttrDfnt_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return !localctx.(*DictionaryAttrDfntContext).attrs["default"]

	case 1:
		return !localctx.(*DictionaryAttrDfntContext).attrs["expression"]

	case 2:
		return !localctx.(*DictionaryAttrDfntContext).attrs["hierarchical"]

	case 3:
		return !localctx.(*DictionaryAttrDfntContext).attrs["injective"]

	case 4:
		return !localctx.(*DictionaryAttrDfntContext).attrs["is_object_id"]

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ClickHouseParser) DictionaryEngineClause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return !localctx.(*DictionaryEngineClauseContext).clauses["source"]

	case 6:
		return !localctx.(*DictionaryEngineClauseContext).clauses["lifetime"]

	case 7:
		return !localctx.(*DictionaryEngineClauseContext).clauses["layout"]

	case 8:
		return !localctx.(*DictionaryEngineClauseContext).clauses["range"]

	case 9:
		return !localctx.(*DictionaryEngineClauseContext).clauses["settings"]

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ClickHouseParser) EngineClause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return !localctx.(*EngineClauseContext).clauses["orderByClause"]

	case 11:
		return !localctx.(*EngineClauseContext).clauses["partitionByClause"]

	case 12:
		return !localctx.(*EngineClauseContext).clauses["primaryKeyClause"]

	case 13:
		return !localctx.(*EngineClauseContext).clauses["sampleByClause"]

	case 14:
		return !localctx.(*EngineClauseContext).clauses["ttlClause"]

	case 15:
		return !localctx.(*EngineClauseContext).clauses["settingsClause"]

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ClickHouseParser) JoinExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ClickHouseParser) ColumnExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 18:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 24:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 26:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 27:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 28:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ClickHouseParser) TableExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 29:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
